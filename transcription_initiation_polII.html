<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="ui-lang" content="ru" />
  <title>Инициация транскрипции Pol II — схема процесса</title>
  <!-- Spec-Version: v1.1 | Generated-At: 2025-09-29 | LANG: HTML | TOPIC: Transcription initiation (Pol II, +1 TSS) | ORG: eukaryote | LEVEL: advanced | VIEW: process | THEME: print | EXPORTS: svg,png,pdf | LAYOUT: A4-landscape | INTERACTIVE: on -->
  <style>
    :root {
      color-scheme: only light;
      font-family: "Fira Sans", "Segoe UI", system-ui, sans-serif;
      --bg: #ffffff;
      --ink: #111111;
      --accent: #1d4ed8;
      --accent-soft: rgba(29, 78, 216, 0.12);
      --accent-strong: rgba(29, 78, 216, 0.75);
      --muted: #555555;
      --grid-line: rgba(0, 0, 0, 0.08);
      --highlight: #d97706;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--ink);
      height: 100%;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 12mm;
    }
    .page {
      width: 297mm;
      height: 210mm;
      background: var(--bg);
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 8mm;
      padding: 14mm 18mm;
      position: relative;
      overflow: hidden;
    }
    .page::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image: linear-gradient(to right, transparent 0, transparent 28mm, var(--grid-line) 28mm, transparent 28.5mm),
        linear-gradient(to bottom, transparent 0, transparent 28mm, var(--grid-line) 28mm, transparent 28.5mm);
      opacity: 0.45;
      pointer-events: none;
    }
    header {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: start;
      gap: 12mm;
    }
    header h1 {
      margin: 0;
      font-size: 22pt;
      letter-spacing: -0.4pt;
    }
    header .meta {
      text-align: right;
      font-size: 9pt;
      line-height: 1.4;
      color: var(--muted);
    }
    main {
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 10mm;
    }
    .block {
      background: rgba(255,255,255,0.94);
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 6px;
      padding: 6mm;
      position: relative;
      overflow: hidden;
    }
    .block h2 {
      margin-top: 0;
      font-size: 14pt;
      letter-spacing: -0.2pt;
    }
    .block p, .block li {
      font-size: 10pt;
      line-height: 1.45;
    }
    .block ul {
      margin: 0;
      padding-left: 4mm;
      list-style: square;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 2mm;
      background: var(--accent-soft);
      color: var(--accent);
      border-radius: 999px;
      padding: 1mm 4mm;
      font-size: 8pt;
      text-transform: uppercase;
      letter-spacing: 0.6pt;
    }
    .flow-map {
      position: relative;
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 4mm;
    }
    .map-stage {
      display: flex;
      flex-direction: column;
      gap: 3mm;
      flex: 1;
      min-height: 0;
    }
    .map-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 3mm;
      align-items: center;
    }
    .map-toolbar button,
    .map-toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 2mm;
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 999px;
      background: #f8fafc;
      padding: 2mm 4mm;
      font-size: 8.5pt;
      cursor: pointer;
      transition: background 0.2s, border 0.2s, color 0.2s;
    }
    .map-toolbar button:focus-visible,
    .map-toolbar label:focus-within {
      outline: 2px solid var(--accent);
      outline-offset: 1mm;
    }
    .map-toolbar button.active {
      background: var(--accent);
      color: #ffffff;
      border-color: var(--accent);
    }
    .map-toolbar input[type="checkbox"] {
      accent-color: var(--accent);
    }
    .map-canvas {
      position: relative;
      flex: 1;
      border: 1px solid rgba(0,0,0,0.14);
      border-radius: 8px;
      overflow: hidden;
      background:
        linear-gradient(to right, rgba(29, 78, 216, 0.12) 0 1px, transparent 1px 120px) 0 0 / 120px 120px,
        linear-gradient(to bottom, rgba(29, 78, 216, 0.08) 0 1px, transparent 1px 120px) 0 0 / 120px 120px,
        linear-gradient(to right, rgba(148, 163, 184, 0.18) 0 1px, transparent 1px 24px) 0 0 / 24px 24px,
        linear-gradient(to bottom, rgba(148, 163, 184, 0.18) 0 1px, transparent 1px 24px) 0 0 / 24px 24px,
        #f8fafc;
      touch-action: none;
      min-height: 0;
      cursor: grab;
    }
    .map-canvas:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 1mm;
    }
    .map-canvas.panning {
      cursor: grabbing;
    }
    .map-canvas.no-grid {
      background: #f8fafc;
    }
    .map-viewport {
      position: absolute;
      inset: 0;
      transform-origin: top left;
      width: 960px;
      height: 520px;
    }
    .map-background {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .node-layer {
      position: absolute;
      inset: 0;
    }
    .edge-layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }
    .edge-layer path {
      fill: none;
      stroke-width: 2.5px;
    }
    .edge-layer path[data-kind="flow"] {
      stroke: var(--accent);
    }
    .edge-layer path[data-kind="regulation"] {
      stroke: #b91c1c;
      stroke-dasharray: 6 3;
    }
    .node {
      position: absolute;
      border-radius: 10px;
      border: 1px solid rgba(15, 23, 42, 0.12);
      padding: 6px 8px;
      background: rgba(255,255,255,0.96);
      min-width: 96px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      cursor: grab;
      box-shadow: 0 3px 10px rgba(15, 23, 42, 0.08);
      transition: box-shadow 0.2s;
    }
    .node:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .node.dragging {
      cursor: grabbing;
      box-shadow: 0 10px 24px rgba(29, 78, 216, 0.28);
    }
    .node[data-layer="chromatin"] {
      background: rgba(74, 222, 128, 0.16);
      border-color: #4d7c0f;
    }
    .node[data-layer="rna"] {
      background: rgba(254, 202, 202, 0.2);
      border-color: #b91c1c;
    }
    .node[data-layer="factors"] {
      background: rgba(199, 210, 254, 0.22);
      border-color: #4338ca;
    }
    .node[data-layer="annotations"] {
      background: rgba(226, 232, 240, 0.6);
      border-color: rgba(15, 23, 42, 0.18);
    }
    .node-title {
      font-size: 10.5pt;
      font-weight: 600;
      color: var(--ink);
      display: flex;
      justify-content: space-between;
      gap: 6px;
      align-items: center;
    }
    .node-type {
      font-size: 7.5pt;
      text-transform: uppercase;
      letter-spacing: 0.6pt;
      color: var(--muted);
      background: rgba(15, 23, 42, 0.08);
      border-radius: 999px;
      padding: 2px 6px;
      flex-shrink: 0;
    }
    .node-notes {
      margin: 0;
      padding-left: 16px;
      font-size: 8.5pt;
      line-height: 1.4;
      color: var(--muted);
    }
    .node-handle {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      font-size: 8pt;
      color: var(--accent);
    }
    .node-handle svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
    .axis-label {
      position: absolute;
      left: 16px;
      top: -26px;
      font-size: 8pt;
      color: var(--muted);
      letter-spacing: 0.4pt;
      text-transform: uppercase;
    }
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 4mm;
      margin-top: 4mm;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 2mm;
      font-size: 8.5pt;
      color: var(--muted);
    }
    .legend-swatch {
      width: 8mm;
      height: 3mm;
      border-radius: 2mm;
      background: var(--accent-strong);
    }
    .legend-item[data-type="chromatin"] .legend-swatch {
      background: #4d7c0f;
    }
    .legend-item[data-type="rna"] .legend-swatch {
      background: #b91c1c;
    }
    .visually-hidden {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .data-model {
      grid-column: span 2;
    }
    .data-model h2 {
      display: flex;
      align-items: baseline;
      gap: 3mm;
      flex-wrap: wrap;
    }
    .data-model h2 .subheading {
      font-size: 8pt;
      font-weight: 600;
      letter-spacing: 0.6pt;
      text-transform: uppercase;
      color: var(--muted);
      background: rgba(17, 24, 39, 0.06);
      padding: 1mm 3mm;
      border-radius: 999px;
    }
    .model-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 3mm;
      margin: 4mm 0;
    }
    .model-tabs button {
      border: 1px solid rgba(0,0,0,0.16);
      border-radius: 999px;
      padding: 2mm 4mm;
      background: #f8fafc;
      font-size: 8.5pt;
      letter-spacing: 0.2pt;
      cursor: pointer;
      transition: background 0.2s, border 0.2s, color 0.2s;
    }
    .model-tabs button.active {
      background: var(--accent);
      color: #ffffff;
      border-color: var(--accent);
    }
    .model-panel {
      background: #f8fafc;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 5px;
      padding: 5mm;
      display: grid;
      gap: 3mm;
    }
    .model-panel h3 {
      margin: 0;
      font-size: 12pt;
    }
    .model-panel ul {
      margin: 0;
      padding-left: 4mm;
      font-size: 9.5pt;
      line-height: 1.45;
    }
    .model-panel .callout {
      font-size: 8.5pt;
      color: var(--muted);
      background: rgba(29, 78, 216, 0.08);
      border-left: 2px solid var(--accent);
      padding: 2mm 3mm;
      border-radius: 3px;
    }
    .model-panel pre {
      margin: 0;
      font-size: 8pt;
      line-height: 1.45;
      background: rgba(15, 23, 42, 0.08);
      padding: 3mm;
      border-radius: 4px;
      overflow-x: auto;
    }
    .timeline {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 3mm;
      margin-top: 4mm;
    }
    .timeline button {
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 4px;
      padding: 4mm 3mm;
      background: #f8fafc;
      font-size: 9pt;
      cursor: pointer;
      text-align: left;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .timeline button.active {
      border-color: var(--accent);
      box-shadow: 0 4px 10px rgba(29,78,216,0.18);
      transform: translateY(-1mm);
    }
    .timeline button span {
      display: block;
    }
    .timeline button .title {
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 1mm;
    }
    .timeline button .detail {
      color: var(--muted);
      line-height: 1.4;
    }
    .step-panel {
      margin-top: 5mm;
      background: #f1f5f9;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 5px;
      padding: 5mm;
      min-height: 42mm;
    }
    .step-panel h3 {
      margin: 0 0 2mm;
      font-size: 12pt;
    }
    .step-panel ul {
      margin: 0;
      padding-left: 4mm;
    }
    .regulation-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 4mm;
      margin-top: 4mm;
    }
    .chip {
      background: rgba(0,0,0,0.04);
      border: 1px dashed rgba(0,0,0,0.2);
      border-radius: 5px;
      padding: 3mm;
      font-size: 8.5pt;
      line-height: 1.4;
    }
    footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 8pt;
      color: var(--muted);
    }
    footer .controls {
      display: flex;
      gap: 4mm;
    }
    footer button {
      padding: 2.5mm 4.5mm;
      font-size: 8pt;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.2);
      background: #ffffff;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    footer button:hover {
      background: var(--accent);
      color: #ffffff;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.98);
      display: none;
      flex-direction: column;
      padding: 18mm;
      gap: 6mm;
    }
    .overlay.active {
      display: flex;
    }
    .overlay h2 {
      margin: 0;
      font-size: 16pt;
    }
    .overlay table {
      border-collapse: collapse;
      width: 100%;
      font-size: 9.5pt;
    }
    .overlay th, .overlay td {
      border: 1px solid rgba(0,0,0,0.2);
      padding: 2.5mm;
      text-align: left;
    }
    .close-overlay {
      align-self: flex-end;
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 2mm 5mm;
      border-radius: 4px;
      font-size: 9pt;
      cursor: pointer;
    }
    @media print {
      body {
        padding: 0;
        box-shadow: none;
      }
      .page {
        margin: 0;
        box-shadow: none;
        border: none;
      }
      footer button {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="page" role="document" aria-label="">
    <header>
      <div>
        <h1 id="header-title"></h1>
        <div class="pill" id="header-pill"></div>
      </div>
      <div class="meta">
        <div id="meta-environment"></div>
        <div id="meta-context"></div>
        <div id="meta-focus"></div>
      </div>
    </header>
    <main>
      <section class="block flow-map" aria-labelledby="map-title">
        <h2 id="map-title"></h2>
        <div class="map-stage" role="application" aria-labelledby="map-title" aria-describedby="map-instructions">
          <div class="map-toolbar" role="group" aria-label="" id="map-toolbar">
            <button type="button" id="fit-to-view"></button>
            <button type="button" id="toggle-grid" class="active" aria-pressed="true"></button>
            <label for="snap-to-grid" class="snap-option">
            <input type="checkbox" id="snap-to-grid" checked />
            <span id="snap-label-text"></span>
          </label>
            <span aria-hidden="true">·</span>
            <button type="button" id="reset-overlap"></button>
          </div>
          <div class="map-canvas" id="map-canvas" tabindex="0" aria-label="" role="region">
            <div class="axis-label" aria-hidden="true" id="axis-label"></div>
            <div class="map-viewport" id="map-viewport">
              <svg class="edge-layer" id="edge-layer" viewBox="0 0 960 520" aria-hidden="true">
                <defs>
                  <marker id="arrow-flow" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--accent)"></path>
                  </marker>
                  <marker id="arrow-regulation" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#b91c1c"></path>
                  </marker>
                  <marker id="tee-regulation" viewBox="0 0 10 10" refX="2" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto">
                    <path d="M 2 0 L 2 10" stroke="#b91c1c" stroke-width="2"></path>
                  </marker>
                </defs>
              </svg>
              <div class="node-layer" id="node-layer" aria-live="polite"></div>
            </div>
          </div>
          <p class="visually-hidden" id="map-instructions"></p>
        </div>
        <div class="legend" aria-label="" id="legend">
          <div class="legend-item" data-type="polii"><span class="legend-swatch"></span><span id="legend-polii"></span></div>
          <div class="legend-item" data-type="chromatin"><span class="legend-swatch"></span><span id="legend-chromatin"></span></div>
          <div class="legend-item" data-type="rna"><span class="legend-swatch"></span><span id="legend-rna"></span></div>
        </div>
      </section>
      <section class="block" aria-labelledby="steps-title">
        <h2 id="steps-title"></h2>
        <div class="timeline" role="tablist" aria-label="" id="timeline"></div>
        <div class="step-panel" role="tabpanel" id="step-panel"></div>
        <div class="regulation-grid" aria-label="" id="regulation-grid"></div>
      </section>
      <section class="block data-model" aria-labelledby="model-title">
        <h2 id="model-title"><span id="model-title-main"></span> <span class="subheading" id="model-subheading"></span></h2>
        <div class="model-tabs" role="tablist" aria-label="" id="model-tabs">
          <button type="button" class="active" data-model="nodes" role="tab" aria-selected="true" id="tab-nodes"></button>
          <button type="button" data-model="edges" role="tab" aria-selected="false" id="tab-edges"></button>
          <button type="button" data-model="layout" role="tab" aria-selected="false" id="tab-layout"></button>
        </div>
        <div class="model-panel" role="tabpanel" id="model-panel"></div>
      </section>
    </main>
    <footer>
      <div id="footer-scales"></div>
      <div class="controls" aria-label="" id="export-controls">
        <button type="button" id="export-svg"></button>
        <button type="button" id="export-png"></button>
        <button type="button" id="export-pdf"></button>
        <button type="button" id="export-json"></button>
        <button type="button" id="import-json"></button>
        <button type="button" id="reset-layout"></button>
        <button type="button" id="open-reference"></button>
      </div>
    </footer>
    <input type="file" id="import-file" accept="application/json" class="visually-hidden" aria-hidden="true" tabindex="-1" />
    <div class="overlay" id="reference-overlay" role="dialog" aria-modal="true" aria-labelledby="overlay-title">
      <button class="close-overlay" type="button" id="close-overlay"></button>
      <h2 id="overlay-title"></h2>
      <table>
        <thead>
          <tr>
            <th id="overlay-col-module"></th>
            <th id="overlay-col-composition"></th>
            <th id="overlay-col-function"></th>
            <th id="overlay-col-control"></th>
          </tr>
        </thead>
        <tbody id="overlay-body"></tbody>
      </table>
    </div>
  </div>
  <script>
    (function() {
      const STRINGS = {
  "ru": {
    "htmlLang": "ru",
    "page": {
      "title": "Инициация транскрипции Pol II — схема процесса",
      "ariaLabel": "A4 схема инициации транскрипции Pol II",
      "header": {
        "title": "Инициация транскрипции Pol II на +1 TSS",
        "pill": "Eukaryote · Advanced · Process View",
        "meta": {
          "environment": "Окружение: ядро эукариот",
          "context": "Контекст: промотор класса II, TATA+/Inr",
          "focus": "Фокус: формирование и запуск PIC"
        }
      }
    },
    "map": {
      "title": "Схема сборки и переходов",
      "toolbarAria": "Управление картой",
      "buttons": {
        "fit": "Подогнать вид",
        "grid": "Сетка",
        "snap": "Привязка к сетке",
        "resetOverlap": "Упорядочить слои"
      },
      "canvasAria": "Рабочая зона",
      "axisLabel": "Геном (5′ → 3′)",
      "instructions": "Используйте мышь или стрелки для перемещения узлов. Колесо мыши с зажатой клавишей Ctrl управляет масштабом, простое прокручивание сдвигает поле. Перетаскивание удерживает элементы в пределах сетки и автоматически перерассчитывает связи.",
      "legendAria": "Условные обозначения",
      "legend": {
        "polii": "Полимераза II и общие факторы",
        "chromatin": "Хроматин и промоторная ДНК",
        "rna": "РНК, побег и пауза"
      }
    },
    "timeline": {
      "title": "Ключевые стадии и контрольные точки",
      "ariaLabel": "Этапы",
      "order": [
        "assembly",
        "isomerization",
        "initiation",
        "escape"
      ],
      "steps": {
        "assembly": {
          "buttonTitle": "1. Предсборка",
          "buttonDetail": "TFIID распознаёт TATA/Inr, активаторы стабилизируют Mediator.",
          "panelTitle": "1. Предсборка преинициаторного комплекса",
          "panelPoints": [
            "TBP изгибает ДНК на ~80°, позиционируя +1 сайт напротив активного центра.",
            "TFIID взаимодействует с коактиваторами (TAF1/2) и метками H3K4me3.",
            "TFIIA стабилизирует TBP–ДНК, TFIIB задаёт направление транскрипции.",
            "Mediator передаёт сигналы от энхансеров, подготавливая CDK8-модуль."
          ]
        },
        "isomerization": {
          "buttonTitle": "2. Изомеризация",
          "buttonDetail": "TFIIE рекрутирует TFIIH, открытие пузыря, загрузка шаблона.",
          "panelTitle": "2. Изомеризация и открытие промотора",
          "panelPoints": [
            "TFIIE координирует рекрутирование TFIIH и подготавливает хеликазный цикл XPB.",
            "ATP-зависимое расплетание формирует открытый пузырь (-9/+2) вокруг TSS.",
            "Шаблонная цепь позиционируется в канал Pol II при участии TFIIB-B reader.",
            "CTD Ser5-фосфориляция инициирует рекрутирование комплекса кэпирования."
          ]
        },
        "initiation": {
          "buttonTitle": "3. Старт синтеза",
          "buttonDetail": "Abortive циклы < 10 нт, CTD Ser5-P запускает кэпирование.",
          "panelTitle": "3. Старт синтеза и ранние транскрипты",
          "panelPoints": [
            "Pol II инициирует синтез с +1 аденина/цитозина, формируя короткие РНК.",
            "Abortive циклы (<10 нт) очищают канал; σ-подобная петля TFIIB ориентирует выход.",
            "NELF/DSIF начинают связываться, подготавливая платформу паузы.",
            "Ser5-P CTD рекрутирует TFIIH CAK и фактор кэпирования CE/HCE."
          ]
        },
        "escape": {
          "buttonTitle": "4. Побег",
          "buttonDetail": "TFIIB/TFIIE освобождаются, NELF/DSIF контролируют удлинение.",
          "panelTitle": "4. Промоторный побег и фиксация паузы",
          "panelPoints": [
            "Pol II проходит +10/+12, выбрасывая TFIIB/TFIIE и ослабляя связи Mediator.",
            "TFIIH остаётся до формирования устойчивого гибрида ДНК–РНК (~8–9 нт).",
            "DSIF стабилизирует удлинение, NELF удерживает полимеразу на +20/+60.",
            "P-TEFb (CDK9/CycT) фосфорилирует NELF/DSIF и CTD Ser2, переводя в элонгацию."
          ]
        }
      }
    },
    "regulation": {
      "ariaLabel": "Регуляция",
      "chips": [
        "Позитивная регуляция: ремоделлеры (SWI/SNF), H3K27ac усиливают доступность промотора.",
        "Негативная регуляция: комплексы NURD, метилирование ДНК ограничивают загрузку TFIID.",
        "Сигнальные входы: MAPK/CDK активируют фосфориляцию CTD через Mediator/CDK7.",
        "Контроль качества: TFIIS помогает Pol II преодолеть остановку на слабом стартовом сигнале."
      ]
    },
    "model": {
      "title": "Модель данных v1.1",
      "subheading": "JSON schema • визуальная грамматика A4",
      "ariaLabel": "Компоненты модели",
      "tabs": {
        "nodes": "Узлы",
        "edges": "Рёбра",
        "layout": "Вёрстка"
      },
      "content": {
        "nodes": {
          "title": "Структура узла {id, x, y, w, h, label, type, data}",
          "items": [
            "Поле <strong>type</strong> принимает роли: DNA, RNA, Protein, Promoter, Enhancer, TSS, TF, Mediator и др.",
            "Геометрия задаётся в миллиметрах A4: координаты (x, y) и размеры (w, h) относительно зоны сетки.",
            "Доп. данные (<code>data</code>) включают метки 5′→3′, модификации (H3K4me3) и состояние комплекса.",
            "Слои доступны через <code>layer</code> и <code>zIndex</code> — используют стандарт «process» для Pol II."
          ],
          "callout": "Рекомендация: хранить идентификаторы в формате <code>promoter:tata</code>, <code>protein:tf2h</code> для совместимости с экспортом.",
          "snippet": "{\n  \"id\": \"node:tfiih\",\n  \"type\": \"TFIIH\",\n  \"x\": 420,\n  \"y\": 120,\n  \"w\": 90,\n  \"h\": 46,\n  \"label\": \"TFIIH\",\n  \"layer\": \"factors\",\n  \"data\": {\"helicase\": \"XPB/XPD\", \"phosphorylation\": \"CTD Ser5\"}\n}"
        },
        "edges": {
          "title": "Определение ребра {id, from, to, kind, label, router, markers}",
          "items": [
            "Тип <strong>kind</strong>: flow (transcribes, recruits, phosphorylates) или regulation (activates, represses, pauses).",
            "Поле <code>router</code> описывает геометрию: orthogonal для PIC, bezier для энхансерных петель, straight для коротких связей.",
            "Маркеры стрелок (<code>markers</code>) задают форму/цвет; используем словарь arrow:polII, arrow:regulation, tee:repress.",
            "Атрибут <code>timeline</code> хранит контрольные точки (например, {start: \"+1\", end: \"+60\"}) для синхронизации с осью времени."
          ],
          "callout": "Связывайте рёбра с узлами по UUID — это облегчает слияние схем от разных авторов.",
          "snippet": "{\n  \"id\": \"edge:tf2h-open\",\n  \"from\": \"node:tfiih\",\n  \"to\": \"node:openbubble\",\n  \"kind\": \"flow\",\n  \"label\": \"открывает\",\n  \"router\": \"orthogonal\",\n  \"markers\": {\"start\": null, \"end\": \"arrow:polII\"}\n}"
        },
        "layout": {
          "title": "Правила вёрстки A4 landscape (print theme)",
          "items": [
            "Поле <code>page</code>: {width: 297, height: 210, margin: 12} — размеры в мм с учётом сетки 28 мм.",
            "Слои (<code>layers</code>): background, chromatin, factors, rna, annotations — управляют порядком рисования.",
            "Стили (<code>styles</code>) фиксируют цвета ролей: Pol II #1d4ed8, chromatin #4d7c0f, RNA #b91c1c.",
            "Гайды (<code>guides</code>) описывают линейки осей: time (left→right), assembly depth (top→bottom), regulation captions."
          ],
          "callout": "Экспорт в SVG/PNG использует эти параметры — держите масштаб 1 мм = 3.78 px для консистентности.",
          "snippet": "{\n  \"layout\": {\n    \"page\": {\"width\": 297, \"height\": 210, \"margin\": 12},\n    \"grid\": {\"size\": 28, \"visible\": true},\n    \"theme\": \"print\"\n  }\n}"
        }
      }
    },
    "footer": {
      "scales": "Шкалы: время (слева направо) · структура комплекса (по высоте) · регуляторы (подписи)",
      "controlsAria": "Экспорт",
      "buttons": {
        "exportSvg": "Экспорт SVG",
        "exportPng": "Экспорт PNG",
        "exportPdf": "PDF / Печать",
        "exportJson": "Экспорт JSON",
        "importJson": "Импорт JSON",
        "resetLayout": "Сброс",
        "openReference": "Таблица комплексов"
      }
    },
    "overlay": {
      "close": "Закрыть",
      "title": "Факторный состав и функции",
      "columns": {
        "module": "Модуль",
        "composition": "Состав",
        "function": "Функция в инициации",
        "control": "Контроль"
      },
      "rows": [
        {
          "module": "TFIID ядро",
          "composition": "TBP + TAF1/2/4/6",
          "function": "Распознаёт TATA/Inr, контактирует с DPE/MTE",
          "control": "Ацетил-H3/4, TAF фосфориляция"
        },
        {
          "module": "TFIIB мост",
          "composition": "Rrn7-подобные домены",
          "function": "Организация +1 канала, стабилизация ранних транскриптов",
          "control": "Фосфориляция Ser65 уменьшает удержание"
        },
        {
          "module": "TFIIE/F",
          "composition": "α/β субъединицы",
          "function": "Рекрутирование TFIIH, поддержка открытого пузыря",
          "control": "Убиквитинирование регулирует деградацию"
        },
        {
          "module": "TFIIH",
          "composition": "XPB, XPD, CAK (CDK7/CycH/MAT1)",
          "function": "Хеликазная активность, CTD Ser5-фосфорилирование",
          "control": "Сигналы стресс-ответа через ATR/ATM"
        },
        {
          "module": "Mediator",
          "composition": "Head/Middle/Tail + CDK8",
          "function": "Платформа для факторов, интеграция сигналов энхансеров",
          "control": "CDK8/CycC переключают режим паузы"
        },
        {
          "module": "Pausing-модуль",
          "composition": "DSIF (Spt4/5), NELF A–E",
          "function": "Стабилизация Pol II на +20–+60, подготовка к паузе",
          "control": "P-TEFb фосфорилирует для освобождения"
        }
      ]
    },
    "nodes": {
      "chromatin": {
        "label": "Хроматин ремоделирован",
        "type": "Chromatin",
        "notes": [
          "SWI/SNF и HAT открывают TATA-бокс и снимают нуклеосомы.",
          "H3K4me3 / ацетил-H3 повышают аффинность TFIID."
        ]
      },
      "mediator": {
        "label": "Mediator + общие факторы",
        "type": "Mediator complex",
        "notes": [
          "TFIID-TBP, TFIIA и TFIIB фиксируют +1 позицию.",
          "Tail/Head модули интегрируют сигналы энхансеров."
        ]
      },
      "polii": {
        "label": "Pol II–TFIIF ядро",
        "type": "Pol II core",
        "notes": [
          "TFIIE координирует загрузку TFIIH; XPB раскрывает пузырь (-9/+2).",
          "CDK7 (CAK) фосфорилирует CTD Ser5, рекрутирует кэпирующий комплекс."
        ]
      },
      "escape": {
        "label": "Промоторный побег и пауза",
        "type": "RNA transition",
        "notes": [
          "Гибрид ДНК–РНК стабилизируется (~8–9 нт), Mediator отходит.",
          "DSIF/NELF удерживают Pol II на +20/+60 до активации P-TEFb."
        ]
      },
      "enhancer": {
        "label": "Энхансерные петли",
        "type": "Enhancer",
        "notes": [
          "Активаторы и Mediator Tail формируют петлю, вовлекая Cohesin.",
          "Chromatin reader-комплексы удерживают гистоновые метки."
        ]
      },
      "ptefb": {
        "label": "P-TEFb / сигналы освобождения",
        "type": "Regulation",
        "notes": [
          "CDK9/CycT активируются через BRD4/SEC и сигналы стресс-ответа.",
          "Фосфорилируют DSIF, NELF и CTD Ser2, переводя в продуктивную элонгацию."
        ]
      }
    },
    "edges": {
      "chromatinMediator": "рекрутирует",
      "mediatorPolii": "собирает PIC",
      "poliiEscape": "инициирует транскрипцию",
      "enhancerMediator": "активирует",
      "ptefbEscape": "освобождает паузу"
    },
    "messages": {
      "importError": "Не удалось импортировать JSON: ",
      "missingNodes": "Структура JSON не содержит массива \"nodes\"",
      "stateReset": "Сброс сохранённого состояния из-за ошибки",
      "saveError": "Не удалось сохранить состояние",
      "dragHandle": "Переместить",
      "nodeAria": "{label}. {type}. Перемещение стрелками, Shift — шаг x2."
    }
  },
  "en": {
    "htmlLang": "en",
    "page": {
      "title": "Pol II transcription initiation — process map",
      "ariaLabel": "A4 Pol II transcription initiation diagram",
      "header": {
        "title": "Pol II transcription initiation at the +1 TSS",
        "pill": "Eukaryote · Advanced · Process View",
        "meta": {
          "environment": "Environment: eukaryotic nucleus",
          "context": "Context: class II promoter, TATA+/Inr",
          "focus": "Focus: assembling and firing the PIC"
        }
      }
    },
    "map": {
      "title": "Assembly and transition map",
      "toolbarAria": "Map controls",
      "buttons": {
        "fit": "Fit to view",
        "grid": "Grid",
        "snap": "Snap to grid",
        "resetOverlap": "Arrange layers"
      },
      "canvasAria": "Workspace",
      "axisLabel": "Genome (5′ → 3′)",
      "instructions": "Use the mouse or arrow keys to move nodes. Scroll with Ctrl adjusts zoom; plain scrolling pans the field. Dragging keeps elements snapped to the grid and recomputes connections.",
      "legendAria": "Legend",
      "legend": {
        "polii": "Pol II and general factors",
        "chromatin": "Chromatin and promoter DNA",
        "rna": "RNA, escape and pause"
      }
    },
    "timeline": {
      "title": "Key stages and checkpoints",
      "ariaLabel": "Stages",
      "order": [
        "assembly",
        "isomerization",
        "initiation",
        "escape"
      ],
      "steps": {
        "assembly": {
          "buttonTitle": "1. Pre-assembly",
          "buttonDetail": "TFIID recognizes TATA/Inr, activators stabilize Mediator.",
          "panelTitle": "1. Pre-assembly of the pre-initiation complex",
          "panelPoints": [
            "TBP bends DNA by ~80°, positioning the +1 site at the active center.",
            "TFIID engages co-activators (TAF1/2) and H3K4me3 marks.",
            "TFIIA stabilizes TBP–DNA, TFIIB sets transcription direction.",
            "Mediator relays enhancer cues and primes the CDK8 module."
          ]
        },
        "isomerization": {
          "buttonTitle": "2. Isomerization",
          "buttonDetail": "TFIIE recruits TFIIH, bubble opening, template loading.",
          "panelTitle": "2. Promoter isomerization and opening",
          "panelPoints": [
            "TFIIE coordinates TFIIH recruitment and primes the XPB helicase cycle.",
            "ATP-driven unwinding creates an open bubble (-9/+2) around the TSS.",
            "The template strand is guided into Pol II by the TFIIB B-reader.",
            "CTD Ser5 phosphorylation triggers capping complex recruitment."
          ]
        },
        "initiation": {
          "buttonTitle": "3. Initiation",
          "buttonDetail": "Abortive cycles < 10 nt, CTD Ser5-P triggers capping.",
          "panelTitle": "3. Initiation and short transcripts",
          "panelPoints": [
            "Pol II initiates at +1 A/C, producing short RNAs.",
            "Abortive cycles (<10 nt) clear the channel; the TFIIB B-finger directs RNA exit.",
            "NELF/DSIF begin to engage, preparing the pause platform.",
            "Ser5-phosphorylated CTD recruits TFIIH CAK and the capping enzyme."
          ]
        },
        "escape": {
          "buttonTitle": "4. Promoter escape",
          "buttonDetail": "TFIIB/TFIIE release, NELF/DSIF tune elongation.",
          "panelTitle": "4. Promoter escape and pause establishment",
          "panelPoints": [
            "Pol II passes +10/+12, releasing TFIIB/TFIIE and loosening Mediator contacts.",
            "TFIIH remains until a stable DNA–RNA hybrid (~8–9 nt) forms.",
            "DSIF stabilizes elongation; NELF holds Pol II at +20/+60.",
            "P-TEFb (CDK9/CycT) phosphorylates NELF/DSIF and CTD Ser2 to enter productive elongation."
          ]
        }
      }
    },
    "regulation": {
      "ariaLabel": "Regulation",
      "chips": [
        "Positive control: remodelers (SWI/SNF) and H3K27ac increase promoter accessibility.",
        "Negative control: NuRD complexes and DNA methylation limit TFIID loading.",
        "Signaling inputs: MAPK/CDK routes activate CTD phosphorylation via Mediator/CDK7.",
        "Quality control: TFIIS helps Pol II bypass weak-start stalls."
      ]
    },
    "model": {
      "title": "Data model v1.1",
      "subheading": "JSON schema • A4 visual grammar",
      "ariaLabel": "Model components",
      "tabs": {
        "nodes": "Nodes",
        "edges": "Edges",
        "layout": "Layout"
      },
      "content": {
        "nodes": {
          "title": "Node structure {id, x, y, w, h, label, type, data}",
          "items": [
            "Field <strong>type</strong> covers roles: DNA, RNA, Protein, Promoter, Enhancer, TSS, TF, Mediator, etc.",
            "Geometry is in A4 millimetres: coordinates (x, y) and size (w, h) within the grid area.",
            "Extra <code>data</code> stores 5′→3′ marks, modifications (H3K4me3) and complex states.",
            "<code>layer</code> and <code>zIndex</code> follow the Pol II “process” standard."
          ],
          "callout": "Recommendation: keep identifiers like <code>promoter:tata</code>, <code>protein:tf2h</code> for export compatibility.",
          "snippet": "{\n  \"id\": \"node:tfiih\",\n  \"type\": \"TFIIH\",\n  \"x\": 420,\n  \"y\": 120,\n  \"w\": 90,\n  \"h\": 46,\n  \"label\": \"TFIIH\",\n  \"layer\": \"factors\",\n  \"data\": {\"helicase\": \"XPB/XPD\", \"phosphorylation\": \"CTD Ser5\"}\n}"
        },
        "edges": {
          "title": "Edge definition {id, from, to, kind, label, router, markers}",
          "items": [
            "<strong>kind</strong>: flow (transcribes, recruits, phosphorylates) or regulation (activates, represses, pauses).",
            "<code>router</code> shapes geometry: orthogonal for the PIC, bezier for enhancer loops, straight for short links.",
            "Arrow markers (<code>markers</code>) pick shape/colour; use the catalog arrow:polII, arrow:regulation, tee:repress.",
            "<code>timeline</code> marks checkpoints (e.g. {start: \"+1\", end: \"+60\"}) to align with the time axis."
          ],
          "callout": "Bind edges to nodes via UUIDs — it simplifies merging diagrams from different authors.",
          "snippet": "{\n  \"id\": \"edge:tf2h-open\",\n  \"from\": \"node:tfiih\",\n  \"to\": \"node:openbubble\",\n  \"kind\": \"flow\",\n  \"label\": \"opens\",\n  \"router\": \"orthogonal\",\n  \"markers\": {\"start\": null, \"end\": \"arrow:polII\"}\n}"
        },
        "layout": {
          "title": "A4 landscape layout rules (print theme)",
          "items": [
            "<code>page</code>: {width: 297, height: 210, margin: 12} — millimetres with a 28 mm grid.",
            "Layers (<code>layers</code>): background, chromatin, factors, rna, annotations — control draw order.",
            "Styles (<code>styles</code>) fix role colours: Pol II #1d4ed8, chromatin #4d7c0f, RNA #b91c1c.",
            "Guides (<code>guides</code>) define axes: time (left→right), assembly depth (top→bottom), regulation captions."
          ],
          "callout": "SVG/PNG export relies on these parameters — keep 1 mm = 3.78 px for consistency.",
          "snippet": "{\n  \"layout\": {\n    \"page\": {\"width\": 297, \"height\": 210, \"margin\": 12},\n    \"grid\": {\"size\": 28, \"visible\": true},\n    \"theme\": \"print\"\n  }\n}"
        }
      }
    },
    "footer": {
      "scales": "Scales: time (left to right) · complex structure (vertical) · regulators (captions)",
      "controlsAria": "Export",
      "buttons": {
        "exportSvg": "Export SVG",
        "exportPng": "Export PNG",
        "exportPdf": "PDF / Print",
        "exportJson": "Export JSON",
        "importJson": "Import JSON",
        "resetLayout": "Reset",
        "openReference": "Complex table"
      }
    },
    "overlay": {
      "close": "Close",
      "title": "Factor composition and functions",
      "columns": {
        "module": "Module",
        "composition": "Composition",
        "function": "Role in initiation",
        "control": "Control"
      },
      "rows": [
        {
          "module": "TFIID core",
          "composition": "TBP + TAF1/2/4/6",
          "function": "Recognizes TATA/Inr, contacts DPE/MTE",
          "control": "H3/H4 acetylation, TAF phosphorylation"
        },
        {
          "module": "TFIIB bridge",
          "composition": "Rrn7-like domains",
          "function": "Organizes the +1 channel, stabilizes early transcripts",
          "control": "Ser65 phosphorylation lowers retention"
        },
        {
          "module": "TFIIE/F",
          "composition": "α/β subunits",
          "function": "Recruit TFIIH, support the open bubble",
          "control": "Ubiquitination regulates turnover"
        },
        {
          "module": "TFIIH",
          "composition": "XPB, XPD, CAK (CDK7/CycH/MAT1)",
          "function": "Helicase activity, CTD Ser5 phosphorylation",
          "control": "Stress-response signals via ATR/ATM"
        },
        {
          "module": "Mediator",
          "composition": "Head/Middle/Tail + CDK8",
          "function": "Factor platform integrating enhancer signals",
          "control": "CDK8/CycC toggles the pause module"
        },
        {
          "module": "Pausing module",
          "composition": "DSIF (Spt4/5), NELF A–E",
          "function": "Stabilizes Pol II at +20–+60, sets up pausing",
          "control": "P-TEFb phosphorylation triggers release"
        }
      ]
    },
    "nodes": {
      "chromatin": {
        "label": "Chromatin remodeled",
        "type": "Chromatin",
        "notes": [
          "SWI/SNF and HATs expose the TATA box and clear nucleosomes.",
          "H3K4me3 / H3 acetylation increases TFIID affinity."
        ]
      },
      "mediator": {
        "label": "Mediator + general factors",
        "type": "Mediator complex",
        "notes": [
          "TFIID-TBP, TFIIA and TFIIB lock the +1 position.",
          "Tail/Head modules integrate enhancer signals."
        ]
      },
      "polii": {
        "label": "Pol II–TFIIF core",
        "type": "Pol II core",
        "notes": [
          "TFIIE coordinates TFIIH loading; XPB opens the bubble (-9/+2).",
          "CDK7 (CAK) phosphorylates CTD Ser5 and recruits the capping machinery."
        ]
      },
      "escape": {
        "label": "Promoter escape and pause",
        "type": "RNA transition",
        "notes": [
          "The DNA–RNA hybrid stabilizes (~8–9 nt) while Mediator disengages.",
          "DSIF/NELF hold Pol II at +20/+60 until P-TEFb activation."
        ]
      },
      "enhancer": {
        "label": "Enhancer loops",
        "type": "Enhancer",
        "notes": [
          "Activators and the Mediator Tail loop DNA, engaging Cohesin.",
          "Chromatin reader complexes maintain histone marks."
        ]
      },
      "ptefb": {
        "label": "P-TEFb / release signals",
        "type": "Regulation",
        "notes": [
          "CDK9/CycT activated via BRD4/SEC and stress pathways.",
          "Phosphorylate DSIF, NELF and CTD Ser2 to trigger productive elongation."
        ]
      }
    },
    "edges": {
      "chromatinMediator": "recruits",
      "mediatorPolii": "assembles the PIC",
      "poliiEscape": "initiates transcription",
      "enhancerMediator": "activates",
      "ptefbEscape": "releases the pause"
    },
    "messages": {
      "importError": "Failed to import JSON: ",
      "missingNodes": "JSON structure is missing a \"nodes\" array",
      "stateReset": "Stored state was reset after an error",
      "saveError": "Failed to save state",
      "dragHandle": "Drag",
      "nodeAria": "{label}. {type}. Move with arrow keys, Shift doubles the step."
    }
  },
  "de": {
    "htmlLang": "de",
    "page": {
      "title": "Pol-II-Transkriptionsinitiation – Prozessübersicht",
      "ariaLabel": "A4-Diagramm der Pol-II-Transkriptionsinitiation",
      "header": {
        "title": "Pol-II-Transkriptionsinitiation am +1-Start",
        "pill": "Eukaryot · Fortgeschritten · Prozessansicht",
        "meta": {
          "environment": "Umgebung: eukaryotischer Zellkern",
          "context": "Kontext: Klasse-II-Promotor, TATA+/Inr",
          "focus": "Fokus: Aufbau und Auslösung des PIC"
        }
      }
    },
    "map": {
      "title": "Karte der Assemblierung und Übergänge",
      "toolbarAria": "Kartensteuerung",
      "buttons": {
        "fit": "Ansicht anpassen",
        "grid": "Raster",
        "snap": "Am Raster ausrichten",
        "resetOverlap": "Ebenen ordnen"
      },
      "canvasAria": "Arbeitsbereich",
      "axisLabel": "Genom (5′ → 3′)",
      "instructions": "Verwenden Sie Maus oder Pfeiltasten, um Knoten zu verschieben. Strg+Scrollen zoomt, normales Scrollen verschiebt die Ansicht. Ziehen hält Elemente im Raster und berechnet Verbindungen neu.",
      "legendAria": "Legende",
      "legend": {
        "polii": "Pol II und allgemeine Faktoren",
        "chromatin": "Chromatin und Promotor-DNA",
        "rna": "RNA, Escape und Pause"
      }
    },
    "timeline": {
      "title": "Schlüsselphasen und Kontrollpunkte",
      "ariaLabel": "Phasen",
      "order": [
        "assembly",
        "isomerization",
        "initiation",
        "escape"
      ],
      "steps": {
        "assembly": {
          "buttonTitle": "1. Präassemblierung",
          "buttonDetail": "TFIID erkennt TATA/Inr, Aktivatoren stabilisieren Mediator.",
          "panelTitle": "1. Präassemblierung des Präinitiationskomplexes",
          "panelPoints": [
            "TBP biegt die DNA um ~80° und positioniert +1 im aktiven Zentrum.",
            "TFIID bindet Koaktivatoren (TAF1/2) und H3K4me3-Marken.",
            "TFIIA stabilisiert TBP–DNA, TFIIB legt die Transkriptionsrichtung fest.",
            "Mediator überträgt Enhancer-Signale und bereitet das CDK8-Modul vor."
          ]
        },
        "isomerization": {
          "buttonTitle": "2. Isomerisierung",
          "buttonDetail": "TFIIE rekrutiert TFIIH, öffnet die Blase, lädt die Matrize.",
          "panelTitle": "2. Promotorisomerisierung und -öffnung",
          "panelPoints": [
            "TFIIE koordiniert das TFIIH-Recruitment und zündet den XPB-Helikasezyklus.",
            "ATP-abhängiges Aufschmelzen erzeugt eine offene Blase (-9/+2) um den TSS.",
            "Der Matrizenstrang wird durch den TFIIB-B-reader in Pol II geführt.",
            "CTD-Ser5-Phosphorylierung rekrutiert den Capping-Komplex."
          ]
        },
        "initiation": {
          "buttonTitle": "3. Initiation",
          "buttonDetail": "Abortive Zyklen < 10 nt, CTD Ser5-P startet Capping.",
          "panelTitle": "3. Initiation und kurze Transkripte",
          "panelPoints": [
            "Pol II startet bei +1 (A/C) und bildet kurze RNAs.",
            "Abortive Zyklen (<10 nt) räumen den Kanal; die TFIIB-Schleife lenkt den Austritt.",
            "NELF/DSIF binden an und bereiten die Pausenplattform vor.",
            "Ser5-phosphoryliertes CTD rekrutiert TFIIH-CAK und die Capping-Enzyme."
          ]
        },
        "escape": {
          "buttonTitle": "4. Promotor-Escape",
          "buttonDetail": "TFIIB/TFIIE lösen sich, NELF/DSIF steuern die Elongation.",
          "panelTitle": "4. Promotor-Escape und Etablierung der Pause",
          "panelPoints": [
            "Pol II passiert +10/+12, löst TFIIB/TFIIE und schwächt Mediator-Kontakte.",
            "TFIIH bleibt, bis ein stabiler DNA–RNA-Hybrid (~8–9 nt) entsteht.",
            "DSIF stabilisiert die Elongation, NELF hält Pol II bei +20/+60.",
            "P-TEFb (CDK9/CycT) phosphoryliert NELF/DSIF und CTD Ser2 für produktive Elongation."
          ]
        }
      }
    },
    "regulation": {
      "ariaLabel": "Regulation",
      "chips": [
        "Positive Regulation: Remodeler (SWI/SNF) und H3K27ac erhöhen die Promotorzugänglichkeit.",
        "Negative Regulation: NuRD-Komplexe und DNA-Methylierung begrenzen die TFIID-Beladung.",
        "Signalschnittstellen: MAPK/CDK-Wege aktivieren die CTD-Phosphorylierung über Mediator/CDK7.",
        "Qualitätskontrolle: TFIIS hilft Pol II, Stalls an schwachen Starts zu überwinden."
      ]
    },
    "model": {
      "title": "Datenmodell v1.1",
      "subheading": "JSON-Schema • A4-Visualgrammatik",
      "ariaLabel": "Modellelemente",
      "tabs": {
        "nodes": "Knoten",
        "edges": "Kanten",
        "layout": "Layout"
      },
      "content": {
        "nodes": {
          "title": "Knotenstruktur {id, x, y, w, h, label, type, data}",
          "items": [
            "Feld <strong>type</strong> umfasst Rollen wie DNA, RNA, Protein, Promoter, Enhancer, TSS, TF, Mediator usw.",
            "Geometrie in A4-Millimetern: Koordinaten (x, y) und Größen (w, h) relativ zum Rasterbereich.",
            "Zusätzliche <code>data</code> enthalten 5′→3′-Marken, Modifikationen (H3K4me3) und Komplexzustände.",
            "<code>layer</code> und <code>zIndex</code> folgen dem Pol-II-Standard „process“."
          ],
          "callout": "Empfehlung: IDs wie <code>promoter:tata</code>, <code>protein:tf2h</code> für Exportkompatibilität verwenden.",
          "snippet": "{\n  \"id\": \"node:tfiih\",\n  \"type\": \"TFIIH\",\n  \"x\": 420,\n  \"y\": 120,\n  \"w\": 90,\n  \"h\": 46,\n  \"label\": \"TFIIH\",\n  \"layer\": \"factors\",\n  \"data\": {\"helicase\": \"XPB/XPD\", \"phosphorylation\": \"CTD Ser5\"}\n}"
        },
        "edges": {
          "title": "Kantendefinition {id, from, to, kind, label, router, markers}",
          "items": [
            "<strong>kind</strong>: flow (transkribiert, rekrutiert, phosphoryliert) oder regulation (aktiviert, reprimiert, pausiert).",
            "<code>router</code> beschreibt die Geometrie: orthogonal für PIC, Bezier für Enhancer-Schleifen, straight für kurze Verbindungen.",
            "Pfeilmarker (<code>markers</code>) bestimmen Form/Farbe; nutzen Sie arrow:polII, arrow:regulation, tee:repress.",
            "<code>timeline</code> speichert Kontrollpunkte (z. B. {start: \"+1\", end: \"+60\"}) zur Synchronisation mit der Zeitachse."
          ],
          "callout": "Kanten per UUID mit Knoten verknüpfen – erleichtert das Zusammenführen verschiedener Diagramme.",
          "snippet": "{\n  \"id\": \"edge:tf2h-open\",\n  \"from\": \"node:tfiih\",\n  \"to\": \"node:openbubble\",\n  \"kind\": \"flow\",\n  \"label\": \"öffnet\",\n  \"router\": \"orthogonal\",\n  \"markers\": {\"start\": null, \"end\": \"arrow:polII\"}\n}"
        },
        "layout": {
          "title": "Layout-Regeln A4 landscape (Print-Thema)",
          "items": [
            "<code>page</code>: {width: 297, height: 210, margin: 12} — Maße in mm mit 28-mm-Raster.",
            "Ebenen (<code>layers</code>): background, chromatin, factors, rna, annotations – steuern die Zeichenreihenfolge.",
            "Stile (<code>styles</code>) fixieren Rollenfarben: Pol II #1d4ed8, Chromatin #4d7c0f, RNA #b91c1c.",
            "Guides (<code>guides</code>) definieren Achsen: time (links→rechts), assembly depth (oben→unten), regulation captions."
          ],
          "callout": "SVG/PNG-Export nutzt diese Parameter – Maßstab 1 mm = 3,78 px beibehalten.",
          "snippet": "{\n  \"layout\": {\n    \"page\": {\"width\": 297, \"height\": 210, \"margin\": 12},\n    \"grid\": {\"size\": 28, \"visible\": true},\n    \"theme\": \"print\"\n  }\n}"
        }
      }
    },
    "footer": {
      "scales": "Skalen: Zeit (links nach rechts) · Komplexstruktur (vertikal) · Regulatoren (Beschriftungen)",
      "controlsAria": "Export",
      "buttons": {
        "exportSvg": "SVG exportieren",
        "exportPng": "PNG exportieren",
        "exportPdf": "PDF / Drucken",
        "exportJson": "JSON exportieren",
        "importJson": "JSON importieren",
        "resetLayout": "Zurücksetzen",
        "openReference": "Faktortabelle"
      }
    },
    "overlay": {
      "close": "Schließen",
      "title": "Faktorzusammensetzung und Funktionen",
      "columns": {
        "module": "Modul",
        "composition": "Zusammensetzung",
        "function": "Funktion in der Initiation",
        "control": "Regulation"
      },
      "rows": [
        {
          "module": "TFIID-Kern",
          "composition": "TBP + TAF1/2/4/6",
          "function": "Erkennt TATA/Inr, kontaktiert DPE/MTE",
          "control": "H3/H4-Acetylierung, TAF-Phosphorylierung"
        },
        {
          "module": "TFIIB-Brücke",
          "composition": "Rrn7-ähnliche Domänen",
          "function": "Organisiert den +1-Kanal, stabilisiert frühe Transkripte",
          "control": "Ser65-Phosphorylierung verringert Verweildauer"
        },
        {
          "module": "TFIIE/F",
          "composition": "α/β-Untereinheiten",
          "function": "Rekrutiert TFIIH, stabilisiert die offene Blase",
          "control": "Ubiquitinierung steuert Abbau"
        },
        {
          "module": "TFIIH",
          "composition": "XPB, XPD, CAK (CDK7/CycH/MAT1)",
          "function": "Helikaseaktivität, CTD-Ser5-Phosphorylierung",
          "control": "Stressantwort-Signale über ATR/ATM"
        },
        {
          "module": "Mediator",
          "composition": "Head/Middle/Tail + CDK8",
          "function": "Plattform für Faktoren, integriert Enhancer-Signale",
          "control": "CDK8/CycC schaltet den Pausenmodus um"
        },
        {
          "module": "Pause-Modul",
          "composition": "DSIF (Spt4/5), NELF A–E",
          "function": "Stabilisiert Pol II bei +20/+60, bereitet Pause vor",
          "control": "P-TEFb-Phosphorylierung löst die Pause"
        }
      ]
    },
    "nodes": {
      "chromatin": {
        "label": "Chromatin umgebaut",
        "type": "Chromatin",
        "notes": [
          "SWI/SNF und HATs legen den TATA-Bereich frei und entfernen Nukleosomen.",
          "H3K4me3 / H3-Acetylierung erhöht die TFIID-Affinität."
        ]
      },
      "mediator": {
        "label": "Mediator + allgemeine Faktoren",
        "type": "Mediator-Komplex",
        "notes": [
          "TFIID-TBP, TFIIA und TFIIB fixieren die +1-Position.",
          "Tail/Head-Module integrieren Enhancer-Signale."
        ]
      },
      "polii": {
        "label": "Pol II–TFIIF-Kern",
        "type": "Pol-II-Kern",
        "notes": [
          "TFIIE koordiniert TFIIH; XPB öffnet die Blase (-9/+2).",
          "CDK7 (CAK) phosphoryliert CTD Ser5 und rekrutiert den Capping-Komplex."
        ]
      },
      "escape": {
        "label": "Promotor-Escape und Pause",
        "type": "RNA-Übergang",
        "notes": [
          "Der DNA–RNA-Hybrid stabilisiert sich (~8–9 nt), Mediator löst sich.",
          "DSIF/NELF halten Pol II bei +20/+60 bis zur P-TEFb-Aktivierung."
        ]
      },
      "enhancer": {
        "label": "Enhancer-Schleifen",
        "type": "Enhancer",
        "notes": [
          "Aktivatoren und Mediator-Tail bilden Schleifen und rekrutieren Cohesin.",
          "Chromatin-Reader-Komplexe erhalten Histonmarken."
        ]
      },
      "ptefb": {
        "label": "P-TEFb / Freigabesignale",
        "type": "Regulation",
        "notes": [
          "CDK9/CycT werden über BRD4/SEC und Stresssignale aktiviert.",
          "Phosphorylieren DSIF, NELF und CTD Ser2 für produktive Elongation."
        ]
      }
    },
    "edges": {
      "chromatinMediator": "rekrutiert",
      "mediatorPolii": "baut den PIC auf",
      "poliiEscape": "initiiert die Transkription",
      "enhancerMediator": "aktiviert",
      "ptefbEscape": "löst die Pause"
    },
    "messages": {
      "importError": "JSON konnte nicht importiert werden: ",
      "missingNodes": "JSON-Struktur enthält kein \"nodes\"-Array",
      "stateReset": "Gespeicherter Zustand wurde nach einem Fehler zurückgesetzt",
      "saveError": "Zustand konnte nicht gespeichert werden",
      "dragHandle": "Ziehen",
      "nodeAria": "{label}. {type}. Mit Pfeiltasten bewegen, Umschalt verdoppelt die Schritte."
    }
  }
};

      const TIMELINE_ORDER = ['assembly', 'isomerization', 'initiation', 'escape'];
      const MODEL_TAB_ORDER = ['nodes', 'edges', 'layout'];
      const DEFAULT_LANG = 'ru';

      function normalizeLang(value) {
        if (!value) return null;
        return value.toLowerCase().split('-')[0];
      }

      function resolveLanguage() {
        const params = new URLSearchParams(window.location.search);
        const fromParam = normalizeLang(params.get('ui_lang') || params.get('ui-lang') || params.get('lang') || params.get('locale'));
        const meta = normalizeLang(document.querySelector('meta[name="ui-lang"]')?.content);
        const dataAttr = normalizeLang(document.documentElement.getAttribute('data-ui-lang'));
        const attr = normalizeLang(document.documentElement.getAttribute('lang'));
        if (fromParam && STRINGS[fromParam]) return fromParam;
        if (meta && STRINGS[meta]) return meta;
        if (dataAttr && STRINGS[dataAttr]) return dataAttr;
        if (attr && STRINGS[attr]) return attr;
        return DEFAULT_LANG;
      }

      const UI_LANG = resolveLanguage();
      const ACTIVE_LANG = STRINGS[UI_LANG] ? UI_LANG : DEFAULT_LANG;
      const ACTIVE_STRINGS = STRINGS[ACTIVE_LANG];
      const FALLBACK_STRINGS = STRINGS[DEFAULT_LANG];

      document.documentElement.setAttribute('data-ui-lang', ACTIVE_LANG);
      document.documentElement.setAttribute('lang', ACTIVE_STRINGS.htmlLang || ACTIVE_LANG);
      const metaLang = document.querySelector('meta[name="ui-lang"]');
      if (metaLang) {
        metaLang.setAttribute('content', ACTIVE_LANG);
      }

      function getLocaleEntry(path) {
        const segments = path.split('.');
        let current = ACTIVE_STRINGS;
        let fallback = FALLBACK_STRINGS;
        for (const segment of segments) {
          current = current && Object.prototype.hasOwnProperty.call(current, segment) ? current[segment] : undefined;
          fallback = fallback && Object.prototype.hasOwnProperty.call(fallback, segment) ? fallback[segment] : undefined;
        }
        return current !== undefined ? current : fallback;
      }

      function getLocaleString(path) {
        const value = getLocaleEntry(path);
        return typeof value === 'string' ? value : '';
      }

      function getLocaleArray(path) {
        const value = getLocaleEntry(path);
        return Array.isArray(value) ? value.slice() : [];
      }

      const GRID_SIZE = 24;
      const MAP_WIDTH = 960;
      const MAP_HEIGHT = 520;
      const STORAGE_KEY = 'polii-map-layout-v1';
      const LAYER_ORDER = { chromatin: 10, factors: 20, rna: 30, annotations: 40 };
      const LAYER_STYLE = {
        chromatin: { fill: '#dcfce7', stroke: '#4d7c0f' },
        factors: { fill: '#ede9fe', stroke: '#4338ca' },
        rna: { fill: '#fee2e2', stroke: '#b91c1c' },
        annotations: { fill: '#e2e8f0', stroke: '#475569' }
      };

      const NODE_TEMPLATES = [
  {
    "id": "node:chromatin",
    "key": "chromatin",
    "layer": "chromatin",
    "x": 48,
    "y": 216,
    "width": 216,
    "height": 132
  },
  {
    "id": "node:mediator",
    "key": "mediator",
    "layer": "factors",
    "x": 288,
    "y": 192,
    "width": 216,
    "height": 144
  },
  {
    "id": "node:polii",
    "key": "polii",
    "layer": "factors",
    "x": 528,
    "y": 192,
    "width": 216,
    "height": 156
  },
  {
    "id": "node:escape",
    "key": "escape",
    "layer": "rna",
    "x": 768,
    "y": 252,
    "width": 192,
    "height": 144
  },
  {
    "id": "node:enhancer",
    "key": "enhancer",
    "layer": "annotations",
    "x": 288,
    "y": 48,
    "width": 216,
    "height": 120
  },
  {
    "id": "node:ptefb",
    "key": "ptefb",
    "layer": "annotations",
    "x": 768,
    "y": 48,
    "width": 192,
    "height": 120
  }
];
      const EDGE_TEMPLATES = [
  {
    "id": "edge:chromatin-mediator",
    "key": "chromatinMediator",
    "from": "node:chromatin",
    "to": "node:mediator",
    "kind": "flow",
    "router": "orthogonal"
  },
  {
    "id": "edge:mediator-polii",
    "key": "mediatorPolii",
    "from": "node:mediator",
    "to": "node:polii",
    "kind": "flow",
    "router": "orthogonal"
  },
  {
    "id": "edge:polii-escape",
    "key": "poliiEscape",
    "from": "node:polii",
    "to": "node:escape",
    "kind": "flow",
    "router": "orthogonal"
  },
  {
    "id": "edge:enhancer-mediator",
    "key": "enhancerMediator",
    "from": "node:enhancer",
    "to": "node:mediator",
    "kind": "regulation",
    "router": "orthogonal",
    "markers": {
      "end": "arrow-regulation"
    }
  },
  {
    "id": "edge:ptefb-escape",
    "key": "ptefbEscape",
    "from": "node:ptefb",
    "to": "node:escape",
    "kind": "regulation",
    "router": "orthogonal",
    "markers": {
      "end": "arrow-regulation"
    }
  }
];

      const BASE_NODES = NODE_TEMPLATES.map(createLocalizedNode);
      const BASE_EDGES = EDGE_TEMPLATES.map(createLocalizedEdge);

      function createLocalizedNode(template) {
        const nodeStrings = getLocaleEntry(`nodes.${template.key}`) || {};
        const notes = Array.isArray(nodeStrings.notes) ? nodeStrings.notes.map(note => String(note)) : [];
        return {
          id: template.id,
          label: typeof nodeStrings.label === 'string' ? nodeStrings.label : '',
          type: typeof nodeStrings.type === 'string' ? nodeStrings.type : '',
          layer: template.layer,
          x: template.x,
          y: template.y,
          width: template.width,
          height: template.height,
          notes,
          z: template.z
        };
      }

      function createLocalizedEdge(template) {
        const markers = template.markers ? { ...template.markers } : undefined;
        return {
          id: template.id,
          from: template.from,
          to: template.to,
          kind: template.kind || 'flow',
          router: template.router || 'orthogonal',
          label: getLocaleString(`edges.${template.key}`),
          markers
        };
      }

      const state = {
        nodes: new Map(BASE_NODES.map(node => [node.id, cloneNode(node)])),
        edges: BASE_EDGES.map(edge => ({ ...edge }))
      };

      let scale = 1;
      let pan = { x: 0, y: 0 };
      let gridSnapEnabled = true;
      let gridVisible = true;
      let isPanning = false;
      let panPointerId = null;

      const mapCanvas = document.getElementById('map-canvas');
      const mapViewport = document.getElementById('map-viewport');
      const nodeLayer = document.getElementById('node-layer');
      const edgeLayer = document.getElementById('edge-layer');
      const toggleGridButton = document.getElementById('toggle-grid');
      const snapCheckbox = document.getElementById('snap-to-grid');
      const fitToViewButton = document.getElementById('fit-to-view');
      const resetOverlapButton = document.getElementById('reset-overlap');
      const resetLayoutButton = document.getElementById('reset-layout');
      const exportJsonButton = document.getElementById('export-json');
      const importJsonButton = document.getElementById('import-json');
      const importFileInput = document.getElementById('import-file');
      const exportSvgButton = document.getElementById('export-svg');
      const exportPngButton = document.getElementById('export-png');
      const exportPdfButton = document.getElementById('export-pdf');

      applyStaticText();
      init();
      setupTimeline();
      setupOverlay();
      setupModelTabs();

      function init() {
        restoreState();
        renderNodes();
        applyTransform();
        updateEdges();
        wireControls();
      }

      function wireControls() {
        toggleGridButton.addEventListener('click', () => {
          gridVisible = !gridVisible;
          mapCanvas.classList.toggle('no-grid', !gridVisible);
          toggleGridButton.classList.toggle('active', gridVisible);
          toggleGridButton.setAttribute('aria-pressed', String(gridVisible));
          persistState();
        });

        snapCheckbox.addEventListener('change', () => {
          gridSnapEnabled = snapCheckbox.checked;
          persistState();
        });

        fitToViewButton.addEventListener('click', () => {
          fitToView();
          persistState();
        });

        resetOverlapButton.addEventListener('click', () => {
          resolveAllOverlaps();
          renderNodes();
          updateEdges();
          persistState();
        });

        resetLayoutButton.addEventListener('click', () => {
          localStorage.removeItem(STORAGE_KEY);
          scale = 1;
          pan = { x: 0, y: 0 };
          gridVisible = true;
          gridSnapEnabled = true;
          toggleGridButton.classList.add('active');
          toggleGridButton.setAttribute('aria-pressed', 'true');
          snapCheckbox.checked = true;
          mapCanvas.classList.remove('no-grid');
          state.nodes = new Map(BASE_NODES.map(node => [node.id, cloneNode(node)]));
          state.edges = BASE_EDGES.map(edge => ({ ...edge }));
          renderNodes();
          applyTransform();
          updateEdges();
          persistState();
        });

        exportJsonButton.addEventListener('click', () => {
          const payload = exportState();
          download('transcription_initiation_polII.json', JSON.stringify(payload, null, 2), 'application/json');
        });

        importJsonButton.addEventListener('click', () => {
          importFileInput.click();
        });

        importFileInput.addEventListener('change', handleImportFile);

        exportSvgButton.addEventListener('click', () => {
          const svgMarkup = buildExportSvg();
          download('transcription_initiation_polII.svg', `<?xml version="1.0" encoding="UTF-8"?>\n${svgMarkup}`, 'image/svg+xml;charset=utf-8');
        });

        exportPngButton.addEventListener('click', () => {
          const svgMarkup = buildExportSvg();
          const blob = new Blob([svgMarkup], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const img = new Image();
          const canvas = document.createElement('canvas');
          const ratio = Math.max(2, Math.round(window.devicePixelRatio || 2));
          canvas.width = MAP_WIDTH * ratio;
          canvas.height = MAP_HEIGHT * ratio;
          const ctx = canvas.getContext('2d');
          img.onload = () => {
            ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
            ctx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);
            canvas.toBlob(result => {
              if (result) {
                download('transcription_initiation_polII.png', result, 'image/png');
              }
            }, 'image/png');
          };
          img.src = url;
        });

        exportPdfButton.addEventListener('click', () => {
          window.print();
        });

        mapCanvas.addEventListener('wheel', handleWheel, { passive: false });
        mapCanvas.addEventListener('pointerdown', handlePanStart);
        mapCanvas.addEventListener('pointermove', handlePanMove);
        mapCanvas.addEventListener('pointerup', handlePanEnd);
        mapCanvas.addEventListener('pointercancel', handlePanEnd);
        mapCanvas.addEventListener('keydown', handleCanvasKeydown);
      }

      function applyStaticText() {
        document.title = getLocaleString('page.title');

        const pageElement = document.querySelector('.page');
        if (pageElement) {
          pageElement.setAttribute('aria-label', getLocaleString('page.ariaLabel'));
        }

        const headerTitle = document.getElementById('header-title');
        if (headerTitle) headerTitle.textContent = getLocaleString('page.header.title');
        const headerPill = document.getElementById('header-pill');
        if (headerPill) headerPill.textContent = getLocaleString('page.header.pill');
        const metaEnvironment = document.getElementById('meta-environment');
        if (metaEnvironment) metaEnvironment.textContent = getLocaleString('page.header.meta.environment');
        const metaContext = document.getElementById('meta-context');
        if (metaContext) metaContext.textContent = getLocaleString('page.header.meta.context');
        const metaFocus = document.getElementById('meta-focus');
        if (metaFocus) metaFocus.textContent = getLocaleString('page.header.meta.focus');

        const mapTitleElement = document.getElementById('map-title');
        if (mapTitleElement) mapTitleElement.textContent = getLocaleString('map.title');
        const mapToolbar = document.getElementById('map-toolbar');
        if (mapToolbar) mapToolbar.setAttribute('aria-label', getLocaleString('map.toolbarAria'));

        if (fitToViewButton) fitToViewButton.textContent = getLocaleString('map.buttons.fit');
        if (toggleGridButton) toggleGridButton.textContent = getLocaleString('map.buttons.grid');
        const snapLabelText = document.getElementById('snap-label-text');
        if (snapLabelText) snapLabelText.textContent = getLocaleString('map.buttons.snap');
        if (resetOverlapButton) resetOverlapButton.textContent = getLocaleString('map.buttons.resetOverlap');

        if (mapCanvas) mapCanvas.setAttribute('aria-label', getLocaleString('map.canvasAria'));
        const axisLabel = document.getElementById('axis-label');
        if (axisLabel) axisLabel.textContent = getLocaleString('map.axisLabel');
        const instructions = document.getElementById('map-instructions');
        if (instructions) instructions.textContent = getLocaleString('map.instructions');

        const legendElement = document.getElementById('legend');
        if (legendElement) legendElement.setAttribute('aria-label', getLocaleString('map.legendAria'));
        const legendPolii = document.getElementById('legend-polii');
        if (legendPolii) legendPolii.textContent = getLocaleString('map.legend.polii');
        const legendChromatin = document.getElementById('legend-chromatin');
        if (legendChromatin) legendChromatin.textContent = getLocaleString('map.legend.chromatin');
        const legendRna = document.getElementById('legend-rna');
        if (legendRna) legendRna.textContent = getLocaleString('map.legend.rna');

        const stepsTitle = document.getElementById('steps-title');
        if (stepsTitle) stepsTitle.textContent = getLocaleString('timeline.title');
        const timelineContainer = document.getElementById('timeline');
        if (timelineContainer) timelineContainer.setAttribute('aria-label', getLocaleString('timeline.ariaLabel'));

        renderRegulation();

        const modelTitleMain = document.getElementById('model-title-main');
        if (modelTitleMain) modelTitleMain.textContent = getLocaleString('model.title');
        const modelSubheading = document.getElementById('model-subheading');
        if (modelSubheading) modelSubheading.textContent = getLocaleString('model.subheading');
        const modelTabsElement = document.getElementById('model-tabs');
        if (modelTabsElement) modelTabsElement.setAttribute('aria-label', getLocaleString('model.ariaLabel'));

        const footerScales = document.getElementById('footer-scales');
        if (footerScales) footerScales.textContent = getLocaleString('footer.scales');
        const exportControls = document.getElementById('export-controls');
        if (exportControls) exportControls.setAttribute('aria-label', getLocaleString('footer.controlsAria'));
        if (exportSvgButton) exportSvgButton.textContent = getLocaleString('footer.buttons.exportSvg');
        if (exportPngButton) exportPngButton.textContent = getLocaleString('footer.buttons.exportPng');
        if (exportPdfButton) exportPdfButton.textContent = getLocaleString('footer.buttons.exportPdf');
        if (exportJsonButton) exportJsonButton.textContent = getLocaleString('footer.buttons.exportJson');
        if (importJsonButton) importJsonButton.textContent = getLocaleString('footer.buttons.importJson');
        if (resetLayoutButton) resetLayoutButton.textContent = getLocaleString('footer.buttons.resetLayout');
        const openReferenceButton = document.getElementById('open-reference');
        if (openReferenceButton) openReferenceButton.textContent = getLocaleString('footer.buttons.openReference');

        populateOverlayTable();
      }

      function renderRegulation() {
        const grid = document.getElementById('regulation-grid');
        if (!grid) return;
        grid.setAttribute('aria-label', getLocaleString('regulation.ariaLabel'));
        grid.innerHTML = '';
        getLocaleArray('regulation.chips').forEach(text => {
          const chip = document.createElement('div');
          chip.className = 'chip';
          chip.textContent = text;
          grid.appendChild(chip);
        });
      }

      function populateOverlayTable() {
        const closeButton = document.getElementById('close-overlay');
        if (closeButton) closeButton.textContent = getLocaleString('overlay.close');
        const overlayTitle = document.getElementById('overlay-title');
        if (overlayTitle) overlayTitle.textContent = getLocaleString('overlay.title');
        const overlayElement = document.getElementById('reference-overlay');
        if (overlayElement) overlayElement.setAttribute('aria-labelledby', 'overlay-title');
        const colModule = document.getElementById('overlay-col-module');
        if (colModule) colModule.textContent = getLocaleString('overlay.columns.module');
        const colComposition = document.getElementById('overlay-col-composition');
        if (colComposition) colComposition.textContent = getLocaleString('overlay.columns.composition');
        const colFunction = document.getElementById('overlay-col-function');
        if (colFunction) colFunction.textContent = getLocaleString('overlay.columns.function');
        const colControl = document.getElementById('overlay-col-control');
        if (colControl) colControl.textContent = getLocaleString('overlay.columns.control');

        const tbody = document.getElementById('overlay-body');
        if (!tbody) return;
        tbody.innerHTML = '';
        const rows = getLocaleEntry('overlay.rows');
        if (Array.isArray(rows)) {
          rows.forEach(row => {
            const tr = document.createElement('tr');
            ['module', 'composition', 'function', 'control'].forEach(key => {
              const td = document.createElement('td');
              const value = typeof row?.[key] === 'string' ? row[key] : '';
              td.textContent = value;
              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });
        }
      }

      function formatNodeAria(label, type) {
        const template = getLocaleString('messages.nodeAria') || '';
        return template
          .replace(/\{label\}/g, label ?? '')
          .replace(/\{type\}/g, type ?? '');
      }

      function handleImportFile(event) {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const payload = JSON.parse(reader.result);
            applyImportedState(payload);
            renderNodes();
            updateEdges();
            persistState();
          } catch (error) {
            alert(getLocaleString('messages.importError') + error.message);
          }
        };
        reader.readAsText(file);
        event.target.value = '';
      }

      function handleWheel(event) {
        event.preventDefault();
        if (event.ctrlKey) {
          const factor = event.deltaY < 0 ? 1.1 : 0.9;
          zoomAt(factor, event.clientX, event.clientY);
          persistState();
        } else {
          pan.x -= event.deltaX;
          pan.y -= event.deltaY;
          applyTransform();
          persistState();
        }
      }

      function handlePanStart(event) {
        if (event.button !== 0) return;
        if (!(event.target === mapCanvas || event.target === mapViewport)) return;
        isPanning = true;
        panPointerId = event.pointerId;
        mapCanvas.setPointerCapture(panPointerId);
        mapCanvas.classList.add('panning');
      }

      function handlePanMove(event) {
        if (!isPanning || event.pointerId !== panPointerId) return;
        pan.x += event.movementX;
        pan.y += event.movementY;
        applyTransform();
      }

      function handlePanEnd(event) {
        if (panPointerId !== null && event.pointerId === panPointerId) {
          mapCanvas.releasePointerCapture(panPointerId);
          panPointerId = null;
          isPanning = false;
          mapCanvas.classList.remove('panning');
          persistState();
        }
      }

      function handleCanvasKeydown(event) {
        const panStep = event.shiftKey ? 60 : 30;
        const center = getCanvasCenter();
        let handled = false;
        if (event.key === 'ArrowUp') {
          pan.y += panStep;
          handled = true;
        } else if (event.key === 'ArrowDown') {
          pan.y -= panStep;
          handled = true;
        } else if (event.key === 'ArrowLeft') {
          pan.x += panStep;
          handled = true;
        } else if (event.key === 'ArrowRight') {
          pan.x -= panStep;
          handled = true;
        } else if (event.key === '+' || event.key === '=') {
          zoomAt(1.1, center.x, center.y);
          handled = true;
        } else if (event.key === '-' || event.key === '_') {
          zoomAt(0.9, center.x, center.y);
          handled = true;
        } else if (event.key === '0') {
          fitToView();
          handled = true;
        }
        if (handled) {
          event.preventDefault();
          applyTransform();
          persistState();
        }
      }

      function renderNodes() {
        nodeLayer.innerHTML = '';
        const fragment = document.createDocumentFragment();
        const sorted = Array.from(state.nodes.values()).sort((a, b) => {
          const za = a.z ?? (LAYER_ORDER[a.layer] ?? 1);
          const zb = b.z ?? (LAYER_ORDER[b.layer] ?? 1);
          return za - zb;
        });
        sorted.forEach(node => {
          const element = createNodeElement(node);
          fragment.appendChild(element);
        });
        nodeLayer.appendChild(fragment);
      }

      function createNodeElement(node) {
        const element = document.createElement('div');
        element.className = 'node';
        element.dataset.layer = node.layer;
        element.dataset.id = node.id;
        element.tabIndex = 0;
        element.setAttribute('role', 'group');
        element.setAttribute('aria-label', formatNodeAria(node.label, node.type));

        const title = document.createElement('div');
        title.className = 'node-title';
        const label = document.createElement('span');
        label.textContent = node.label;
        const type = document.createElement('span');
        type.className = 'node-type';
        type.textContent = node.type;
        title.append(label, type);
        element.appendChild(title);

        if (Array.isArray(node.notes) && node.notes.length) {
          const list = document.createElement('ul');
          list.className = 'node-notes';
          node.notes.forEach(note => {
            const li = document.createElement('li');
            li.textContent = note;
            list.appendChild(li);
          });
          element.appendChild(list);
        }

        const handle = document.createElement('div');
        handle.className = 'node-handle';
        handle.setAttribute('aria-hidden', 'true');
        handle.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M7 4h2v2H7V4zm4 0h2v2h-2V4zm4 0h2v2h-2V4zM7 9h2v2H7V9zm4 0h2v2h-2V9zm4 0h2v2h-2V9zM7 14h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM7 19h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z"></path></svg><span>${getLocaleString('messages.dragHandle')}</span>`;
        element.appendChild(handle);

        applyNodePosition(element, node);
        attachDrag(element, node);
        element.addEventListener('keydown', event => handleNodeKeydown(event, node, element));
        return element;
      }

      function attachDrag(element, node) {
        let pointerId = null;
        let origin = null;
        element.addEventListener('pointerdown', event => {
          if (event.button !== 0) return;
          pointerId = event.pointerId;
          origin = {
            mapX: getMapPoint(event).x,
            mapY: getMapPoint(event).y,
            nodeX: node.x,
            nodeY: node.y
          };
          element.setPointerCapture(pointerId);
          element.classList.add('dragging');
          const baseZ = node.z ?? (LAYER_ORDER[node.layer] ?? 1);
          element.style.zIndex = String(baseZ + 100);
          event.stopPropagation();
        });

        element.addEventListener('pointermove', event => {
          if (pointerId !== event.pointerId || !origin) return;
          const point = getMapPoint(event);
          let nextX = origin.nodeX + (point.x - origin.mapX);
          let nextY = origin.nodeY + (point.y - origin.mapY);
          if (gridSnapEnabled) {
            nextX = snap(nextX);
            nextY = snap(nextY);
          }
          node.x = nextX;
          node.y = nextY;
          clampNode(node);
          applyNodePosition(element, node, false);
          updateEdges();
        });

        const finish = event => {
          if (pointerId === null || (event && event.pointerId !== pointerId)) return;
          element.releasePointerCapture(pointerId);
          pointerId = null;
          element.classList.remove('dragging');
          resolveOverlapsFor(node);
          applyNodePosition(element, node);
          updateEdges();
          persistState();
        };

        element.addEventListener('pointerup', finish);
        element.addEventListener('pointercancel', finish);
      }

      function handleNodeKeydown(event, node, element) {
        const step = event.shiftKey ? GRID_SIZE * 2 : GRID_SIZE;
        let moved = false;
        if (event.key === 'ArrowUp') {
          node.y -= step;
          moved = true;
        } else if (event.key === 'ArrowDown') {
          node.y += step;
          moved = true;
        } else if (event.key === 'ArrowLeft') {
          node.x -= step;
          moved = true;
        } else if (event.key === 'ArrowRight') {
          node.x += step;
          moved = true;
        }
        if (moved) {
          event.preventDefault();
          if (gridSnapEnabled) {
            node.x = snap(node.x);
            node.y = snap(node.y);
          }
          clampNode(node);
          resolveOverlapsFor(node);
          applyNodePosition(element, node);
          updateEdges();
          persistState();
        }
      }

      function applyNodePosition(element, node, resetZ = true) {
        element.style.left = `${node.x}px`;
        element.style.top = `${node.y}px`;
        element.style.width = `${node.width}px`;
        element.style.height = `${node.height}px`;
        if (resetZ) {
          const baseZ = node.z ?? (LAYER_ORDER[node.layer] ?? 1);
          element.style.zIndex = String(baseZ);
        }
      }

      function getMapPoint(event) {
        const rect = mapCanvas.getBoundingClientRect();
        return {
          x: (event.clientX - rect.left - pan.x) / scale,
          y: (event.clientY - rect.top - pan.y) / scale
        };
      }

      function updateEdges() {
        edgeLayer.querySelectorAll('path').forEach(path => path.remove());
        state.edges.forEach(edge => {
          const from = state.nodes.get(edge.from);
          const to = state.nodes.get(edge.to);
          if (!from || !to) return;
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.dataset.kind = edge.kind || 'flow';
          path.dataset.router = edge.router || 'orthogonal';
          path.setAttribute('d', computeOrthogonalPath(from, to));
          const markerEnd = edge.markers?.end || (edge.kind === 'regulation' ? 'arrow-regulation' : 'arrow-flow');
          if (markerEnd) {
            path.setAttribute('marker-end', `url(#${markerEnd})`);
          }
          if (edge.markers?.start) {
            path.setAttribute('marker-start', `url(#${edge.markers.start})`);
          }
          if (edge.label) {
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            title.textContent = edge.label;
            path.appendChild(title);
          }
          edgeLayer.appendChild(path);
        });
      }

      function computeOrthogonalPath(from, to) {
        const fromCenter = { x: from.x + from.width / 2, y: from.y + from.height / 2 };
        const toCenter = { x: to.x + to.width / 2, y: to.y + to.height / 2 };
        const horizontalPreference = Math.abs(fromCenter.x - toCenter.x) >= Math.abs(fromCenter.y - toCenter.y);
        let segments = [];
        if (horizontalPreference) {
          const startX = fromCenter.x <= toCenter.x ? from.x + from.width : from.x;
          const endX = fromCenter.x <= toCenter.x ? to.x : to.x + to.width;
          const midX = startX + (endX - startX) / 2;
          segments = [
            `M ${startX} ${fromCenter.y}`,
            `H ${midX}`,
            `V ${toCenter.y}`,
            `H ${endX}`
          ];
        } else {
          const startY = fromCenter.y <= toCenter.y ? from.y + from.height : from.y;
          const endY = fromCenter.y <= toCenter.y ? to.y : to.y + to.height;
          const midY = startY + (endY - startY) / 2;
          segments = [
            `M ${fromCenter.x} ${startY}`,
            `V ${midY}`,
            `H ${toCenter.x}`,
            `V ${endY}`
          ];
        }
        return segments.join(' ');
      }

      function resolveOverlapsFor(node) {
        const others = Array.from(state.nodes.values()).filter(other => other.id !== node.id);
        let iterations = 0;
        while (others.some(other => boxesOverlap(node, other))) {
          node.y = snap(node.y + GRID_SIZE);
          if (node.y + node.height > MAP_HEIGHT) {
            node.y = clamp(node.y - GRID_SIZE, 0, MAP_HEIGHT - node.height);
            node.x = snap(node.x + GRID_SIZE);
          }
          clampNode(node);
          if (++iterations > 200) break;
        }
      }

      function resolveAllOverlaps() {
        const ordered = Array.from(state.nodes.values()).sort((a, b) => a.x - b.x || a.y - b.y);
        ordered.forEach(node => resolveOverlapsFor(node));
      }

      function boxesOverlap(a, b) {
        return !(a.x + a.width <= b.x || b.x + b.width <= a.x || a.y + a.height <= b.y || b.y + b.height <= a.y);
      }

      function clampNode(node) {
        node.width = Math.max(96, node.width);
        node.height = Math.max(80, node.height);
        node.x = clamp(node.x, 0, MAP_WIDTH - node.width);
        node.y = clamp(node.y, 0, MAP_HEIGHT - node.height);
      }

      function snap(value) {
        return Math.round(value / GRID_SIZE) * GRID_SIZE;
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function zoomAt(factor, clientX, clientY) {
        const rect = mapCanvas.getBoundingClientRect();
        const originX = clientX - rect.left;
        const originY = clientY - rect.top;
        const mapX = (originX - pan.x) / scale;
        const mapY = (originY - pan.y) / scale;
        const newScale = clamp(scale * factor, 0.5, 2.5);
        pan.x = originX - mapX * newScale;
        pan.y = originY - mapY * newScale;
        scale = newScale;
        applyTransform();
      }

      function fitToView() {
        const rect = mapCanvas.getBoundingClientRect();
        const scaleX = rect.width / MAP_WIDTH;
        const scaleY = rect.height / MAP_HEIGHT;
        scale = clamp(Math.min(scaleX, scaleY), 0.5, 2.5);
        pan = {
          x: (rect.width - MAP_WIDTH * scale) / 2,
          y: (rect.height - MAP_HEIGHT * scale) / 2
        };
        applyTransform();
      }

      function getCanvasCenter() {
        const rect = mapCanvas.getBoundingClientRect();
        return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      }

      function applyTransform() {
        mapViewport.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${scale})`;
      }

      function cloneNode(node, overrides = {}) {
        const width = Math.max(96, Number.isFinite(Number(overrides.width)) ? Number(overrides.width) : node.width);
        const height = Math.max(80, Number.isFinite(Number(overrides.height)) ? Number(overrides.height) : node.height);
        let x = Number.isFinite(Number(overrides.x)) ? Number(overrides.x) : node.x;
        let y = Number.isFinite(Number(overrides.y)) ? Number(overrides.y) : node.y;
        x = clamp(x, 0, MAP_WIDTH - width);
        y = clamp(y, 0, MAP_HEIGHT - height);
        const baseNotes = Array.isArray(node.notes) ? node.notes.slice() : [];
        const notes = Array.isArray(overrides.notes) && overrides.notes.length ? overrides.notes.slice(0, 6).map(String) : baseNotes;
        return {
          id: overrides.id ?? node.id,
          label: overrides.label ?? node.label,
          type: overrides.type ?? node.type,
          layer: overrides.layer ?? node.layer,
          x,
          y,
          width,
          height,
          notes,
          z: Number.isFinite(overrides.z) ? overrides.z : node.z ?? (LAYER_ORDER[node.layer] ?? 1)
        };
      }

      function restoreState() {
        try {
          const storedRaw = localStorage.getItem(STORAGE_KEY);
          if (!storedRaw) {
            gridVisible = true;
            gridSnapEnabled = true;
            return;
          }
          const stored = JSON.parse(storedRaw);
          if (Array.isArray(stored.nodes)) {
            const merged = new Map(BASE_NODES.map(node => [node.id, cloneNode(node)]));
            stored.nodes.forEach(raw => {
              if (!raw || !raw.id) return;
              const base = merged.get(raw.id) || BASE_NODES.find(node => node.id === raw.id) || raw;
              merged.set(raw.id, cloneNode(base, raw));
            });
            state.nodes = merged;
          }
          if (Array.isArray(stored.edges) && stored.edges.length) {
            state.edges = stored.edges.map(edge => ({
              id: edge.id,
              from: edge.from,
              to: edge.to,
              kind: edge.kind || 'flow',
              router: edge.router || 'orthogonal',
              label: edge.label || '',
              markers: edge.markers || null
            }));
          }
          if (stored.transform) {
            scale = clamp(Number(stored.transform.scale) || 1, 0.5, 2.5);
            pan = {
              x: Number.isFinite(Number(stored.transform.pan?.x)) ? Number(stored.transform.pan.x) : 0,
              y: Number.isFinite(Number(stored.transform.pan?.y)) ? Number(stored.transform.pan.y) : 0
            };
          }
          if (stored.preferences) {
            gridVisible = stored.preferences.gridVisible ?? true;
            gridSnapEnabled = stored.preferences.gridSnap ?? true;
          }
          mapCanvas.classList.toggle('no-grid', !gridVisible);
          toggleGridButton.classList.toggle('active', gridVisible);
          toggleGridButton.setAttribute('aria-pressed', String(gridVisible));
          snapCheckbox.checked = gridSnapEnabled;
        } catch (error) {
          console.warn(getLocaleString('messages.stateReset'), error);
          localStorage.removeItem(STORAGE_KEY);
          gridVisible = true;
          gridSnapEnabled = true;
        }
      }

      function exportState() {
        return {
          nodes: Array.from(state.nodes.values()).map(node => ({
            id: node.id,
            label: node.label,
            type: node.type,
            layer: node.layer,
            x: node.x,
            y: node.y,
            width: node.width,
            height: node.height,
            notes: node.notes,
            z: node.z
          })),
          edges: state.edges,
          transform: { scale, pan },
          preferences: { gridVisible, gridSnap: gridSnapEnabled }
        };
      }

      function persistState() {
        try {
          const payload = exportState();
          localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch (error) {
          console.warn(getLocaleString('messages.saveError'), error);
        }
      }

      function applyImportedState(payload) {
        if (!payload || !Array.isArray(payload.nodes)) {
          throw new Error(getLocaleString('messages.missingNodes'));
        }
        const merged = new Map(BASE_NODES.map(node => [node.id, cloneNode(node)]));
        payload.nodes.forEach(raw => {
          if (!raw || !raw.id) return;
          const base = merged.get(raw.id) || BASE_NODES.find(node => node.id === raw.id) || raw;
          merged.set(raw.id, cloneNode(base, raw));
        });
        state.nodes = merged;
        if (Array.isArray(payload.edges) && payload.edges.length) {
          state.edges = payload.edges.map(edge => ({
            id: edge.id,
            from: edge.from,
            to: edge.to,
            kind: edge.kind || 'flow',
            router: edge.router || 'orthogonal',
            label: edge.label || '',
            markers: edge.markers || null
          }));
        } else {
          state.edges = BASE_EDGES.map(edge => ({ ...edge }));
        }
        if (payload.transform) {
          scale = clamp(Number(payload.transform.scale) || 1, 0.5, 2.5);
          pan = {
            x: Number.isFinite(Number(payload.transform.pan?.x)) ? Number(payload.transform.pan.x) : 0,
            y: Number.isFinite(Number(payload.transform.pan?.y)) ? Number(payload.transform.pan.y) : 0
          };
        }
        if (payload.preferences) {
          gridVisible = payload.preferences.gridVisible ?? gridVisible;
          gridSnapEnabled = payload.preferences.gridSnap ?? gridSnapEnabled;
          mapCanvas.classList.toggle('no-grid', !gridVisible);
          toggleGridButton.classList.toggle('active', gridVisible);
          toggleGridButton.setAttribute('aria-pressed', String(gridVisible));
          snapCheckbox.checked = gridSnapEnabled;
        }
        applyTransform();
      }

      function buildExportSvg() {
        const parts = [];
        parts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${MAP_WIDTH}" height="${MAP_HEIGHT}" viewBox="0 0 ${MAP_WIDTH} ${MAP_HEIGHT}">`);
        parts.push('<rect width="100%" height="100%" fill="#f8fafc"/>');
        parts.push('<g stroke-width="1">');
        for (let x = GRID_SIZE; x < MAP_WIDTH; x += GRID_SIZE) {
          const major = x % (GRID_SIZE * 5) === 0;
          const color = major ? 'rgba(29,78,216,0.18)' : 'rgba(148,163,184,0.16)';
          parts.push(`<line x1="${x}" y1="0" x2="${x}" y2="${MAP_HEIGHT}" stroke="${color}"/>`);
        }
        for (let y = GRID_SIZE; y < MAP_HEIGHT; y += GRID_SIZE) {
          const major = y % (GRID_SIZE * 5) === 0;
          const color = major ? 'rgba(29,78,216,0.18)' : 'rgba(148,163,184,0.16)';
          parts.push(`<line x1="0" y1="${y}" x2="${MAP_WIDTH}" y2="${y}" stroke="${color}"/>`);
        }
        parts.push('</g>');
        state.edges.forEach(edge => {
          const from = state.nodes.get(edge.from);
          const to = state.nodes.get(edge.to);
          if (!from || !to) return;
          const d = computeOrthogonalPath(from, to);
          const stroke = edge.kind === 'regulation' ? '#b91c1c' : '#1d4ed8';
          const dash = edge.kind === 'regulation' ? ' stroke-dasharray="6 3"' : '';
          parts.push(`<path d="${d}" fill="none" stroke="${stroke}" stroke-width="2.5"${dash} marker-end="url(#${edge.markers?.end || (edge.kind === 'regulation' ? 'arrow-regulation' : 'arrow-flow')})"/>`);
        });
        parts.push('<defs>');
        parts.push('<marker id="arrow-flow" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="#1d4ed8"></path></marker>');
        parts.push('<marker id="arrow-regulation" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="#b91c1c"></path></marker>');
        parts.push('<marker id="tee-regulation" viewBox="0 0 10 10" refX="2" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto"><path d="M 2 0 L 2 10" stroke="#b91c1c" stroke-width="2"></path></marker>');
        parts.push('</defs>');
        const nodes = Array.from(state.nodes.values()).sort((a, b) => (a.z ?? LAYER_ORDER[a.layer] ?? 1) - (b.z ?? LAYER_ORDER[b.layer] ?? 1));
        nodes.forEach(node => {
          const style = LAYER_STYLE[node.layer] || { fill: '#e2e8f0', stroke: '#475569' };
          parts.push(`<g>`);
          parts.push(`<rect x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="10" ry="10" fill="${style.fill}" stroke="${style.stroke}" stroke-width="1.5"/>`);
          parts.push(`<text x="${node.x + 12}" y="${node.y + 22}" font-size="12" font-family="Fira Sans, Segoe UI, sans-serif" font-weight="600" fill="#111111">${escapeXml(node.label)}</text>`);
          parts.push(`<text x="${node.x + 12}" y="${node.y + 38}" font-size="9" font-family="Fira Sans, Segoe UI, sans-serif" fill="#475569">${escapeXml(node.type)}</text>`);
          node.notes.forEach((note, index) => {
            const noteY = node.y + 58 + index * 16;
            if (noteY < node.y + node.height - 8) {
              parts.push(`<text x="${node.x + 12}" y="${noteY}" font-size="9" font-family="Fira Sans, Segoe UI, sans-serif" fill="#4b5563">${escapeXml(note)}</text>`);
            }
          });
          parts.push('</g>');
        });
        parts.push('</svg>');
        return parts.join('');
      }

      function download(filename, content, type) {
        const blob = content instanceof Blob ? content : new Blob([content], { type });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      }

      function escapeXml(value) {
        return String(value ?? '').replace(/[&<>"']/g, char => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[char]));
      }

      function setupTimeline() {
        const timelineContainer = document.getElementById('timeline');
        const stepPanel = document.getElementById('step-panel');
        if (!timelineContainer || !stepPanel) return;

        timelineContainer.innerHTML = '';
        const steps = getLocaleEntry('timeline.steps') || {};
        const orderSource = getLocaleEntry('timeline.order');
        const order = Array.isArray(orderSource) ? orderSource : TIMELINE_ORDER;
        let activeKey = null;

        order.forEach(key => {
          const step = steps?.[key];
          if (!step) return;
          const button = document.createElement('button');
          button.type = 'button';
          button.dataset.step = key;
          button.setAttribute('role', 'tab');
          button.setAttribute('aria-selected', 'false');

          const titleSpan = document.createElement('span');
          titleSpan.className = 'title';
          titleSpan.textContent = typeof step.buttonTitle === 'string' ? step.buttonTitle : '';
          const detailSpan = document.createElement('span');
          detailSpan.className = 'detail';
          detailSpan.textContent = typeof step.buttonDetail === 'string' ? step.buttonDetail : '';
          button.append(titleSpan, detailSpan);

          button.addEventListener('click', () => selectStep(key));

          timelineContainer.appendChild(button);
          if (activeKey === null) {
            activeKey = key;
            button.classList.add('active');
            button.setAttribute('aria-selected', 'true');
          }
        });

        function selectStep(stepKey) {
          const step = steps?.[stepKey];
          if (!step) return;
          Array.from(timelineContainer.children).forEach(child => {
            if (!(child instanceof HTMLElement)) return;
            const isActive = child.dataset.step === stepKey;
            child.classList.toggle('active', isActive);
            child.setAttribute('aria-selected', String(isActive));
          });
          stepPanel.innerHTML = '';
          const title = document.createElement('h3');
          title.textContent = typeof step.panelTitle === 'string' ? step.panelTitle : '';
          stepPanel.appendChild(title);
          const list = document.createElement('ul');
          const points = Array.isArray(step.panelPoints) ? step.panelPoints : [];
          points.forEach(point => {
            const li = document.createElement('li');
            li.textContent = point;
            list.appendChild(li);
          });
          stepPanel.appendChild(list);
        }

        if (activeKey) {
          selectStep(activeKey);
        } else {
          stepPanel.innerHTML = '';
        }
      }

      function setupOverlay() {
        const overlay = document.getElementById('reference-overlay');
        const openButton = document.getElementById('open-reference');
        const closeButton = document.getElementById('close-overlay');
        openButton.addEventListener('click', () => overlay.classList.add('active'));
        closeButton.addEventListener('click', () => overlay.classList.remove('active'));
        overlay.addEventListener('click', event => {
          if (event.target === overlay) {
            overlay.classList.remove('active');
          }
        });
      }

      function setupModelTabs() {
        const modelButtons = document.querySelectorAll('.model-tabs button');
        const modelPanel = document.getElementById('model-panel');
        if (!modelButtons.length || !modelPanel) return;

        const tabLabels = getLocaleEntry('model.tabs') || {};
        modelButtons.forEach(button => {
          const key = button.dataset.model;
          button.textContent = typeof tabLabels?.[key] === 'string' ? tabLabels[key] : '';
          button.setAttribute('role', 'tab');
          button.setAttribute('aria-selected', button.classList.contains('active') ? 'true' : 'false');
        });

        const content = getLocaleEntry('model.content') || {};

        function renderModelSection(key) {
          const section = content?.[key];
          modelPanel.innerHTML = '';
          if (!section) return;
          const title = document.createElement('h3');
          title.textContent = typeof section.title === 'string' ? section.title : '';
          modelPanel.appendChild(title);
          const list = document.createElement('ul');
          const items = Array.isArray(section.items) ? section.items : [];
          items.forEach(item => {
            const li = document.createElement('li');
            li.innerHTML = item;
            list.appendChild(li);
          });
          modelPanel.appendChild(list);
          if (section.callout) {
            const callout = document.createElement('div');
            callout.className = 'callout';
            callout.innerHTML = section.callout;
            modelPanel.appendChild(callout);
          }
          if (section.snippet) {
            const pre = document.createElement('pre');
            pre.textContent = section.snippet;
            modelPanel.appendChild(pre);
          }
        }

        modelButtons.forEach(button => {
          button.addEventListener('click', () => {
            modelButtons.forEach(other => {
              const isActive = other === button;
              other.classList.toggle('active', isActive);
              other.setAttribute('aria-selected', String(isActive));
            });
            renderModelSection(button.dataset.model);
          });
        });

        const activeButton = Array.from(modelButtons).find(btn => btn.classList.contains('active')) || modelButtons[0];
        if (activeButton) {
          modelButtons.forEach(btn => {
            const isActive = btn === activeButton;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-selected', String(isActive));
          });
          renderModelSection(activeButton.dataset.model);
        }
      }


    })();
  </script>
</body>
</html>
