<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="ui-lang" content="ru" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; script-src 'self' 'unsafe-inline'; connect-src 'none'; frame-ancestors 'self'; base-uri 'self'; form-action 'none'; sandbox allow-scripts allow-same-origin allow-downloads allow-modals" />
  <meta http-equiv="Referrer-Policy" content="no-referrer" />
  <meta http-equiv="X-Content-Type-Options" content="nosniff" />
  <meta name="color-scheme" content="only light" />
  <title>Инициация транскрипции Pol II — схема процесса</title>
  <!-- Spec-Version: v1.1 | Generated-At: 2025-09-29 | LANG: HTML | TOPIC: Transcription initiation (Pol II, +1 TSS) | ORG: eukaryote | LEVEL: advanced | VIEW: process | THEME: print | EXPORTS: svg,png,pdf | LAYOUT: A4-landscape | INTERACTIVE: on -->
  <style>
    :root {
      color-scheme: only light;
      font-family: "Fira Sans", "Segoe UI", system-ui, sans-serif;
      --bg: #ffffff;
      --ink: #111111;
      --accent: #1d4ed8;
      --accent-soft: rgba(29, 78, 216, 0.12);
      --accent-strong: rgba(29, 78, 216, 0.75);
      --muted: #555555;
      --grid-line: rgba(0, 0, 0, 0.08);
      --highlight: #d97706;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--ink);
      height: 100%;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 12mm;
    }
    .page {
      width: 100%;
      max-width: 297mm;
      min-height: 210mm;
      background: var(--bg);
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 8mm;
      padding: 14mm 18mm;
      position: relative;
      overflow: auto;
    }
    .page::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image: linear-gradient(to right, transparent 0, transparent 28mm, var(--grid-line) 28mm, transparent 28.5mm),
        linear-gradient(to bottom, transparent 0, transparent 28mm, var(--grid-line) 28mm, transparent 28.5mm);
      opacity: 0.45;
      pointer-events: none;
    }
    header {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: start;
      gap: 12mm;
    }
    header h1 {
      margin: 0;
      font-size: 22pt;
      letter-spacing: -0.4pt;
    }
    header .meta-column {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 3mm;
    }
    header .meta {
      text-align: right;
      font-size: 9pt;
      line-height: 1.4;
      color: var(--muted);
    }
    #language-switch {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 1.5mm;
      font-size: 8pt;
      color: var(--muted);
    }
    #language-switch select {
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 6px;
      padding: 1mm 3mm;
      font-size: 8.5pt;
      background: #ffffff;
      color: var(--ink);
      cursor: pointer;
      min-width: 52px;
    }
    #language-switch select:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 1mm;
    }
    main {
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 10mm;
    }
    .block {
      background: rgba(255,255,255,0.94);
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 6px;
      padding: 6mm;
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
    }
    .block h2 {
      margin-top: 0;
      font-size: 14pt;
      letter-spacing: -0.2pt;
    }
    .block p, .block li {
      font-size: 10pt;
      line-height: 1.45;
    }
    .block ul {
      margin: 0;
      padding-left: 4mm;
      list-style: square;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 2mm;
      background: var(--accent-soft);
      color: var(--accent);
      border-radius: 999px;
      padding: 1mm 4mm;
      font-size: 8pt;
      text-transform: uppercase;
      letter-spacing: 0.6pt;
    }
    .flow-map {
      position: relative;
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 4mm;
    }
    .map-stage {
      display: flex;
      flex-direction: column;
      gap: 3mm;
      flex: 1;
      min-height: 0;
    }
    .map-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 3mm;
      align-items: center;
    }
    .map-toolbar button,
    .map-toolbar label,
    .map-toolbar .preset-control {
      display: inline-flex;
      align-items: center;
      gap: 2mm;
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 999px;
      background: #f8fafc;
      padding: 2mm 4mm;
      font-size: 8.5pt;
      cursor: pointer;
      transition: background 0.2s, border 0.2s, color 0.2s;
    }
    .map-toolbar label.preset-control {
      flex-direction: column;
      align-items: flex-start;
      gap: 1mm;
      border: none;
      background: transparent;
      padding: 0;
      cursor: default;
    }
    .map-toolbar label.preset-control span {
      font-size: 6.5pt;
      letter-spacing: 0.5pt;
      text-transform: uppercase;
      color: var(--muted);
    }
    .map-toolbar label.preset-control select {
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 6px;
      padding: 1mm 3mm;
      font-size: 8.5pt;
      background: #ffffff;
      min-width: 132px;
      cursor: pointer;
    }
    .map-toolbar button:focus-visible,
    .map-toolbar label:focus-within {
      outline: 2px solid var(--accent);
      outline-offset: 1mm;
    }
    .map-toolbar button.active {
      background: var(--accent);
      color: #ffffff;
      border-color: var(--accent);
    }
    .map-toolbar input[type="checkbox"] {
      accent-color: var(--accent);
    }
    .map-canvas {
      position: relative;
      flex: 1;
      border: 1px solid rgba(0,0,0,0.14);
      border-radius: 8px;
      overflow: hidden;
      background:
        linear-gradient(to right, rgba(29, 78, 216, 0.12) 0 1px, transparent 1px 120px) 0 0 / 120px 120px,
        linear-gradient(to bottom, rgba(29, 78, 216, 0.08) 0 1px, transparent 1px 120px) 0 0 / 120px 120px,
        linear-gradient(to right, rgba(148, 163, 184, 0.18) 0 1px, transparent 1px 24px) 0 0 / 24px 24px,
        linear-gradient(to bottom, rgba(148, 163, 184, 0.18) 0 1px, transparent 1px 24px) 0 0 / 24px 24px,
        #f8fafc;
      touch-action: none;
      min-height: 0;
      cursor: grab;
    }
    .map-canvas:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 1mm;
    }
    .map-canvas.panning {
      cursor: grabbing;
    }
    .map-canvas.no-grid {
      background: #f8fafc;
    }
    .map-viewport {
      position: absolute;
      inset: 0;
      transform-origin: top left;
      width: 960px;
      height: 520px;
    }
    .map-background {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .node-layer {
      position: absolute;
      inset: 0;
    }
    .edge-layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }
    .edge-layer path {
      fill: none;
      stroke-width: 2.5px;
    }
    .edge-layer path[data-kind="flow"] {
      stroke: var(--accent);
    }
    .edge-layer path[data-kind="regulation"] {
      stroke: #b91c1c;
      stroke-dasharray: 6 3;
    }
    .node {
      position: absolute;
      border-radius: 10px;
      border: 1px solid rgba(15, 23, 42, 0.12);
      padding: 6px 8px;
      background: rgba(255,255,255,0.96);
      min-width: 96px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      cursor: grab;
      box-shadow: 0 3px 10px rgba(15, 23, 42, 0.08);
      transition: box-shadow 0.2s;
    }
    .node[data-corrected="true"] {
      outline: 1.2px solid var(--highlight);
      outline-offset: -3px;
    }
    .node:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .node.dragging {
      cursor: grabbing;
      box-shadow: 0 10px 24px rgba(29, 78, 216, 0.28);
    }
    .node[data-layer="chromatin"] {
      background: rgba(74, 222, 128, 0.16);
      border-color: #4d7c0f;
    }
    .node[data-layer="rna"] {
      background: rgba(254, 202, 202, 0.2);
      border-color: #b91c1c;
    }
    .node[data-layer="factors"] {
      background: rgba(199, 210, 254, 0.22);
      border-color: #4338ca;
    }
    .node[data-layer="annotations"] {
      background: rgba(226, 232, 240, 0.6);
      border-color: rgba(15, 23, 42, 0.18);
    }
    .node-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      font-size: 7.2pt;
      letter-spacing: 0.5pt;
      text-transform: uppercase;
      color: var(--muted);
    }
    .node-frame {
      background: rgba(37, 99, 235, 0.12);
      color: #1d4ed8;
      border-radius: 6px;
      padding: 2px 6px;
      font-weight: 600;
    }
    .node-frame[data-kind="genomic"] {
      background: rgba(34, 197, 94, 0.16);
      color: #15803d;
    }
    .node-frame[data-kind="regulatory"] {
      background: rgba(202, 138, 4, 0.18);
      color: #b45309;
    }
    .node-strand {
      background: rgba(15, 23, 42, 0.1);
      color: #0f172a;
      border-radius: 999px;
      padding: 2px 6px;
      font-weight: 600;
    }
    .node-title {
      font-size: 10.5pt;
      font-weight: 600;
      color: var(--ink);
      display: flex;
      justify-content: space-between;
      gap: 6px;
      align-items: center;
    }
    .node-type {
      font-size: 7.5pt;
      text-transform: uppercase;
      letter-spacing: 0.6pt;
      color: var(--muted);
      background: rgba(15, 23, 42, 0.08);
      border-radius: 999px;
      padding: 2px 6px;
      flex-shrink: 0;
    }
    .node-coordinates {
      font-size: 8pt;
      color: #1f2937;
      font-variant-numeric: tabular-nums;
    }
    .node-sites {
      margin: 0;
      padding-left: 14px;
      font-size: 8pt;
      line-height: 1.35;
      color: #334155;
      list-style: square;
    }
    .node-sites li + li {
      margin-top: 2px;
    }
    .node-notes {
      margin: 0;
      padding-left: 16px;
      font-size: 8.5pt;
      line-height: 1.4;
      color: var(--muted);
    }
    .node-handle {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      font-size: 8pt;
      color: var(--accent);
    }
    .node-handle svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
    .axis-label {
      position: absolute;
      left: 16px;
      top: -26px;
      font-size: 8pt;
      color: var(--muted);
      letter-spacing: 0.4pt;
      text-transform: uppercase;
    }
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 4mm;
      margin-top: 4mm;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 2mm;
      font-size: 8.5pt;
      color: var(--muted);
    }
    .legend-swatch {
      width: 8mm;
      height: 3mm;
      border-radius: 2mm;
      background: var(--accent-strong);
    }
    .legend-item[data-type="chromatin"] .legend-swatch {
      background: linear-gradient(135deg, #22c55e, #4d7c0f);
    }
    .legend-item[data-type="rna"] .legend-swatch {
      background: linear-gradient(135deg, #fb7185, #b91c1c);
    }
    .legend-item[data-type="strand"] .legend-swatch {
      background: linear-gradient(90deg, #1d4ed8, #9333ea);
      position: relative;
    }
    .legend-item[data-type="strand"] .legend-swatch::after {
      content: '5′→3′';
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 6pt;
      color: #ffffff;
      font-weight: 600;
    }
    .legend-item[data-type="frame"] .legend-swatch {
      background: transparent;
      border: 2px dashed rgba(29, 78, 216, 0.7);
    }
    .visually-hidden {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .data-model {
      grid-column: span 2;
    }
    .data-model h2 {
      display: flex;
      align-items: baseline;
      gap: 3mm;
      flex-wrap: wrap;
    }
    .data-model h2 .subheading {
      font-size: 8pt;
      font-weight: 600;
      letter-spacing: 0.6pt;
      text-transform: uppercase;
      color: var(--muted);
      background: rgba(17, 24, 39, 0.06);
      padding: 1mm 3mm;
      border-radius: 999px;
    }
    .model-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 3mm;
      margin: 4mm 0;
    }
    .model-tabs button {
      border: 1px solid rgba(0,0,0,0.16);
      border-radius: 999px;
      padding: 2mm 4mm;
      background: #f8fafc;
      font-size: 8.5pt;
      letter-spacing: 0.2pt;
      cursor: pointer;
      transition: background 0.2s, border 0.2s, color 0.2s;
    }
    .model-tabs button.active {
      background: var(--accent);
      color: #ffffff;
      border-color: var(--accent);
    }
    .model-panel {
      background: #f8fafc;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 5px;
      padding: 5mm;
      display: grid;
      gap: 3mm;
    }
    .model-panel h3 {
      margin: 0;
      font-size: 12pt;
    }
    .model-panel ul {
      margin: 0;
      padding-left: 4mm;
      font-size: 9.5pt;
      line-height: 1.45;
    }
    .model-panel .callout {
      font-size: 8.5pt;
      color: var(--muted);
      background: rgba(29, 78, 216, 0.08);
      border-left: 2px solid var(--accent);
      padding: 2mm 3mm;
      border-radius: 3px;
    }
    .model-panel pre {
      margin: 0;
      font-size: 8pt;
      line-height: 1.45;
      background: rgba(15, 23, 42, 0.08);
      padding: 3mm;
      border-radius: 4px;
      overflow-x: auto;
    }
    .timeline {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 3mm;
      margin-top: 4mm;
    }
    .timeline button {
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 4px;
      padding: 4mm 3mm;
      background: #f8fafc;
      font-size: 9pt;
      cursor: pointer;
      text-align: left;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .timeline button.active {
      border-color: var(--accent);
      box-shadow: 0 4px 10px rgba(29,78,216,0.18);
      transform: translateY(-1mm);
    }
    .timeline button span {
      display: block;
    }
    .timeline button .title {
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 1mm;
    }
    .timeline button .detail {
      color: var(--muted);
      line-height: 1.4;
    }
    .step-panel {
      margin-top: 5mm;
      background: #f1f5f9;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 5px;
      padding: 5mm;
      min-height: 0;
    }
    .step-panel h3 {
      margin: 0 0 2mm;
      font-size: 12pt;
    }
    .step-panel ul {
      margin: 0;
      padding-left: 4mm;
    }
    .regulation-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 4mm;
      margin-top: 4mm;
    }
    .chip {
      background: rgba(0,0,0,0.04);
      border: 1px dashed rgba(0,0,0,0.2);
      border-radius: 5px;
      padding: 3mm;
      font-size: 8.5pt;
      line-height: 1.4;
    }
    footer {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      font-size: 8pt;
      color: var(--muted);
      gap: 6mm;
    }
    footer .attribution {
      display: flex;
      flex-direction: column;
      gap: 1mm;
      max-width: 140mm;
    }
    footer .controls {
      display: flex;
      gap: 4mm;
    }
    footer button {
      padding: 2.5mm 4.5mm;
      font-size: 8pt;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.2);
      background: #ffffff;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    footer button:hover {
      background: var(--accent);
      color: #ffffff;
    }
    .safe-mode *,
    .safe-mode *::before,
    .safe-mode *::after {
      animation: none !important;
      transition: none !important;
    }
    @page {
      size: A4 landscape;
      margin: 12mm;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.98);
      display: none;
      flex-direction: column;
      padding: 18mm;
      gap: 6mm;
    }
    .overlay.active {
      display: flex;
    }
    .overlay h2 {
      margin: 0;
      font-size: 16pt;
    }
    .overlay table {
      border-collapse: collapse;
      width: 100%;
      font-size: 9.5pt;
    }
    .overlay th, .overlay td {
      border: 1px solid rgba(0,0,0,0.2);
      padding: 2.5mm;
      text-align: left;
    }
    .close-overlay {
      align-self: flex-end;
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 2mm 5mm;
      border-radius: 4px;
      font-size: 9pt;
      cursor: pointer;
    }
    @media print {
      body {
        padding: 0;
        box-shadow: none;
        background: var(--bg);
      }
      .page {
        margin: 0;
        box-shadow: none;
        border: none;
        width: 297mm;
        height: 210mm;
        overflow: hidden;
      }
      .page::before {
        display: none;
      }
      footer button {
        display: none;
      }
      footer .attribution {
        font-size: 7.5pt;
      }
    }
  </style>
</head>
<body>
  <div class="page" role="document" aria-label="">
    <header>
      <div>
        <h1 id="header-title"></h1>
        <div class="pill" id="header-pill"></div>
      </div>
      <div class="meta-column">
        <div class="meta">
          <div id="meta-environment"></div>
          <div id="meta-context"></div>
          <div id="meta-focus"></div>
        </div>
        <div id="language-switch" class="language-switch"></div>
      </div>
    </header>
    <main>
      <section class="block flow-map" aria-labelledby="map-title">
        <h2 id="map-title"></h2>
        <div class="map-stage" role="application" aria-labelledby="map-title" aria-describedby="map-instructions">
          <div class="map-toolbar" role="group" aria-label="" id="map-toolbar">
            <button type="button" id="fit-to-view"></button>
            <button type="button" id="toggle-grid" class="active" aria-pressed="true"></button>
            <label for="snap-to-grid" class="snap-option">
            <input type="checkbox" id="snap-to-grid" checked />
            <span id="snap-label-text"></span>
          </label>
            <span aria-hidden="true">·</span>
            <button type="button" id="reset-overlap"></button>
            <label class="preset-control" id="preset-control" for="preset-select">
              <span id="preset-select-label"></span>
              <select id="preset-select"></select>
            </label>
            <label class="preset-control" id="org-control" for="org-select">
              <span id="org-select-label"></span>
              <select id="org-select"></select>
            </label>
          </div>
          <div class="map-canvas" id="map-canvas" tabindex="0" aria-label="" role="region">
            <div class="axis-label" aria-hidden="true" id="axis-label"></div>
            <div class="map-viewport" id="map-viewport">
              <svg class="edge-layer" id="edge-layer" viewBox="0 0 960 520" aria-hidden="true">
                <defs>
                  <marker id="arrow-flow" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--accent)"></path>
                  </marker>
                  <marker id="arrow-regulation" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#b91c1c"></path>
                  </marker>
                  <marker id="tee-regulation" viewBox="0 0 10 10" refX="2" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto">
                    <path d="M 2 0 L 2 10" stroke="#b91c1c" stroke-width="2"></path>
                  </marker>
                </defs>
              </svg>
              <div class="node-layer" id="node-layer" aria-live="polite"></div>
            </div>
          </div>
          <p class="visually-hidden" id="map-instructions"></p>
        </div>
        <div class="legend" aria-label="" id="legend">
          <div class="legend-item" data-type="polii"><span class="legend-swatch"></span><span id="legend-polii"></span></div>
          <div class="legend-item" data-type="chromatin"><span class="legend-swatch"></span><span id="legend-chromatin"></span></div>
          <div class="legend-item" data-type="rna"><span class="legend-swatch"></span><span id="legend-rna"></span></div>
          <div class="legend-item" data-type="strand"><span class="legend-swatch"></span><span id="legend-strand"></span></div>
          <div class="legend-item" data-type="frame"><span class="legend-swatch"></span><span id="legend-frame"></span></div>
        </div>
      </section>
      <section class="block" aria-labelledby="steps-title">
        <h2 id="steps-title"></h2>
        <div class="timeline" role="tablist" aria-label="" id="timeline"></div>
        <div class="step-panel" role="tabpanel" id="step-panel"></div>
        <div class="regulation-grid" aria-label="" id="regulation-grid"></div>
      </section>
      <section class="block data-model" aria-labelledby="model-title">
        <h2 id="model-title"><span id="model-title-main"></span> <span class="subheading" id="model-subheading"></span></h2>
        <div class="model-tabs" role="tablist" aria-label="" id="model-tabs">
          <button type="button" class="active" data-model="nodes" role="tab" aria-selected="true" id="tab-nodes"></button>
          <button type="button" data-model="edges" role="tab" aria-selected="false" id="tab-edges"></button>
          <button type="button" data-model="layout" role="tab" aria-selected="false" id="tab-layout"></button>
        </div>
        <div class="model-panel" role="tabpanel" id="model-panel"></div>
      </section>
    </main>
    <footer>
      <div class="attribution">
        <span id="footer-attribution"></span>
        <span id="footer-license"></span>
      </div>
      <div id="footer-scales"></div>
      <div class="controls" aria-label="" id="export-controls">
        <button type="button" id="export-svg"></button>
        <button type="button" id="export-png"></button>
        <button type="button" id="export-pdf"></button>
        <button type="button" id="export-json"></button>
        <button type="button" id="import-json"></button>
        <button type="button" id="reset-layout"></button>
        <button type="button" id="open-reference"></button>
      </div>
    </footer>
    <input type="file" id="import-file" accept="application/json" class="visually-hidden" aria-hidden="true" tabindex="-1" />
    <div class="overlay" id="reference-overlay" role="dialog" aria-modal="true" aria-labelledby="overlay-title">
      <button class="close-overlay" type="button" id="close-overlay"></button>
      <h2 id="overlay-title"></h2>
      <table>
        <thead>
          <tr>
            <th id="overlay-col-module"></th>
            <th id="overlay-col-composition"></th>
            <th id="overlay-col-function"></th>
            <th id="overlay-col-control"></th>
          </tr>
        </thead>
        <tbody id="overlay-body"></tbody>
      </table>
    </div>
  </div>
  <script>
    (function() {
      const STRINGS = {
  "ru": {
    "htmlLang": "ru",
    "page": {
      "title": "Инициация транскрипции Pol II — схема процесса",
      "ariaLabel": "A4 схема инициации транскрипции Pol II",
      "header": {
        "title": "Инициация транскрипции Pol II на +1 TSS",
        "pill": "Eukaryote · Advanced · Process View",
        "meta": {
          "environment": "Окружение: ядро эукариот",
          "context": "Контекст: промотор класса II, TATA+/Inr",
          "focus": "Фокус: формирование и запуск PIC"
        }
      }
    },
    "map": {
      "title": "Схема сборки и переходов",
      "toolbarAria": "Управление картой",
      "buttons": {
        "fit": "Подогнать вид",
        "grid": "Сетка",
        "snap": "Привязка к сетке",
        "resetOverlap": "Упорядочить слои"
      },
      "presets": {
        "presetLabel": "Пресет",
        "presetAria": "Выбор пресета диаграммы",
        "orgLabel": "Организм",
        "orgAria": "Выбор домена жизни",
        "options": {
          "tssMini": "TSS(+1) мини",
          "exonIntron": "Экзон-интрон карта",
          "operon": "Оперон",
          "library": "Расширенная библиотека"
        },
        "orgOptions": {
          "eukaryote": "Эукариоты",
          "prokaryote": "Прокариоты",
          "virus": "Вирусы"
        }
      },
      "canvasAria": "Рабочая зона",
      "axisLabel": "Геном (5′ → 3′)",
      "instructions": "Используйте мышь или стрелки для перемещения узлов. Колесо мыши с зажатой клавишей Ctrl управляет масштабом, простое прокручивание сдвигает поле. Перетаскивание удерживает элементы в пределах сетки и автоматически перерассчитывает связи.",
      "legendAria": "Условные обозначения",
      "legend": {
        "polii": "Полимераза II и общие факторы",
        "chromatin": "Хроматин и промоторная ДНК",
        "rna": "РНК, побег и пауза",
        "strand": "Направленность цепи (5′→3′ / 3′→5′)",
        "frame": "Окно координат (frame, сборка hg38)"
      }
    },
    "timeline": {
      "title": "Ключевые стадии и контрольные точки",
      "ariaLabel": "Этапы",
      "order": [
        "assembly",
        "isomerization",
        "initiation",
        "escape"
      ],
      "steps": {
        "assembly": {
          "buttonTitle": "1. Предсборка",
          "buttonDetail": "TFIID распознаёт TATA/Inr, активаторы стабилизируют Mediator.",
          "panelTitle": "1. Предсборка преинициаторного комплекса",
          "panelPoints": [
            "TBP изгибает ДНК на ~80°, позиционируя +1 сайт напротив активного центра.",
            "TFIID взаимодействует с коактиваторами (TAF1/2) и метками H3K4me3.",
            "TFIIA стабилизирует TBP–ДНК, TFIIB задаёт направление транскрипции.",
            "Mediator передаёт сигналы от энхансеров, подготавливая CDK8-модуль."
          ]
        },
        "isomerization": {
          "buttonTitle": "2. Изомеризация",
          "buttonDetail": "TFIIE рекрутирует TFIIH, открытие пузыря, загрузка шаблона.",
          "panelTitle": "2. Изомеризация и открытие промотора",
          "panelPoints": [
            "TFIIE координирует рекрутирование TFIIH и подготавливает хеликазный цикл XPB.",
            "ATP-зависимое расплетание формирует открытый пузырь (-9/+2) вокруг TSS.",
            "Шаблонная цепь позиционируется в канал Pol II при участии TFIIB-B reader.",
            "CTD Ser5-фосфориляция инициирует рекрутирование комплекса кэпирования."
          ]
        },
        "initiation": {
          "buttonTitle": "3. Старт синтеза",
          "buttonDetail": "Abortive циклы < 10 нт, CTD Ser5-P запускает кэпирование.",
          "panelTitle": "3. Старт синтеза и ранние транскрипты",
          "panelPoints": [
            "Pol II инициирует синтез с +1 аденина/цитозина, формируя короткие РНК.",
            "Abortive циклы (<10 нт) очищают канал; σ-подобная петля TFIIB ориентирует выход.",
            "NELF/DSIF начинают связываться, подготавливая платформу паузы.",
            "Ser5-P CTD рекрутирует TFIIH CAK и фактор кэпирования CE/HCE."
          ]
        },
        "escape": {
          "buttonTitle": "4. Побег",
          "buttonDetail": "TFIIB/TFIIE освобождаются, NELF/DSIF контролируют удлинение.",
          "panelTitle": "4. Промоторный побег и фиксация паузы",
          "panelPoints": [
            "Pol II проходит +10/+12, выбрасывая TFIIB/TFIIE и ослабляя связи Mediator.",
            "TFIIH остаётся до формирования устойчивого гибрида ДНК–РНК (~8–9 нт).",
            "DSIF стабилизирует удлинение, NELF удерживает полимеразу на +20/+60.",
            "P-TEFb (CDK9/CycT) фосфорилирует NELF/DSIF и CTD Ser2, переводя в элонгацию."
          ]
        }
      }
    },
    "regulation": {
      "ariaLabel": "Регуляция",
      "chips": [
        "Позитивная регуляция: ремоделлеры (SWI/SNF), H3K27ac усиливают доступность промотора.",
        "Негативная регуляция: комплексы NURD, метилирование ДНК ограничивают загрузку TFIID.",
        "Сигнальные входы: MAPK/CDK активируют фосфориляцию CTD через Mediator/CDK7.",
        "Контроль качества: TFIIS помогает Pol II преодолеть остановку на слабом стартовом сигнале."
      ]
    },
    "model": {
      "title": "Модель данных v1.1",
      "subheading": "JSON schema • визуальная грамматика A4",
      "ariaLabel": "Компоненты модели",
      "tabs": {
        "nodes": "Узлы",
        "edges": "Рёбра",
        "layout": "Вёрстка"
      },
      "content": {
        "nodes": {
          "title": "Структура узла {id, x, y, w, h, label, type, data}",
          "items": [
            "Поле <strong>type</strong> принимает роли: DNA, RNA, Protein, Promoter, Enhancer, TSS, TF, Mediator и др.",
            "Геометрия задаётся в миллиметрах A4: координаты (x, y) и размеры (w, h) относительно зоны сетки.",
            "Уровень advanced добавляет <code>frame</code>, <code>coordinates</code>, <code>strand</code> и <code>recognitionSites</code> для описания геномного окна, ориентации и сайтов узнавания.",
            "Доп. данные (<code>data</code>) включают метки 5′→3′, модификации (H3K4me3) и состояние комплекса.",
            "Слои доступны через <code>layer</code> и <code>zIndex</code> — используют стандарт «process» для Pol II."
          ],
          "callout": "Рекомендация: хранить идентификаторы в формате <code>promoter:tata</code>, <code>protein:tf2h</code> для совместимости с экспортом.",
          "snippet": "{\n  \"id\": \"node:tfiih\",\n  \"type\": \"TFIIH\",\n  \"x\": 420,\n  \"y\": 120,\n  \"w\": 90,\n  \"h\": 46,\n  \"label\": \"TFIIH\",\n  \"layer\": \"factors\",\n  \"data\": {\"helicase\": \"XPB/XPD\", \"phosphorylation\": \"CTD Ser5\"}\n}"
        },
        "edges": {
          "title": "Определение ребра {id, from, to, kind, label, router, markers}",
          "items": [
            "Тип <strong>kind</strong>: flow (transcribes, recruits, phosphorylates) или regulation (activates, represses, pauses).",
            "Поле <code>router</code> описывает геометрию: orthogonal для PIC, bezier для энхансерных петель, straight для коротких связей.",
            "Маркеры стрелок (<code>markers</code>) задают форму/цвет; используем словарь arrow:polII, arrow:regulation, tee:repress.",
            "Расширенные рёбра содержат <code>frame</code>, <code>coordinates</code>, <code>strand</code> и <code>recognitionSites</code> для фиксации контактов по геному и времени.",
            "Атрибут <code>timeline</code> хранит контрольные точки (например, {start: \"+1\", end: \"+60\"}) для синхронизации с осью времени."
          ],
          "callout": "Связывайте рёбра с узлами по UUID — это облегчает слияние схем от разных авторов.",
          "snippet": "{\n  \"id\": \"edge:tf2h-open\",\n  \"from\": \"node:tfiih\",\n  \"to\": \"node:openbubble\",\n  \"kind\": \"flow\",\n  \"label\": \"открывает\",\n  \"router\": \"orthogonal\",\n  \"markers\": {\"start\": null, \"end\": \"arrow:polII\"}\n}"
        },
        "layout": {
          "title": "Правила вёрстки A4 landscape (print theme)",
          "items": [
            "Поле <code>page</code>: {width: 297, height: 210, margin: 12} — размеры в мм с учётом сетки 28 мм.",
            "Слои (<code>layers</code>): background, chromatin, factors, rna, annotations — управляют порядком рисования.",
            "Стили (<code>styles</code>) фиксируют цвета ролей: Pol II #1d4ed8, chromatin #4d7c0f, RNA #b91c1c.",
            "Гайды (<code>guides</code>) описывают линейки осей: time (left→right), assembly depth (top→bottom), regulation captions."
          ],
          "callout": "Экспорт в SVG/PNG использует эти параметры — держите масштаб 1 мм = 3.78 px для консистентности.",
          "snippet": "{\n  \"layout\": {\n    \"page\": {\"width\": 297, \"height\": 210, \"margin\": 12},\n    \"grid\": {\"size\": 28, \"visible\": true},\n    \"theme\": \"print\"\n  }\n}"
        }
      }
    },
    "footer": {
      "attribution": "© 2025 eukaryote lab · Данные: литература по Pol II (Cold Spring Harbor, eLife, 2021–2024)",
      "license": "Лицензия: CC BY 4.0 · указание авторства обязательно при публикации",
      "scales": "Шкалы: время (слева направо) · структура комплекса (по высоте) · регуляторы (подписи)",
      "controlsAria": "Экспорт",
      "buttons": {
        "exportSvg": "Экспорт SVG",
        "exportPng": "Экспорт PNG (300 DPI)",
        "exportPdf": "PDF / Печать",
        "exportJson": "Экспорт JSON",
        "importJson": "Импорт JSON",
        "resetLayout": "Сброс",
        "openReference": "Таблица комплексов"
      }
    },
    "overlay": {
      "close": "Закрыть",
      "title": "Факторный состав и функции",
      "columns": {
        "module": "Модуль",
        "composition": "Состав",
        "function": "Функция в инициации",
        "control": "Контроль"
      },
      "rows": [
        {
          "module": "TFIID ядро",
          "composition": "TBP + TAF1/2/4/6",
          "function": "Распознаёт TATA/Inr, контактирует с DPE/MTE",
          "control": "Ацетил-H3/4, TAF фосфориляция"
        },
        {
          "module": "TFIIB мост",
          "composition": "Rrn7-подобные домены",
          "function": "Организация +1 канала, стабилизация ранних транскриптов",
          "control": "Фосфориляция Ser65 уменьшает удержание"
        },
        {
          "module": "TFIIE/F",
          "composition": "α/β субъединицы",
          "function": "Рекрутирование TFIIH, поддержка открытого пузыря",
          "control": "Убиквитинирование регулирует деградацию"
        },
        {
          "module": "TFIIH",
          "composition": "XPB, XPD, CAK (CDK7/CycH/MAT1)",
          "function": "Хеликазная активность, CTD Ser5-фосфорилирование",
          "control": "Сигналы стресс-ответа через ATR/ATM"
        },
        {
          "module": "Mediator",
          "composition": "Head/Middle/Tail + CDK8",
          "function": "Платформа для факторов, интеграция сигналов энхансеров",
          "control": "CDK8/CycC переключают режим паузы"
        },
        {
          "module": "Pausing-модуль",
          "composition": "DSIF (Spt4/5), NELF A–E",
          "function": "Стабилизация Pol II на +20–+60, подготовка к паузе",
          "control": "P-TEFb фосфорилирует для освобождения"
        }
      ]
    },
    "presets": {
      "tssMini": {
        "prokaryote": {
          "nodes": {
            "promoter": {
              "label": "−35/−10 промотор",
              "type": "Промотор σ70",
              "notes": [
                "Консервативные −35 TTGACA и −10 TATAAT мотивы",
                "UP-элементы усиливают связывание RNAP"
              ]
            },
            "holoenzyme": {
              "label": "RNAP σ70 холоэнзим",
              "type": "Полимераза",
              "notes": [
                "β/β′ формируют канал; σ распознаёт промотор",
                "α-CTD взаимодействует с UP-элементами"
              ]
            },
            "openComplex": {
              "label": "Открытый комплекс",
              "type": "Инициирующий комплекс",
              "notes": [
                "DNA расплетается на ~13 п. н.",
                "Начальные транскрипты удерживаются петлёй σ3.2"
              ]
            },
            "clearance": {
              "label": "Побег и σ-фактор",
              "type": "Ранняя транскрипция",
              "notes": [
                "σ освобождается при +10/+12",
                "GreA/B предотвращают остановки"
              ]
            }
          },
          "edges": {
            "promoterToRnap": "Рекрутирует RNAP",
            "rnapToOpen": "Изомеризация",
            "openToClearance": "Промоторный побег"
          }
        },
        "virus": {
          "nodes": {
            "hostChromatin": {
              "label": "Хостовый промотор",
              "type": "ДНК/хроматин",
              "notes": [
                "Вирусные белки меняют ацетиляцию и метилирование",
                "Интеграция создаёт LTR или инвертированные повторы"
              ]
            },
            "viralFactors": {
              "label": "Вирусные факторы",
              "type": "Регуляция",
              "notes": [
                "Tat/ICP4/VP16 рекрутируют коактиваторы",
                "Перенаправляют Mediator и P-TEFb"
              ]
            },
            "hostPol": {
              "label": "Pol II/Pol III перенацелены",
              "type": "Полимераза хозяина",
              "notes": [
                "CDK7/CDK9 активируются вирусными сигналами",
                "Транскрипционные фабрики смещаются к вирусу"
              ]
            },
            "release": {
              "label": "Побег и переключение фаз",
              "type": "Экспрессия вируса",
              "notes": [
                "Ранние транскрипты запускают репликацию",
                "Поздние гены включаются по таймеру"
              ]
            }
          },
          "edges": {
            "chromatinToFactors": "Перестраивает хроматин",
            "factorsToPol": "Загружает полимеразу",
            "polToEscape": "Переход к вирусной РНК"
          }
        }
      },
      "exonIntron": {
        "eukaryote": {
          "nodes": {
            "promoter": {
              "label": "Промотор и 5′ UTR",
              "type": "Промотор",
              "notes": [
                "CpG-островки и гистоновые метки",
                "Ко-транскрипционное кэпирование"
              ]
            },
            "exon1": {
              "label": "Экзон 1",
              "type": "Экзон",
              "notes": [
                "Содержит стартовый кодон и ESE",
                "SR-белки стабилизируют участок"
              ]
            },
            "intron": {
              "label": "Интрон",
              "type": "Интрон",
              "notes": [
                "5′ GU … AG 3′ и бранч-точка A",
                "RNP формирует шпильку"
              ]
            },
            "exon2": {
              "label": "Экзон 2",
              "type": "Экзон",
              "notes": [
                "Содержит ESE/ISE для выбора",
                "Поддерживает кадр считывания"
              ]
            },
            "splicing": {
              "label": "Сплайсосома",
              "type": "Комплекс",
              "notes": [
                "U1/U2/U4/U5/U6 проводят катализ",
                "PRP8 и ATPазы обеспечивают динамику"
              ]
            }
          },
          "edges": {
            "promoterToExon1": "Транскрибирует",
            "exon1ToIntron": "Формирует пре-мРНК",
            "intronToExon2": "Лигирование экзонов",
            "splicingControl": "Катализирует сплайсинг"
          }
        },
        "prokaryote": {
          "nodes": {
            "leader": {
              "label": "Лидерная последовательность",
              "type": "5′ UTR",
              "notes": [
                "Shine-Dalgarno и RBS",
                "Содержит элементы аттенюации"
              ]
            },
            "coding": {
              "label": "Кодирующий регион",
              "type": "ORF",
              "notes": [
                "Часто полицестронный",
                "Перекрывающиеся старт и стоп"
              ]
            },
            "terminator": {
              "label": "Терминатор",
              "type": "ρ-независимый/зависимый",
              "notes": [
                "ГЦ-шпилька + поли-U или Rut-сайт",
                "Определяет скорость транскрипции"
              ]
            },
            "processing": {
              "label": "Обработка РНК",
              "type": "Рибонуклеаза",
              "notes": [
                "RNase E/III обрезают полицистрон",
                "Riboswitch управляет стабильностью"
              ]
            }
          },
          "edges": {
            "leaderToCoding": "Инициирует трансляцию",
            "codingToTerminator": "Синтезирует транскрипт",
            "terminatorToProcessing": "Передаёт на обработку"
          }
        },
        "virus": {
          "nodes": {
            "donor": {
              "label": "Донорный сайт",
              "type": "5′ сплайс",
              "notes": [
                "Слабые консенсусы",
                "Зависит от SR/hnRNP белков"
              ]
            },
            "intronic": {
              "label": "Вирусные интроны",
              "type": "Интрон",
              "notes": [
                "Регуляторные элементы ESS/EIS",
                "Контроль экспорта и фаз"
              ]
            },
            "acceptor": {
              "label": "Акцепторный сайт",
              "type": "3′ сплайс",
              "notes": [
                "AG + полипиримидиновый трек",
                "Формирует множественные белки"
              ]
            },
            "export": {
              "label": "Экспорт и переключение",
              "type": "Регуляция",
              "notes": [
                "Rev/Crm1 или M-экспортные комплексы",
                "Делит экспрессию на раннюю и позднюю"
              ]
            }
          },
          "edges": {
            "donorToIntronic": "Формирует интрон",
            "intronicToAcceptor": "Сплайсинг",
            "acceptorToExport": "Экспортирует мРНК"
          }
        }
      },
      "operon": {
        "eukaryote": {
          "nodes": {
            "enhancer": {
              "label": "Enhancer/активаторы",
              "type": "Регуляция",
              "notes": [
                "mtDNA/пластидные факторы",
                "Петля к промотору"
              ]
            },
            "promoter": {
              "label": "Бикадровый промотор",
              "type": "Промотор",
              "notes": [
                "POLRMT/TFB2M и TFBM",
                "Формирует лидерную мРНК"
              ]
            },
            "polycistronic": {
              "label": "Полицестронная транскрипт",
              "type": "мРНК",
              "notes": [
                "Общие 5′/3′ UTR",
                "Резка эндорибонуклеазами"
              ]
            },
            "processing": {
              "label": "Обработка и редактирование",
              "type": "RNP-комплекс",
              "notes": [
                "RNase P/Z, полиаденилирование",
                "Редактирование и сплайсинг tRNA"
              ]
            }
          },
          "edges": {
            "enhancerToPromoter": "Активирует",
            "promoterToPoly": "Транскрибирует кластер",
            "polyToProcessing": "Передаёт на обработку"
          }
        },
        "prokaryote": {
          "nodes": {
            "operator": {
              "label": "Оператор",
              "type": "DNA оператор",
              "notes": [
                "Связывает репрессоры/активаторы",
                "Пример: lacO, trpO"
              ]
            },
            "rnap": {
              "label": "RNAP + σ",
              "type": "Полимераза",
              "notes": [
                "Инициирует на промоторе",
                "Чувствителен к ко-активаторам"
              ]
            },
            "genes": {
              "label": "Структурные гены",
              "type": "Полицестронная мРНК",
              "notes": [
                "lacZYA/trpEDCBA",
                "Связанные трансляцией"
              ]
            },
            "attenuation": {
              "label": "Аттенюация/регуляция",
              "type": "Регуляция",
              "notes": [
                "Leader-пептид и остановки",
                "Metabolite riboswitch"
              ]
            }
          },
          "edges": {
            "operatorToRnap": "Регулирует связывание",
            "rnapToGenes": "Синтезирует мРНК",
            "genesToAttenuation": "Лидер-транскрипт",
            "attenuationToRnap": "Модулирует продолжение"
          }
        },
        "virus": {
          "nodes": {
            "ltr": {
              "label": "LTR промотор",
              "type": "Промотор",
              "notes": [
                "U3/R/U5 модули",
                "Требует Tat/интеграцию"
              ]
            },
            "polymerase": {
              "label": "Вирусная полимераза",
              "type": "Фермент",
              "notes": [
                "RT или хостовый фактор",
                "Инициирует транскрипцию"
              ]
            },
            "polyprotein": {
              "label": "Полипротеин мРНК",
              "type": "мРНК",
              "notes": [
                "Gag-Pol/NS транскрипты",
                "Фреймшифт регулирует стехиометрию"
              ]
            },
            "frameshift": {
              "label": "Frameshift/редактирование",
              "type": "Регуляция",
              "notes": [
                "−1 frameshift или RNA-editing",
                "Контролирует поздние белки"
              ]
            }
          },
          "edges": {
            "ltrToPolymerase": "Запускает транскрипцию",
            "polymeraseToPolyprotein": "Синтезирует мРНК",
            "polyproteinToFrameshift": "Переключает считывание"
          }
        }
      },
      "library": {
        "eukaryote": {
          "nodes": {
            "factors": {
              "label": "Библиотека факторов",
              "type": "PIC ядро",
              "notes": [
                "TFIID/TFIIA/TFIIB",
                "Подготовка TSS"
              ]
            },
            "coactivators": {
              "label": "Коактиваторы/хроматин",
              "type": "Регуляция",
              "notes": [
                "Mediator, SAGA, SWI/SNF",
                "Метки H3K4me3/H3K27ac"
              ]
            },
            "pause": {
              "label": "Пауза и контроль",
              "type": "RNA пауза",
              "notes": [
                "DSIF/NELF",
                "P-TEFb запускает элонгацию"
              ]
            },
            "elongation": {
              "label": "Элонгация/процессивность",
              "type": "Элонгация",
              "notes": [
                "FACT, PAF1C, writer m6A",
                "Связь с ко-транскрипционным процессингом"
              ]
            }
          },
          "edges": {
            "factorsToCoactivators": "Привлекает модули",
            "coactivatorsToPause": "Настраивает платформу",
            "pauseToElongation": "Запускает элонгацию"
          }
        },
        "prokaryote": {
          "nodes": {
            "sigma": {
              "label": "σ-факторы",
              "type": "Регуляция",
              "notes": [
                "σ70, σ32, σ54",
                "Определяют спектр промоторов"
              ]
            },
            "remodeling": {
              "label": "Нуклеоид/ремоделлеры",
              "type": "ДНК-организация",
              "notes": [
                "Fis, H-NS, IHF",
                "Контролируют суперскручивание"
              ]
            },
            "termination": {
              "label": "Терминация",
              "type": "Процесс",
              "notes": [
                "ρ, NusA/B",
                "Coupling с трансляцией"
              ]
            },
            "stress": {
              "label": "Стрессовые сигналы",
              "type": "Регуляция",
              "notes": [
                "ppGpp/DksA, CsrA",
                "Переключают σ-факторы"
              ]
            }
          },
          "edges": {
            "sigmaToRemodeling": "Направляет открытие",
            "remodelingToTermination": "Формирует окно транскрипции",
            "stressToTermination": "Модулирует завершение"
          }
        },
        "virus": {
          "nodes": {
            "entry": {
              "label": "Вход/шаблон",
              "type": "Геном",
              "notes": [
                "ssRNA или dsDNA",
                "Капсид/нуклеосома раскрывается"
              ]
            },
            "hostFactors": {
              "label": "Хостовые факторы",
              "type": "Ко-факторы",
              "notes": [
                "TFIID, P-TEFb, HAT",
                "Репрограммирование клеточного цикла"
              ]
            },
            "polymerase": {
              "label": "Вирусная полимераза",
              "type": "Фермент",
              "notes": [
                "RdRp или DNA-полимераза",
                "Зависит от праймирования"
              ]
            },
            "switching": {
              "label": "Переключение программ",
              "type": "Регуляция",
              "notes": [
                "Литический/латентный выбор",
                "Антисмысловые РНК"
              ]
            }
          },
          "edges": {
            "entryToHost": "Рекрутирует факторы",
            "hostToPolymerase": "Активирует синтез",
            "polymeraseToSwitching": "Управляет стадиями"
          }
        }
      }
    },

    "nodes": {
      "chromatin": {
        "label": "Хроматин ремоделирован",
        "type": "Chromatin",
        "notes": [
          "SWI/SNF и HAT открывают TATA-бокс и снимают нуклеосомы.",
          "H3K4me3 / ацетил-H3 повышают аффинность TFIID."
        ]
      },
      "mediator": {
        "label": "Mediator + общие факторы",
        "type": "Mediator complex",
        "notes": [
          "TFIID-TBP, TFIIA и TFIIB фиксируют +1 позицию.",
          "Tail/Head модули интегрируют сигналы энхансеров."
        ]
      },
      "polii": {
        "label": "Pol II–TFIIF ядро",
        "type": "Pol II core",
        "notes": [
          "TFIIE координирует загрузку TFIIH; XPB раскрывает пузырь (-9/+2).",
          "CDK7 (CAK) фосфорилирует CTD Ser5, рекрутирует кэпирующий комплекс."
        ]
      },
      "escape": {
        "label": "Промоторный побег и пауза",
        "type": "RNA transition",
        "notes": [
          "Гибрид ДНК–РНК стабилизируется (~8–9 нт), Mediator отходит.",
          "DSIF/NELF удерживают Pol II на +20/+60 до активации P-TEFb."
        ]
      },
      "enhancer": {
        "label": "Энхансерные петли",
        "type": "Enhancer",
        "notes": [
          "Активаторы и Mediator Tail формируют петлю, вовлекая Cohesin.",
          "Chromatin reader-комплексы удерживают гистоновые метки."
        ]
      },
      "ptefb": {
        "label": "P-TEFb / сигналы освобождения",
        "type": "Regulation",
        "notes": [
          "CDK9/CycT активируются через BRD4/SEC и сигналы стресс-ответа.",
          "Фосфорилируют DSIF, NELF и CTD Ser2, переводя в продуктивную элонгацию."
        ]
      }
    },
    "edges": {
      "chromatinMediator": "рекрутирует",
      "mediatorPolii": "собирает PIC",
      "poliiEscape": "инициирует транскрипцию",
      "enhancerMediator": "активирует",
      "ptefbEscape": "освобождает паузу"
    },
    "messages": {
      "importError": "Не удалось импортировать JSON: ",
      "missingNodes": "Структура JSON не содержит массива \"nodes\"",
      "stateReset": "Сброс сохранённого состояния из-за ошибки",
      "saveError": "Не удалось сохранить состояние",
      "autoCorrectionPrefix": "Автоисправлено:",
      "validationApplied": "Исправлены поля: {fields}",
      "pngFallback": "PNG не создан — сохранён резервный SVG",
      "safeMode": "Безопасный режим: анимации отключены",
      "dragHandle": "Переместить",
      "nodeAria": "{label}. {type}. Перемещение стрелками, Shift — шаг x2."
    }
  },
  "en": {
    "htmlLang": "en",
    "page": {
      "title": "Pol II transcription initiation — process map",
      "ariaLabel": "A4 Pol II transcription initiation diagram",
      "header": {
        "title": "Pol II transcription initiation at the +1 TSS",
        "pill": "Eukaryote · Advanced · Process View",
        "meta": {
          "environment": "Environment: eukaryotic nucleus",
          "context": "Context: class II promoter, TATA+/Inr",
          "focus": "Focus: assembling and firing the PIC"
        }
      }
    },
    "map": {
      "title": "Assembly and transition map",
      "toolbarAria": "Map controls",
      "buttons": {
        "fit": "Fit to view",
        "grid": "Grid",
        "snap": "Snap to grid",
        "resetOverlap": "Arrange layers"
      },
      "presets": {
        "presetLabel": "Preset",
        "presetAria": "Choose diagram preset",
        "orgLabel": "Organism",
        "orgAria": "Select domain",
        "options": {
          "tssMini": "TSS(+1) mini",
          "exonIntron": "Exon–intron map",
          "operon": "Operon",
          "library": "Extended library"
        },
        "orgOptions": {
          "eukaryote": "Eukaryote",
          "prokaryote": "Prokaryote",
          "virus": "Virus"
        }
      },
      "canvasAria": "Workspace",
      "axisLabel": "Genome (5′ → 3′)",
      "instructions": "Use the mouse or arrow keys to move nodes. Scroll with Ctrl adjusts zoom; plain scrolling pans the field. Dragging keeps elements snapped to the grid and recomputes connections.",
      "legendAria": "Legend",
      "legend": {
        "polii": "Pol II and general factors",
        "chromatin": "Chromatin and promoter DNA",
        "rna": "RNA, escape and pause",
        "strand": "Strand orientation (5′→3′ / 3′→5′)",
        "frame": "Coordinate frame / genomic window"
      }
    },
    "timeline": {
      "title": "Key stages and checkpoints",
      "ariaLabel": "Stages",
      "order": [
        "assembly",
        "isomerization",
        "initiation",
        "escape"
      ],
      "steps": {
        "assembly": {
          "buttonTitle": "1. Pre-assembly",
          "buttonDetail": "TFIID recognizes TATA/Inr, activators stabilize Mediator.",
          "panelTitle": "1. Pre-assembly of the pre-initiation complex",
          "panelPoints": [
            "TBP bends DNA by ~80°, positioning the +1 site at the active center.",
            "TFIID engages co-activators (TAF1/2) and H3K4me3 marks.",
            "TFIIA stabilizes TBP–DNA, TFIIB sets transcription direction.",
            "Mediator relays enhancer cues and primes the CDK8 module."
          ]
        },
        "isomerization": {
          "buttonTitle": "2. Isomerization",
          "buttonDetail": "TFIIE recruits TFIIH, bubble opening, template loading.",
          "panelTitle": "2. Promoter isomerization and opening",
          "panelPoints": [
            "TFIIE coordinates TFIIH recruitment and primes the XPB helicase cycle.",
            "ATP-driven unwinding creates an open bubble (-9/+2) around the TSS.",
            "The template strand is guided into Pol II by the TFIIB B-reader.",
            "CTD Ser5 phosphorylation triggers capping complex recruitment."
          ]
        },
        "initiation": {
          "buttonTitle": "3. Initiation",
          "buttonDetail": "Abortive cycles < 10 nt, CTD Ser5-P triggers capping.",
          "panelTitle": "3. Initiation and short transcripts",
          "panelPoints": [
            "Pol II initiates at +1 A/C, producing short RNAs.",
            "Abortive cycles (<10 nt) clear the channel; the TFIIB B-finger directs RNA exit.",
            "NELF/DSIF begin to engage, preparing the pause platform.",
            "Ser5-phosphorylated CTD recruits TFIIH CAK and the capping enzyme."
          ]
        },
        "escape": {
          "buttonTitle": "4. Promoter escape",
          "buttonDetail": "TFIIB/TFIIE release, NELF/DSIF tune elongation.",
          "panelTitle": "4. Promoter escape and pause establishment",
          "panelPoints": [
            "Pol II passes +10/+12, releasing TFIIB/TFIIE and loosening Mediator contacts.",
            "TFIIH remains until a stable DNA–RNA hybrid (~8–9 nt) forms.",
            "DSIF stabilizes elongation; NELF holds Pol II at +20/+60.",
            "P-TEFb (CDK9/CycT) phosphorylates NELF/DSIF and CTD Ser2 to enter productive elongation."
          ]
        }
      }
    },
    "regulation": {
      "ariaLabel": "Regulation",
      "chips": [
        "Positive control: remodelers (SWI/SNF) and H3K27ac increase promoter accessibility.",
        "Negative control: NuRD complexes and DNA methylation limit TFIID loading.",
        "Signaling inputs: MAPK/CDK routes activate CTD phosphorylation via Mediator/CDK7.",
        "Quality control: TFIIS helps Pol II bypass weak-start stalls."
      ]
    },
    "model": {
      "title": "Data model v1.1",
      "subheading": "JSON schema • A4 visual grammar",
      "ariaLabel": "Model components",
      "tabs": {
        "nodes": "Nodes",
        "edges": "Edges",
        "layout": "Layout"
      },
      "content": {
        "nodes": {
          "title": "Node structure {id, x, y, w, h, label, type, data}",
          "items": [
            "Field <strong>type</strong> covers roles: DNA, RNA, Protein, Promoter, Enhancer, TSS, TF, Mediator, etc.",
            "Geometry is in A4 millimetres: coordinates (x, y) and size (w, h) within the grid area.",
            "Advanced level introduces <code>frame</code>, <code>coordinates</code>, <code>strand</code> and <code>recognitionSites</code> for genomic windows, orientation and motif metadata.",
            "Extra <code>data</code> stores 5′→3′ marks, modifications (H3K4me3) and complex states.",
            "<code>layer</code> and <code>zIndex</code> follow the Pol II “process” standard."
          ],
          "callout": "Recommendation: keep identifiers like <code>promoter:tata</code>, <code>protein:tf2h</code> for export compatibility.",
          "snippet": "{\n  \"id\": \"node:tfiih\",\n  \"type\": \"TFIIH\",\n  \"x\": 420,\n  \"y\": 120,\n  \"w\": 90,\n  \"h\": 46,\n  \"label\": \"TFIIH\",\n  \"layer\": \"factors\",\n  \"data\": {\"helicase\": \"XPB/XPD\", \"phosphorylation\": \"CTD Ser5\"}\n}"
        },
        "edges": {
          "title": "Edge definition {id, from, to, kind, label, router, markers}",
          "items": [
            "<strong>kind</strong>: flow (transcribes, recruits, phosphorylates) or regulation (activates, represses, pauses).",
            "<code>router</code> shapes geometry: orthogonal for the PIC, bezier for enhancer loops, straight for short links.",
            "Arrow markers (<code>markers</code>) pick shape/colour; use the catalog arrow:polII, arrow:regulation, tee:repress.",
            "Advanced edges track <code>frame</code>, <code>coordinates</code>, <code>strand</code> and <code>recognitionSites</code> for genomic spans and contact hotspots.",
            "<code>timeline</code> marks checkpoints (e.g. {start: \"+1\", end: \"+60\"}) to align with the time axis."
          ],
          "callout": "Bind edges to nodes via UUIDs — it simplifies merging diagrams from different authors.",
          "snippet": "{\n  \"id\": \"edge:tf2h-open\",\n  \"from\": \"node:tfiih\",\n  \"to\": \"node:openbubble\",\n  \"kind\": \"flow\",\n  \"label\": \"opens\",\n  \"router\": \"orthogonal\",\n  \"markers\": {\"start\": null, \"end\": \"arrow:polII\"}\n}"
        },
        "layout": {
          "title": "A4 landscape layout rules (print theme)",
          "items": [
            "<code>page</code>: {width: 297, height: 210, margin: 12} — millimetres with a 28 mm grid.",
            "Layers (<code>layers</code>): background, chromatin, factors, rna, annotations — control draw order.",
            "Styles (<code>styles</code>) fix role colours: Pol II #1d4ed8, chromatin #4d7c0f, RNA #b91c1c.",
            "Guides (<code>guides</code>) define axes: time (left→right), assembly depth (top→bottom), regulation captions."
          ],
          "callout": "SVG/PNG export relies on these parameters — keep 1 mm = 3.78 px for consistency.",
          "snippet": "{\n  \"layout\": {\n    \"page\": {\"width\": 297, \"height\": 210, \"margin\": 12},\n    \"grid\": {\"size\": 28, \"visible\": true},\n    \"theme\": \"print\"\n  }\n}"
        }
      }
    },
    "footer": {
      "attribution": "© 2025 eukaryote lab · Sources: Pol II literature (Cold Spring Harbor, eLife, 2021–2024)",
      "license": "License: CC BY 4.0 · attribution required for reuse",
      "scales": "Scales: time (left to right) · complex structure (vertical) · regulators (captions)",
      "controlsAria": "Export",
      "buttons": {
        "exportSvg": "Export SVG",
        "exportPng": "Export PNG (300 DPI)",
        "exportPdf": "PDF / Print",
        "exportJson": "Export JSON",
        "importJson": "Import JSON",
        "resetLayout": "Reset",
        "openReference": "Complex table"
      }
    },
    "overlay": {
      "close": "Close",
      "title": "Factor composition and functions",
      "columns": {
        "module": "Module",
        "composition": "Composition",
        "function": "Role in initiation",
        "control": "Control"
      },
      "rows": [
        {
          "module": "TFIID core",
          "composition": "TBP + TAF1/2/4/6",
          "function": "Recognizes TATA/Inr, contacts DPE/MTE",
          "control": "H3/H4 acetylation, TAF phosphorylation"
        },
        {
          "module": "TFIIB bridge",
          "composition": "Rrn7-like domains",
          "function": "Organizes the +1 channel, stabilizes early transcripts",
          "control": "Ser65 phosphorylation lowers retention"
        },
        {
          "module": "TFIIE/F",
          "composition": "α/β subunits",
          "function": "Recruit TFIIH, support the open bubble",
          "control": "Ubiquitination regulates turnover"
        },
        {
          "module": "TFIIH",
          "composition": "XPB, XPD, CAK (CDK7/CycH/MAT1)",
          "function": "Helicase activity, CTD Ser5 phosphorylation",
          "control": "Stress-response signals via ATR/ATM"
        },
        {
          "module": "Mediator",
          "composition": "Head/Middle/Tail + CDK8",
          "function": "Factor platform integrating enhancer signals",
          "control": "CDK8/CycC toggles the pause module"
        },
        {
          "module": "Pausing module",
          "composition": "DSIF (Spt4/5), NELF A–E",
          "function": "Stabilizes Pol II at +20–+60, sets up pausing",
          "control": "P-TEFb phosphorylation triggers release"
        }
      ]
    },
    "presets": {
      "tssMini": {
        "prokaryote": {
          "nodes": {
            "promoter": {
              "label": "−35/−10 promoter",
              "type": "σ70 promoter",
              "notes": [
                "Conserved −35 TTGACA and −10 TATAAT elements",
                "UP-elements raise RNAP affinity"
              ]
            },
            "holoenzyme": {
              "label": "RNAP σ70 holoenzyme",
              "type": "Polymerase",
              "notes": [
                "β/β′ form the channel; σ recognizes motifs",
                "α-CTD contacts UP-elements"
              ]
            },
            "openComplex": {
              "label": "Open complex",
              "type": "Initiation complex",
              "notes": [
                "DNA unwound across ~13 bp",
                "Initial transcripts stabilized by σ3.2"
              ]
            },
            "clearance": {
              "label": "Promoter clearance",
              "type": "Early transcription",
              "notes": [
                "σ releases near +10/+12",
                "GreA/B suppress backtracking"
              ]
            }
          },
          "edges": {
            "promoterToRnap": "Recruit RNAP",
            "rnapToOpen": "Isomerize",
            "openToClearance": "Promoter escape"
          }
        },
        "virus": {
          "nodes": {
            "hostChromatin": {
              "label": "Host promoter",
              "type": "DNA/chromatin",
              "notes": [
                "Viral proteins remodel acetylation and methylation",
                "Integration can create LTR or inverted repeats"
              ]
            },
            "viralFactors": {
              "label": "Viral activators",
              "type": "Regulation",
              "notes": [
                "Tat/ICP4/VP16 recruit co-activators",
                "Redirect Mediator and P-TEFb"
              ]
            },
            "hostPol": {
              "label": "Retasked host polymerase",
              "type": "Host polymerase",
              "notes": [
                "CDK7/CDK9 activated by viral cues",
                "Transcription factories relocalize to viral loci"
              ]
            },
            "release": {
              "label": "Escape and phase switch",
              "type": "Viral expression",
              "notes": [
                "Early RNAs trigger replication",
                "Late programs follow timed cascades"
              ]
            }
          },
          "edges": {
            "chromatinToFactors": "Remodel chromatin",
            "factorsToPol": "Load polymerase",
            "polToEscape": "Shift to viral RNA"
          }
        }
      },
      "exonIntron": {
        "eukaryote": {
          "nodes": {
            "promoter": {
              "label": "Promoter + 5′ UTR",
              "type": "Promoter",
              "notes": [
                "CpG islands and histone marks",
                "Co-transcriptional capping"
              ]
            },
            "exon1": {
              "label": "Exon 1",
              "type": "Exon",
              "notes": [
                "Contains start codon and ESE",
                "SR proteins stabilize the region"
              ]
            },
            "intron": {
              "label": "Intron",
              "type": "Intron",
              "notes": [
                "5′ GU … AG 3′ with branch point A",
                "RNP forms a lariat"
              ]
            },
            "exon2": {
              "label": "Exon 2",
              "type": "Exon",
              "notes": [
                "Carries ESE/ISE to enforce choice",
                "Maintains reading frame"
              ]
            },
            "splicing": {
              "label": "Spliceosome",
              "type": "Complex",
              "notes": [
                "U1/U2/U4/U5/U6 orchestrate catalysis",
                "PRP8 and ATPases drive remodeling"
              ]
            }
          },
          "edges": {
            "promoterToExon1": "Transcribes",
            "exon1ToIntron": "Forms pre-mRNA",
            "intronToExon2": "Ligates exons",
            "splicingControl": "Catalyzes splicing"
          }
        },
        "prokaryote": {
          "nodes": {
            "leader": {
              "label": "Leader sequence",
              "type": "5′ UTR",
              "notes": [
                "Shine–Dalgarno ribosome binding site",
                "Contains attenuation switches"
              ]
            },
            "coding": {
              "label": "Coding region",
              "type": "ORF",
              "notes": [
                "Often polycistronic",
                "Overlapping start/stop sites"
              ]
            },
            "terminator": {
              "label": "Terminator",
              "type": "ρ-dependent/independent",
              "notes": [
                "GC stem–loop plus poly-U or Rut site",
                "Sets transcription speed"
              ]
            },
            "processing": {
              "label": "RNA processing",
              "type": "Ribonuclease",
              "notes": [
                "RNase E/III cleave operons",
                "Riboswitches modulate stability"
              ]
            }
          },
          "edges": {
            "leaderToCoding": "Initiates translation",
            "codingToTerminator": "Synthesizes transcript",
            "terminatorToProcessing": "Hands off to processing"
          }
        },
        "virus": {
          "nodes": {
            "donor": {
              "label": "Donor site",
              "type": "5′ splice site",
              "notes": [
                "Weak consensus motifs",
                "Depends on host SR/hnRNP balance"
              ]
            },
            "intronic": {
              "label": "Viral introns",
              "type": "Intron",
              "notes": [
                "Regulatory ESS/EIS elements",
                "Control export and temporal phases"
              ]
            },
            "acceptor": {
              "label": "Acceptor site",
              "type": "3′ splice site",
              "notes": [
                "AG plus polypyrimidine tract",
                "Generates multiple proteins"
              ]
            },
            "export": {
              "label": "Export and switching",
              "type": "Regulation",
              "notes": [
                "Rev/Crm1 or M export complexes",
                "Defines early versus late transcripts"
              ]
            }
          },
          "edges": {
            "donorToIntronic": "Forms intron",
            "intronicToAcceptor": "Splices",
            "acceptorToExport": "Exports mRNA"
          }
        }
      },
      "operon": {
        "eukaryote": {
          "nodes": {
            "enhancer": {
              "label": "Enhancer/activator cluster",
              "type": "Regulation",
              "notes": [
                "mtDNA/plastid factors (NRF1)",
                "Loops to the promoter"
              ]
            },
            "promoter": {
              "label": "Bicistronic promoter",
              "type": "Promoter",
              "notes": [
                "POLRMT/TFB2M driven",
                "Produces a leader RNA"
              ]
            },
            "polycistronic": {
              "label": "Polycistronic transcript",
              "type": "mRNA",
              "notes": [
                "Shared 5′/3′ UTR",
                "Processed by endoribonucleases"
              ]
            },
            "processing": {
              "label": "Processing & editing",
              "type": "RNP complex",
              "notes": [
                "RNase P/Z and polyadenylation",
                "RNA editing and tRNA excision"
              ]
            }
          },
          "edges": {
            "enhancerToPromoter": "Activates",
            "promoterToPoly": "Transcribes the cluster",
            "polyToProcessing": "Feeds into processing"
          }
        },
        "prokaryote": {
          "nodes": {
            "operator": {
              "label": "Operator",
              "type": "DNA operator",
              "notes": [
                "Binds repressors/activators",
                "Examples: lacO, trpO"
              ]
            },
            "rnap": {
              "label": "RNAP + σ",
              "type": "Polymerase",
              "notes": [
                "Initiates at the promoter",
                "Responsive to co-activators"
              ]
            },
            "genes": {
              "label": "Structural genes",
              "type": "Polycistronic mRNA",
              "notes": [
                "lacZYA/trpEDCBA operons",
                "Coupled transcription-translation"
              ]
            },
            "attenuation": {
              "label": "Attenuation/regulation",
              "type": "Regulation",
              "notes": [
                "Leader peptide stalling",
                "Metabolite riboswitch control"
              ]
            }
          },
          "edges": {
            "operatorToRnap": "Modulates RNAP binding",
            "rnapToGenes": "Produces mRNA",
            "genesToAttenuation": "Leader transcript",
            "attenuationToRnap": "Regulates continuation"
          }
        },
        "virus": {
          "nodes": {
            "ltr": {
              "label": "LTR promoter",
              "type": "Promoter",
              "notes": [
                "U3/R/U5 modules",
                "Requires Tat/integration"
              ]
            },
            "polymerase": {
              "label": "Viral polymerase",
              "type": "Enzyme",
              "notes": [
                "RT or hijacked Pol II",
                "Initiates transcription"
              ]
            },
            "polyprotein": {
              "label": "Polyprotein mRNA",
              "type": "mRNA",
              "notes": [
                "Gag-Pol/NS transcripts",
                "Frameshift tunes stoichiometry"
              ]
            },
            "frameshift": {
              "label": "Frameshift/editing",
              "type": "Regulation",
              "notes": [
                "−1 frameshift or RNA editing",
                "Controls late proteins"
              ]
            }
          },
          "edges": {
            "ltrToPolymerase": "Launches transcription",
            "polymeraseToPolyprotein": "Produces mRNA",
            "polyproteinToFrameshift": "Switches reading frame"
          }
        }
      },
      "library": {
        "eukaryote": {
          "nodes": {
            "factors": {
              "label": "Factor library",
              "type": "PIC core",
              "notes": [
                "TFIID/TFIIA/TFIIB sets",
                "Prepares the TSS"
              ]
            },
            "coactivators": {
              "label": "Co-activators/chromatin",
              "type": "Regulation",
              "notes": [
                "Mediator, SAGA, SWI/SNF",
                "Histone marks H3K4me3/H3K27ac"
              ]
            },
            "pause": {
              "label": "Pause control",
              "type": "RNA pause",
              "notes": [
                "DSIF/NELF pause module",
                "P-TEFb gate to elongation"
              ]
            },
            "elongation": {
              "label": "Elongation/processivity",
              "type": "Elongation",
              "notes": [
                "FACT, PAF1C, m6A writers",
                "Coupled co-transcriptional processing"
              ]
            }
          },
          "edges": {
            "factorsToCoactivators": "Recruit modules",
            "coactivatorsToPause": "Prepare pause platform",
            "pauseToElongation": "Trigger elongation"
          }
        },
        "prokaryote": {
          "nodes": {
            "sigma": {
              "label": "Sigma factors",
              "type": "Regulation",
              "notes": [
                "σ70, σ32, σ54",
                "Define promoter classes"
              ]
            },
            "remodeling": {
              "label": "Nucleoid remodeling",
              "type": "DNA organization",
              "notes": [
                "Fis, H-NS, IHF",
                "Shape supercoiled domains"
              ]
            },
            "termination": {
              "label": "Termination",
              "type": "Process",
              "notes": [
                "ρ, NusA/B factors",
                "Coordinates with translation"
              ]
            },
            "stress": {
              "label": "Stress signals",
              "type": "Regulation",
              "notes": [
                "ppGpp/DksA, CsrA",
                "Switch sigma usage"
              ]
            }
          },
          "edges": {
            "sigmaToRemodeling": "Guide opening",
            "remodelingToTermination": "Set transcription window",
            "stressToTermination": "Modulate termination"
          }
        },
        "virus": {
          "nodes": {
            "entry": {
              "label": "Entry/template",
              "type": "Genome",
              "notes": [
                "ssRNA or dsDNA template",
                "Capsid or nucleosome release"
              ]
            },
            "hostFactors": {
              "label": "Host factors",
              "type": "Co-factors",
              "notes": [
                "TFIID, P-TEFb, HAT",
                "Reprogram cell cycle"
              ]
            },
            "polymerase": {
              "label": "Viral polymerase",
              "type": "Enzyme",
              "notes": [
                "RdRp or DNA polymerase",
                "Requires priming"
              ]
            },
            "switching": {
              "label": "Program switching",
              "type": "Regulation",
              "notes": [
                "Lytic/latent decisions",
                "Antisense RNAs"
              ]
            }
          },
          "edges": {
            "entryToHost": "Recruit factors",
            "hostToPolymerase": "Activate synthesis",
            "polymeraseToSwitching": "Control phases"
          }
        }
      }
    },

    "nodes": {
      "chromatin": {
        "label": "Chromatin remodeled",
        "type": "Chromatin",
        "notes": [
          "SWI/SNF and HATs expose the TATA box and clear nucleosomes.",
          "H3K4me3 / H3 acetylation increases TFIID affinity."
        ]
      },
      "mediator": {
        "label": "Mediator + general factors",
        "type": "Mediator complex",
        "notes": [
          "TFIID-TBP, TFIIA and TFIIB lock the +1 position.",
          "Tail/Head modules integrate enhancer signals."
        ]
      },
      "polii": {
        "label": "Pol II–TFIIF core",
        "type": "Pol II core",
        "notes": [
          "TFIIE coordinates TFIIH loading; XPB opens the bubble (-9/+2).",
          "CDK7 (CAK) phosphorylates CTD Ser5 and recruits the capping machinery."
        ]
      },
      "escape": {
        "label": "Promoter escape and pause",
        "type": "RNA transition",
        "notes": [
          "The DNA–RNA hybrid stabilizes (~8–9 nt) while Mediator disengages.",
          "DSIF/NELF hold Pol II at +20/+60 until P-TEFb activation."
        ]
      },
      "enhancer": {
        "label": "Enhancer loops",
        "type": "Enhancer",
        "notes": [
          "Activators and the Mediator Tail loop DNA, engaging Cohesin.",
          "Chromatin reader complexes maintain histone marks."
        ]
      },
      "ptefb": {
        "label": "P-TEFb / release signals",
        "type": "Regulation",
        "notes": [
          "CDK9/CycT activated via BRD4/SEC and stress pathways.",
          "Phosphorylate DSIF, NELF and CTD Ser2 to trigger productive elongation."
        ]
      }
    },
    "edges": {
      "chromatinMediator": "recruits",
      "mediatorPolii": "assembles the PIC",
      "poliiEscape": "initiates transcription",
      "enhancerMediator": "activates",
      "ptefbEscape": "releases the pause"
    },
    "messages": {
      "importError": "Failed to import JSON: ",
      "missingNodes": "JSON structure is missing a \"nodes\" array",
      "stateReset": "Stored state was reset after an error",
      "saveError": "Failed to save state",
      "autoCorrectionPrefix": "Auto-corrected:",
      "validationApplied": "Adjusted fields: {fields}",
      "pngFallback": "PNG export failed — delivered fallback SVG",
      "safeMode": "Safe mode: animations disabled",
      "dragHandle": "Drag",
      "nodeAria": "{label}. {type}. Move with arrow keys, Shift doubles the step."
    }
  },
  "de": {
    "htmlLang": "de",
    "page": {
      "title": "Pol-II-Transkriptionsinitiation – Prozessübersicht",
      "ariaLabel": "A4-Diagramm der Pol-II-Transkriptionsinitiation",
      "header": {
        "title": "Pol-II-Transkriptionsinitiation am +1-Start",
        "pill": "Eukaryot · Fortgeschritten · Prozessansicht",
        "meta": {
          "environment": "Umgebung: eukaryotischer Zellkern",
          "context": "Kontext: Klasse-II-Promotor, TATA+/Inr",
          "focus": "Fokus: Aufbau und Auslösung des PIC"
        }
      }
    },
    "map": {
      "title": "Karte der Assemblierung und Übergänge",
      "toolbarAria": "Kartensteuerung",
      "buttons": {
        "fit": "Ansicht anpassen",
        "grid": "Raster",
        "snap": "Am Raster ausrichten",
        "resetOverlap": "Ebenen ordnen"
      },
      "presets": {
        "presetLabel": "Voreinstellung",
        "presetAria": "Diagramm-Voreinstellung wählen",
        "orgLabel": "Organismus",
        "orgAria": "Domäne auswählen",
        "options": {
          "tssMini": "TSS(+1) Mini",
          "exonIntron": "Exon–Intron-Karte",
          "operon": "Operon",
          "library": "Erweiterte Bibliothek"
        },
        "orgOptions": {
          "eukaryote": "Eukaryoten",
          "prokaryote": "Prokaryoten",
          "virus": "Viren"
        }
      },
      "canvasAria": "Arbeitsbereich",
      "axisLabel": "Genom (5′ → 3′)",
      "instructions": "Verwenden Sie Maus oder Pfeiltasten, um Knoten zu verschieben. Strg+Scrollen zoomt, normales Scrollen verschiebt die Ansicht. Ziehen hält Elemente im Raster und berechnet Verbindungen neu.",
      "legendAria": "Legende",
      "legend": {
        "polii": "Pol II und allgemeine Faktoren",
        "chromatin": "Chromatin und Promotor-DNA",
        "rna": "RNA, Escape und Pause",
        "strand": "Strangrichtung (5′→3′ / 3′→5′)",
        "frame": "Koordinatenrahmen / Genomfenster"
      }
    },
    "timeline": {
      "title": "Schlüsselphasen und Kontrollpunkte",
      "ariaLabel": "Phasen",
      "order": [
        "assembly",
        "isomerization",
        "initiation",
        "escape"
      ],
      "steps": {
        "assembly": {
          "buttonTitle": "1. Präassemblierung",
          "buttonDetail": "TFIID erkennt TATA/Inr, Aktivatoren stabilisieren Mediator.",
          "panelTitle": "1. Präassemblierung des Präinitiationskomplexes",
          "panelPoints": [
            "TBP biegt die DNA um ~80° und positioniert +1 im aktiven Zentrum.",
            "TFIID bindet Koaktivatoren (TAF1/2) und H3K4me3-Marken.",
            "TFIIA stabilisiert TBP–DNA, TFIIB legt die Transkriptionsrichtung fest.",
            "Mediator überträgt Enhancer-Signale und bereitet das CDK8-Modul vor."
          ]
        },
        "isomerization": {
          "buttonTitle": "2. Isomerisierung",
          "buttonDetail": "TFIIE rekrutiert TFIIH, öffnet die Blase, lädt die Matrize.",
          "panelTitle": "2. Promotorisomerisierung und -öffnung",
          "panelPoints": [
            "TFIIE koordiniert das TFIIH-Recruitment und zündet den XPB-Helikasezyklus.",
            "ATP-abhängiges Aufschmelzen erzeugt eine offene Blase (-9/+2) um den TSS.",
            "Der Matrizenstrang wird durch den TFIIB-B-reader in Pol II geführt.",
            "CTD-Ser5-Phosphorylierung rekrutiert den Capping-Komplex."
          ]
        },
        "initiation": {
          "buttonTitle": "3. Initiation",
          "buttonDetail": "Abortive Zyklen < 10 nt, CTD Ser5-P startet Capping.",
          "panelTitle": "3. Initiation und kurze Transkripte",
          "panelPoints": [
            "Pol II startet bei +1 (A/C) und bildet kurze RNAs.",
            "Abortive Zyklen (<10 nt) räumen den Kanal; die TFIIB-Schleife lenkt den Austritt.",
            "NELF/DSIF binden an und bereiten die Pausenplattform vor.",
            "Ser5-phosphoryliertes CTD rekrutiert TFIIH-CAK und die Capping-Enzyme."
          ]
        },
        "escape": {
          "buttonTitle": "4. Promotor-Escape",
          "buttonDetail": "TFIIB/TFIIE lösen sich, NELF/DSIF steuern die Elongation.",
          "panelTitle": "4. Promotor-Escape und Etablierung der Pause",
          "panelPoints": [
            "Pol II passiert +10/+12, löst TFIIB/TFIIE und schwächt Mediator-Kontakte.",
            "TFIIH bleibt, bis ein stabiler DNA–RNA-Hybrid (~8–9 nt) entsteht.",
            "DSIF stabilisiert die Elongation, NELF hält Pol II bei +20/+60.",
            "P-TEFb (CDK9/CycT) phosphoryliert NELF/DSIF und CTD Ser2 für produktive Elongation."
          ]
        }
      }
    },
    "regulation": {
      "ariaLabel": "Regulation",
      "chips": [
        "Positive Regulation: Remodeler (SWI/SNF) und H3K27ac erhöhen die Promotorzugänglichkeit.",
        "Negative Regulation: NuRD-Komplexe und DNA-Methylierung begrenzen die TFIID-Beladung.",
        "Signalschnittstellen: MAPK/CDK-Wege aktivieren die CTD-Phosphorylierung über Mediator/CDK7.",
        "Qualitätskontrolle: TFIIS hilft Pol II, Stalls an schwachen Starts zu überwinden."
      ]
    },
    "model": {
      "title": "Datenmodell v1.1",
      "subheading": "JSON-Schema • A4-Visualgrammatik",
      "ariaLabel": "Modellelemente",
      "tabs": {
        "nodes": "Knoten",
        "edges": "Kanten",
        "layout": "Layout"
      },
      "content": {
        "nodes": {
          "title": "Knotenstruktur {id, x, y, w, h, label, type, data}",
          "items": [
            "Feld <strong>type</strong> umfasst Rollen wie DNA, RNA, Protein, Promoter, Enhancer, TSS, TF, Mediator usw.",
            "Geometrie in A4-Millimetern: Koordinaten (x, y) und Größen (w, h) relativ zum Rasterbereich.",
            "Im Advanced-Level ergänzen <code>frame</code>, <code>coordinates</code>, <code>strand</code> und <code>recognitionSites</code> das genombasierte Fenster, die Orientierung und Erkennungsmotive.",
            "Zusätzliche <code>data</code> enthalten 5′→3′-Marken, Modifikationen (H3K4me3) und Komplexzustände.",
            "<code>layer</code> und <code>zIndex</code> folgen dem Pol-II-Standard „process“."
          ],
          "callout": "Empfehlung: IDs wie <code>promoter:tata</code>, <code>protein:tf2h</code> für Exportkompatibilität verwenden.",
          "snippet": "{\n  \"id\": \"node:tfiih\",\n  \"type\": \"TFIIH\",\n  \"x\": 420,\n  \"y\": 120,\n  \"w\": 90,\n  \"h\": 46,\n  \"label\": \"TFIIH\",\n  \"layer\": \"factors\",\n  \"data\": {\"helicase\": \"XPB/XPD\", \"phosphorylation\": \"CTD Ser5\"}\n}"
        },
        "edges": {
          "title": "Kantendefinition {id, from, to, kind, label, router, markers}",
          "items": [
            "<strong>kind</strong>: flow (transkribiert, rekrutiert, phosphoryliert) oder regulation (aktiviert, reprimiert, pausiert).",
            "<code>router</code> beschreibt die Geometrie: orthogonal für PIC, Bezier für Enhancer-Schleifen, straight für kurze Verbindungen.",
            "Pfeilmarker (<code>markers</code>) bestimmen Form/Farbe; nutzen Sie arrow:polII, arrow:regulation, tee:repress.",
            "Erweiterte Kanten führen <code>frame</code>, <code>coordinates</code>, <code>strand</code> und <code>recognitionSites</code> für Genombereiche und Kontakt-Hotspots.",
            "<code>timeline</code> speichert Kontrollpunkte (z. B. {start: \"+1\", end: \"+60\"}) zur Synchronisation mit der Zeitachse."
          ],
          "callout": "Kanten per UUID mit Knoten verknüpfen – erleichtert das Zusammenführen verschiedener Diagramme.",
          "snippet": "{\n  \"id\": \"edge:tf2h-open\",\n  \"from\": \"node:tfiih\",\n  \"to\": \"node:openbubble\",\n  \"kind\": \"flow\",\n  \"label\": \"öffnet\",\n  \"router\": \"orthogonal\",\n  \"markers\": {\"start\": null, \"end\": \"arrow:polII\"}\n}"
        },
        "layout": {
          "title": "Layout-Regeln A4 landscape (Print-Thema)",
          "items": [
            "<code>page</code>: {width: 297, height: 210, margin: 12} — Maße in mm mit 28-mm-Raster.",
            "Ebenen (<code>layers</code>): background, chromatin, factors, rna, annotations – steuern die Zeichenreihenfolge.",
            "Stile (<code>styles</code>) fixieren Rollenfarben: Pol II #1d4ed8, Chromatin #4d7c0f, RNA #b91c1c.",
            "Guides (<code>guides</code>) definieren Achsen: time (links→rechts), assembly depth (oben→unten), regulation captions."
          ],
          "callout": "SVG/PNG-Export nutzt diese Parameter – Maßstab 1 mm = 3,78 px beibehalten.",
          "snippet": "{\n  \"layout\": {\n    \"page\": {\"width\": 297, \"height\": 210, \"margin\": 12},\n    \"grid\": {\"size\": 28, \"visible\": true},\n    \"theme\": \"print\"\n  }\n}"
        }
      }
    },
    "footer": {
      "attribution": "© 2025 eukaryote lab · Quellen: Pol-II-Literatur (Cold Spring Harbor, eLife, 2021–2024)",
      "license": "Lizenz: CC BY 4.0 · Namensnennung bei Weiterverwendung erforderlich",
      "scales": "Skalen: Zeit (links nach rechts) · Komplexstruktur (vertikal) · Regulatoren (Beschriftungen)",
      "controlsAria": "Export",
      "buttons": {
        "exportSvg": "SVG exportieren",
        "exportPng": "PNG exportieren (300 DPI)",
        "exportPdf": "PDF / Drucken",
        "exportJson": "JSON exportieren",
        "importJson": "JSON importieren",
        "resetLayout": "Zurücksetzen",
        "openReference": "Faktortabelle"
      }
    },
    "overlay": {
      "close": "Schließen",
      "title": "Faktorzusammensetzung und Funktionen",
      "columns": {
        "module": "Modul",
        "composition": "Zusammensetzung",
        "function": "Funktion in der Initiation",
        "control": "Regulation"
      },
      "rows": [
        {
          "module": "TFIID-Kern",
          "composition": "TBP + TAF1/2/4/6",
          "function": "Erkennt TATA/Inr, kontaktiert DPE/MTE",
          "control": "H3/H4-Acetylierung, TAF-Phosphorylierung"
        },
        {
          "module": "TFIIB-Brücke",
          "composition": "Rrn7-ähnliche Domänen",
          "function": "Organisiert den +1-Kanal, stabilisiert frühe Transkripte",
          "control": "Ser65-Phosphorylierung verringert Verweildauer"
        },
        {
          "module": "TFIIE/F",
          "composition": "α/β-Untereinheiten",
          "function": "Rekrutiert TFIIH, stabilisiert die offene Blase",
          "control": "Ubiquitinierung steuert Abbau"
        },
        {
          "module": "TFIIH",
          "composition": "XPB, XPD, CAK (CDK7/CycH/MAT1)",
          "function": "Helikaseaktivität, CTD-Ser5-Phosphorylierung",
          "control": "Stressantwort-Signale über ATR/ATM"
        },
        {
          "module": "Mediator",
          "composition": "Head/Middle/Tail + CDK8",
          "function": "Plattform für Faktoren, integriert Enhancer-Signale",
          "control": "CDK8/CycC schaltet den Pausenmodus um"
        },
        {
          "module": "Pause-Modul",
          "composition": "DSIF (Spt4/5), NELF A–E",
          "function": "Stabilisiert Pol II bei +20/+60, bereitet Pause vor",
          "control": "P-TEFb-Phosphorylierung löst die Pause"
        }
      ]
    },
    "presets": {
      "tssMini": {
        "prokaryote": {
          "nodes": {
            "promoter": {
              "label": "−35/−10-Promotor",
              "type": "σ70-Promotor",
              "notes": [
                "Konservierte −35-TTGACA- und −10-TATAAT-Motive",
                "UP-Elemente erhöhen die RNAP-Affinität"
              ]
            },
            "holoenzyme": {
              "label": "RNAP-σ70-Holoenzym",
              "type": "Polymerase",
              "notes": [
                "β/β′ bilden den Kanal; σ erkennt Motive",
                "α-CTD kontaktiert UP-Elemente"
              ]
            },
            "openComplex": {
              "label": "Offener Komplex",
              "type": "Initiationskomplex",
              "notes": [
                "DNA über ~13 bp aufgeschmolzen",
                "σ3.2 stabilisiert Initialtranskripte"
              ]
            },
            "clearance": {
              "label": "Promotor-Freisetzung",
              "type": "Frühe Transkription",
              "notes": [
                "σ löst sich bei +10/+12",
                "GreA/B verhindern Zurückrutschen"
              ]
            }
          },
          "edges": {
            "promoterToRnap": "Rekrutiert RNAP",
            "rnapToOpen": "Isomerisiert",
            "openToClearance": "Promotor-Escape"
          }
        },
        "virus": {
          "nodes": {
            "hostChromatin": {
              "label": "Wirtspromotor",
              "type": "DNA/Chromatin",
              "notes": [
                "Virale Proteine verändern Acetylierung und Methylierung",
                "Integration erzeugt LTRs oder invertierte Wiederholungen"
              ]
            },
            "viralFactors": {
              "label": "Virale Aktivatoren",
              "type": "Regulation",
              "notes": [
                "Tat/ICP4/VP16 rekrutieren Koaktivatoren",
                "Lenken Mediator und P-TEFb um"
              ]
            },
            "hostPol": {
              "label": "Umgelenkte Wirts-Polymerase",
              "type": "Wirtspolymerase",
              "notes": [
                "CDK7/CDK9 durch virale Signale aktiviert",
                "Transkriptionsfabriken verlagern sich zu viralen Loci"
              ]
            },
            "release": {
              "label": "Escape und Phasenwechsel",
              "type": "Virale Expression",
              "notes": [
                "Frühe RNAs starten Replikation",
                "Späte Programme folgen Zeitkaskaden"
              ]
            }
          },
          "edges": {
            "chromatinToFactors": "Chromatin umbauen",
            "factorsToPol": "Polymerase laden",
            "polToEscape": "Auf virale RNA umschalten"
          }
        }
      },
      "exonIntron": {
        "eukaryote": {
          "nodes": {
            "promoter": {
              "label": "Promotor + 5′-UTR",
              "type": "Promotor",
              "notes": [
                "CpG-Inseln und Histonmarken",
                "Ko-transkriptionelles Capping"
              ]
            },
            "exon1": {
              "label": "Exon 1",
              "type": "Exon",
              "notes": [
                "Enthält Startcodon und ESE",
                "SR-Proteine stabilisieren den Bereich"
              ]
            },
            "intron": {
              "label": "Intron",
              "type": "Intron",
              "notes": [
                "5′ GU … AG 3′ mit Branchpoint-A",
                "RNP bildet ein Lariat"
              ]
            },
            "exon2": {
              "label": "Exon 2",
              "type": "Exon",
              "notes": [
                "Trägt ESE/ISE für Auswahl",
                "Erhält Leserahmen"
              ]
            },
            "splicing": {
              "label": "Spleißosom",
              "type": "Komplex",
              "notes": [
                "U1/U2/U4/U5/U6 katalysieren",
                "PRP8 und ATPasen treiben Dynamik"
              ]
            }
          },
          "edges": {
            "promoterToExon1": "Transkribiert",
            "exon1ToIntron": "Bildet Prä-mRNA",
            "intronToExon2": "Ligiert Exons",
            "splicingControl": "Katalysiert Spleißen"
          }
        },
        "prokaryote": {
          "nodes": {
            "leader": {
              "label": "Leader-Sequenz",
              "type": "5′-UTR",
              "notes": [
                "Shine-Dalgarno und RBS",
                "Enthält Attenuations-Elemente"
              ]
            },
            "coding": {
              "label": "Kodierbereich",
              "type": "ORF",
              "notes": [
                "Oft polycistronisch",
                "Überlappende Start-/Stoppsignale"
              ]
            },
            "terminator": {
              "label": "Terminator",
              "type": "ρ-unabhängig/abhängig",
              "notes": [
                "GC-Haarnadel + Poly-U oder Rut-Stelle",
                "Bestimmt Transkriptionsgeschwindigkeit"
              ]
            },
            "processing": {
              "label": "RNA-Verarbeitung",
              "type": "Ribonuklease",
              "notes": [
                "RNase E/III schneiden Polycistron",
                "Riboswitch steuert Stabilität"
              ]
            }
          },
          "edges": {
            "leaderToCoding": "Startet Translation",
            "codingToTerminator": "Synthese des Transkripts",
            "terminatorToProcessing": "Gibt zur Verarbeitung weiter"
          }
        },
        "virus": {
          "nodes": {
            "donor": {
              "label": "Donor-Stelle",
              "type": "5′-Spleißstelle",
              "notes": [
                "Schwache Konsensussequenzen",
                "Abhängig von SR-/hnRNP-Proteinen"
              ]
            },
            "intronic": {
              "label": "Virale Introns",
              "type": "Intron",
              "notes": [
                "Regulatorische ESS/EIS-Elemente",
                "Steuern Export und Phasen"
              ]
            },
            "acceptor": {
              "label": "Akzeptor-Stelle",
              "type": "3′-Spleißstelle",
              "notes": [
                "AG + Polypyrimidinspur",
                "Erzeugt multiple Proteine"
              ]
            },
            "export": {
              "label": "Export & Umschalten",
              "type": "Regulation",
              "notes": [
                "Rev/Crm1 oder M-Export-Komplexe",
                "Teilen Expression in früh/spät"
              ]
            }
          },
          "edges": {
            "donorToIntronic": "Bildet Intron",
            "intronicToAcceptor": "Spleißt",
            "acceptorToExport": "Exportiert mRNA"
          }
        }
      },
      "operon": {
        "eukaryote": {
          "nodes": {
            "enhancer": {
              "label": "Enhancer/Aktivatoren",
              "type": "Regulation",
              "notes": [
                "mtDNA/Plastidenfaktoren",
                "Schleife zum Promotor"
              ]
            },
            "promoter": {
              "label": "Bidirektionaler Promotor",
              "type": "Promotor",
              "notes": [
                "POLRMT/TFB2M und TFBM",
                "Bildet Leader-mRNA"
              ]
            },
            "polycistronic": {
              "label": "Polycistronisches Transkript",
              "type": "mRNA",
              "notes": [
                "Geteilte 5′/3′-UTRs",
                "Prozessiert durch Endoribonukleasen"
              ]
            },
            "processing": {
              "label": "Verarbeitung & Editing",
              "type": "RNP-Komplex",
              "notes": [
                "RNase P/Z, Polyadenylierung",
                "Editing & tRNA-Spleißen"
              ]
            }
          },
          "edges": {
            "enhancerToPromoter": "Aktiviert",
            "promoterToPoly": "Transkribiert Cluster",
            "polyToProcessing": "Überführt in Verarbeitung"
          }
        },
        "prokaryote": {
          "nodes": {
            "operator": {
              "label": "Operator",
              "type": "DNA-Operator",
              "notes": [
                "Bindet Repressoren/Aktivatoren",
                "Beispiel: lacO, trpO"
              ]
            },
            "rnap": {
              "label": "RNAP + σ",
              "type": "Polymerase",
              "notes": [
                "Initiiert am Promotor",
                "Sensitiv für Koaktivatoren"
              ]
            },
            "genes": {
              "label": "Strukturgene",
              "type": "Polycistronische mRNA",
              "notes": [
                "lacZYA/trpEDCBA",
                "Koppeln Translation"
              ]
            },
            "attenuation": {
              "label": "Attenuation/Regulation",
              "type": "Regulation",
              "notes": [
                "Leader-Peptid und Stalls",
                "Metabolit-Riboswitch"
              ]
            }
          },
          "edges": {
            "operatorToRnap": "Steuert Bindung",
            "rnapToGenes": "Synthese der mRNA",
            "genesToAttenuation": "Leader-Transkript",
            "attenuationToRnap": "Moduliert Fortsetzung"
          }
        },
        "virus": {
          "nodes": {
            "ltr": {
              "label": "LTR-Promotor",
              "type": "Promotor",
              "notes": [
                "U3/R/U5-Module",
                "Benötigt Tat/Integration"
              ]
            },
            "polymerase": {
              "label": "Virale Polymerase",
              "type": "Enzym",
              "notes": [
                "RT oder Wirtsfaktor",
                "Startet Transkription"
              ]
            },
            "polyprotein": {
              "label": "Polyprotein-mRNA",
              "type": "mRNA",
              "notes": [
                "Gag-Pol/NS-Transkripte",
                "Frameshift steuert Stöchiometrie"
              ]
            },
            "frameshift": {
              "label": "Frameshift/Editing",
              "type": "Regulation",
              "notes": [
                "−1 Frameshift oder RNA-Editing",
                "Kontrolliert späte Proteine"
              ]
            }
          },
          "edges": {
            "ltrToPolymerase": "Startet Transkription",
            "polymeraseToPolyprotein": "Produziert mRNA",
            "polyproteinToFrameshift": "Schaltet Leserahmen"
          }
        }
      },
      "library": {
        "eukaryote": {
          "nodes": {
            "factors": {
              "label": "Faktor-Bibliothek",
              "type": "PIC-Kern",
              "notes": [
                "TFIID/TFIIA/TFIIB-Sets",
                "Bereitet den TSS vor"
              ]
            },
            "coactivators": {
              "label": "Koaktivatoren/Chromatin",
              "type": "Regulation",
              "notes": [
                "Mediator, SAGA, SWI/SNF",
                "Histonmarken H3K4me3/H3K27ac"
              ]
            },
            "pause": {
              "label": "Pause & Kontrolle",
              "type": "RNA-Pause",
              "notes": [
                "DSIF/NELF",
                "P-TEFb startet Elongation"
              ]
            },
            "elongation": {
              "label": "Elongation/Prozessivität",
              "type": "Elongation",
              "notes": [
                "FACT, PAF1C, m6A-Schreiber",
                "Gekoppelte ko-transkriptionelle Verarbeitung"
              ]
            }
          },
          "edges": {
            "factorsToCoactivators": "Rekrutiert Module",
            "coactivatorsToPause": "Bereitet Pausenplattform vor",
            "pauseToElongation": "Startet Elongation"
          }
        },
        "prokaryote": {
          "nodes": {
            "sigma": {
              "label": "Sigma-Faktoren",
              "type": "Regulation",
              "notes": [
                "σ70, σ32, σ54",
                "Bestimmen Promotor-Spektrum"
              ]
            },
            "remodeling": {
              "label": "Nukleoid/Remodeler",
              "type": "DNA-Organisation",
              "notes": [
                "Fis, H-NS, IHF",
                "Kontrollieren Supercoiling"
              ]
            },
            "termination": {
              "label": "Terminierung",
              "type": "Prozess",
              "notes": [
                "ρ-, NusA/B-Faktoren",
                "Koppelt an Translation"
              ]
            },
            "stress": {
              "label": "Stresssignale",
              "type": "Regulation",
              "notes": [
                "ppGpp/DksA, CsrA",
                "Schalten Sigma-Nutzung um"
              ]
            }
          },
          "edges": {
            "sigmaToRemodeling": "Steuert Öffnung",
            "remodelingToTermination": "Setzt Transkriptionsfenster",
            "stressToTermination": "Moduliert Terminierung"
          }
        },
        "virus": {
          "nodes": {
            "entry": {
              "label": "Einstieg/Vorlage",
              "type": "Genom",
              "notes": [
                "ssRNA oder dsDNA",
                "Kapsid/Nukleosom wird freigesetzt"
              ]
            },
            "hostFactors": {
              "label": "Wirtsfaktoren",
              "type": "Ko-Faktoren",
              "notes": [
                "TFIID, P-TEFb, HAT",
                "Reprogrammieren Zellzyklus"
              ]
            },
            "polymerase": {
              "label": "Virale Polymerase",
              "type": "Enzym",
              "notes": [
                "RdRp oder DNA-Polymerase",
                "Benötigt Priming"
              ]
            },
            "switching": {
              "label": "Programmwechsel",
              "type": "Regulation",
              "notes": [
                "Lytische/latente Entscheidung",
                "Antisense-RNAs"
              ]
            }
          },
          "edges": {
            "entryToHost": "Rekrutiert Faktoren",
            "hostToPolymerase": "Aktiviert Synthese",
            "polymeraseToSwitching": "Steuert Stadien"
          }
        }
      }
    },
    "nodes": {
      "chromatin": {
        "label": "Chromatin umgebaut",
        "type": "Chromatin",
        "notes": [
          "SWI/SNF und HATs legen den TATA-Bereich frei und entfernen Nukleosomen.",
          "H3K4me3 / H3-Acetylierung erhöht die TFIID-Affinität."
        ]
      },
      "mediator": {
        "label": "Mediator + allgemeine Faktoren",
        "type": "Mediator-Komplex",
        "notes": [
          "TFIID-TBP, TFIIA und TFIIB fixieren die +1-Position.",
          "Tail/Head-Module integrieren Enhancer-Signale."
        ]
      },
      "polii": {
        "label": "Pol II–TFIIF-Kern",
        "type": "Pol-II-Kern",
        "notes": [
          "TFIIE koordiniert TFIIH; XPB öffnet die Blase (-9/+2).",
          "CDK7 (CAK) phosphoryliert CTD Ser5 und rekrutiert den Capping-Komplex."
        ]
      },
      "escape": {
        "label": "Promotor-Escape und Pause",
        "type": "RNA-Übergang",
        "notes": [
          "Der DNA–RNA-Hybrid stabilisiert sich (~8–9 nt), Mediator löst sich.",
          "DSIF/NELF halten Pol II bei +20/+60 bis zur P-TEFb-Aktivierung."
        ]
      },
      "enhancer": {
        "label": "Enhancer-Schleifen",
        "type": "Enhancer",
        "notes": [
          "Aktivatoren und Mediator-Tail bilden Schleifen und rekrutieren Cohesin.",
          "Chromatin-Reader-Komplexe erhalten Histonmarken."
        ]
      },
      "ptefb": {
        "label": "P-TEFb / Freigabesignale",
        "type": "Regulation",
        "notes": [
          "CDK9/CycT werden über BRD4/SEC und Stresssignale aktiviert.",
          "Phosphorylieren DSIF, NELF und CTD Ser2 für produktive Elongation."
        ]
      }
    },
    "edges": {
      "chromatinMediator": "rekrutiert",
      "mediatorPolii": "baut den PIC auf",
      "poliiEscape": "initiiert die Transkription",
      "enhancerMediator": "aktiviert",
      "ptefbEscape": "löst die Pause"
    },
    "messages": {
      "importError": "JSON konnte nicht importiert werden: ",
      "missingNodes": "JSON-Struktur enthält kein \"nodes\"-Array",
      "stateReset": "Gespeicherter Zustand wurde nach einem Fehler zurückgesetzt",
      "saveError": "Zustand konnte nicht gespeichert werden",
      "autoCorrectionPrefix": "Automatisch korrigiert:",
      "validationApplied": "Angepasste Felder: {fields}",
      "pngFallback": "PNG-Export fehlgeschlagen – SVG als Fallback gespeichert",
      "safeMode": "Sicherheitsmodus: Animationen deaktiviert",
      "dragHandle": "Ziehen",
      "nodeAria": "{label}. {type}. Mit Pfeiltasten bewegen, Umschalt verdoppelt die Schritte."
    }
  }
};

      const TIMELINE_ORDER = ['assembly', 'isomerization', 'initiation', 'escape'];
      const MODEL_TAB_ORDER = ['nodes', 'edges', 'layout'];
      const DEFAULT_LANG = 'ru';

      function normalizeLang(value) {
        if (!value) return null;
        return value.toLowerCase().split('-')[0];
      }

      function resolveLanguage() {
        const params = new URLSearchParams(window.location.search);
        const fromParam = normalizeLang(params.get('ui_lang') || params.get('ui-lang') || params.get('lang') || params.get('locale'));
        const meta = normalizeLang(document.querySelector('meta[name="ui-lang"]')?.content);
        const dataAttr = normalizeLang(document.documentElement.getAttribute('data-ui-lang'));
        const attr = normalizeLang(document.documentElement.getAttribute('lang'));
        if (fromParam && STRINGS[fromParam]) return fromParam;
        if (meta && STRINGS[meta]) return meta;
        if (dataAttr && STRINGS[dataAttr]) return dataAttr;
        if (attr && STRINGS[attr]) return attr;
        return DEFAULT_LANG;
      }

      const UI_LANG = resolveLanguage();
      const ACTIVE_LANG = STRINGS[UI_LANG] ? UI_LANG : DEFAULT_LANG;
      const ACTIVE_STRINGS = STRINGS[ACTIVE_LANG];
      const FALLBACK_STRINGS = STRINGS[DEFAULT_LANG];

      document.documentElement.setAttribute('data-ui-lang', ACTIVE_LANG);
      document.documentElement.setAttribute('lang', ACTIVE_STRINGS.htmlLang || ACTIVE_LANG);
      const metaLang = document.querySelector('meta[name="ui-lang"]');
      if (metaLang) {
        metaLang.setAttribute('content', ACTIVE_LANG);
      }

      function getLocaleEntry(path) {
        const segments = path.split('.');
        let current = ACTIVE_STRINGS;
        let fallback = FALLBACK_STRINGS;
        for (const segment of segments) {
          current = current && Object.prototype.hasOwnProperty.call(current, segment) ? current[segment] : undefined;
          fallback = fallback && Object.prototype.hasOwnProperty.call(fallback, segment) ? fallback[segment] : undefined;
        }
        return current !== undefined ? current : fallback;
      }

      function getLocaleString(path) {
        const value = getLocaleEntry(path);
        return typeof value === 'string' ? value : '';
      }

      function getLocaleArray(path) {
        const value = getLocaleEntry(path);
        return Array.isArray(value) ? value.slice() : [];
      }

      const URL_PARAMS = new URLSearchParams(window.location.search);

      const GRID_SIZE = 24;
      const MAP_WIDTH = 960;
      const MAP_HEIGHT = 520;
      const STORAGE_KEY_BASE = 'polii-map-layout-v1';
      const EXPORT_BASE_NAME = 'transcription_initiation_polII';
      const CSS_PX_PER_INCH = 96;
      const EXPORT_DPI = 300;
      const MM_PER_INCH = 25.4;
      const PAGE_WIDTH_MM = 297;
      const PAGE_HEIGHT_MM = 210;
      const LAYER_ORDER = { chromatin: 10, factors: 20, rna: 30, annotations: 40 };
      const LAYER_STYLE = {
        chromatin: { fill: '#dcfce7', stroke: '#4d7c0f' },
        factors: { fill: '#ede9fe', stroke: '#4338ca' },
        rna: { fill: '#fee2e2', stroke: '#b91c1c' },
        annotations: { fill: '#e2e8f0', stroke: '#475569' }
      };
      const ALLOWED_NODE_LAYERS = new Set(Object.keys(LAYER_STYLE));
      const ALLOWED_STRANDS = new Set(['plus', '5to3', 'minus', '3to5', 'bidirectional', 'both', 'unknown']);
      const ALLOWED_EDGE_KINDS = new Set(['flow', 'regulation']);
      const ALLOWED_EDGE_ROUTERS = new Set(['orthogonal', 'direct', 'straight', 'bezier']);
      const ALLOWED_MARKERS = new Set(['arrow-flow', 'arrow-regulation', 'tee-regulation']);

      const SAFE_MODE = detectSafeMode();
      if (SAFE_MODE && document.body) {
        document.body.classList.add('safe-mode');
      }

      function cloneFrame(frame) {
        if (!frame || typeof frame !== 'object') return null;
        const result = {};
        if (frame.type) result.type = String(frame.type);
        if (frame.assembly) result.assembly = String(frame.assembly);
        if (frame.chromosome) result.chromosome = String(frame.chromosome);
        if (frame.locus) result.locus = String(frame.locus);
        if (frame.reference) result.reference = String(frame.reference);
        if (frame.notes) result.notes = String(frame.notes);
        return Object.keys(result).length ? result : null;
      }

      function cloneCoordinates(coordinates) {
        if (!coordinates || typeof coordinates !== 'object') return null;
        const start = Number(coordinates.start);
        const end = Number(coordinates.end);
        if (!Number.isFinite(start) || !Number.isFinite(end)) return null;
        const result = { start, end };
        if (coordinates.unit) {
          result.unit = String(coordinates.unit);
        }
        if (coordinates.reference) {
          result.reference = String(coordinates.reference);
        }
        if (Number.isFinite(Number(coordinates.confidence))) {
          const confidence = Math.min(1, Math.max(0, Number(coordinates.confidence)));
          result.confidence = confidence;
        }
        return result;
      }

      function cloneRecognitionSites(sites) {
        if (!Array.isArray(sites)) return [];
        return sites
          .map(site => {
            if (!site || typeof site !== 'object') return null;
            if (!site.name && !Number.isFinite(Number(site.start)) && !Number.isFinite(Number(site.end))) return null;
            const start = Number(site.start);
            const end = Number(site.end);
            if (!Number.isFinite(start) || !Number.isFinite(end)) return null;
            const entry = {
              name: site.name ? String(site.name) : '',
              start,
              end
            };
            if (site.sequence) entry.sequence = String(site.sequence);
            if (site.strand) entry.strand = String(site.strand);
            if (site.evidence) entry.evidence = String(site.evidence);
            if (site.notes) entry.notes = String(site.notes);
            return entry;
          })
          .filter(Boolean);
      }

      function cloneStringArray(value) {
        return Array.isArray(value) ? value.map(item => String(item)) : [];
      }

      function cloneTimeline(timeline) {
        if (!timeline || typeof timeline !== 'object') return null;
        const result = {};
        if (timeline.phase) result.phase = String(timeline.phase);
        if (Number.isFinite(Number(timeline.order))) result.order = Number(timeline.order);
        if (Number.isFinite(Number(timeline.start))) result.start = Number(timeline.start);
        if (Number.isFinite(Number(timeline.end))) result.end = Number(timeline.end);
        if (timeline.unit) result.unit = String(timeline.unit);
        return Object.keys(result).length ? result : null;
      }

      function cloneMarkers(markers) {
        if (!markers || typeof markers !== 'object') return null;
        const result = {};
        if (markers.start) result.start = String(markers.start);
        if (markers.end) result.end = String(markers.end);
        return Object.keys(result).length ? result : null;
      }

      let activePresetKey = 'tssMini';
      let activeOrgKey = 'eukaryote';
      let storageKey = buildStorageKey(activePresetKey, activeOrgKey);
      let presetNodes = [];
      let presetEdges = [];
      let edgeRenderPending = false;

      const NODE_TEMPLATES = [
  {
    "id": "node:chromatin",
    "key": "chromatin",
    "layer": "chromatin",
    "x": 48,
    "y": 216,
    "width": 216,
    "height": 132,
    "frame": {
      "type": "genomic",
      "assembly": "GRCh38",
      "chromosome": "chr17",
      "locus": "POLR2A promoter window",
      "reference": "chr17:74,617,320-74,617,520"
    },
    "coordinates": {
      "start": -45,
      "end": 60,
      "unit": "bp",
      "reference": "+1 = POLR2A TSS (hg38)",
      "confidence": 0.92
    },
    "strand": "plus",
    "recognitionSites": [
      {
        "name": "TATA-box",
        "start": -31,
        "end": -24,
        "sequence": "TATAWAWR",
        "strand": "plus",
        "evidence": "TBP ChIP-seq (ENCODE)",
        "notes": "Core promoter motif"
      },
      {
        "name": "Inr",
        "start": -2,
        "end": 4,
        "sequence": "YYANWYY",
        "strand": "plus",
        "evidence": "CAGE +1 peak",
        "notes": "Defines transcription start"
      }
    ],
    "aliases": ["POLR2A promoter", "Core promoter window"],
    "timeline": { "phase": "assembly", "order": 1, "start": -45, "end": 4, "unit": "bp" },
    "evidence": ["Cryo-EM PIC (PDB 7E8S)", "ENCODE TFIID ChIP-seq"],
    "references": ["https://doi.org/10.1038/s41594-021-00606-2"],
    "confidence": 0.9
  },
  {
    "id": "node:mediator",
    "key": "mediator",
    "layer": "factors",
    "x": 288,
    "y": 192,
    "width": 216,
    "height": 144,
    "frame": {
      "type": "interaction",
      "reference": "Mediator–PIC scaffold",
      "notes": "Head/Middle modules contacting TBP and Pol II"
    },
    "coordinates": {
      "start": -35,
      "end": 12,
      "unit": "bp",
      "reference": "Relative to POLR2A +1",
      "confidence": 0.88
    },
    "strand": "plus",
    "recognitionSites": [
      {
        "name": "TFIID–Mediator interface",
        "start": -35,
        "end": -10,
        "sequence": "TAF1/Med17",
        "strand": "plus",
        "evidence": "Crosslinking MS",
        "notes": "Stabilises PIC assembly"
      },
      {
        "name": "Activator relay",
        "start": -200,
        "end": -60,
        "sequence": "Mediator tail",
        "strand": "plus",
        "evidence": "ChIA-PET loops",
        "notes": "Connects enhancer inputs"
      }
    ],
    "aliases": ["Mediator + GTF ensemble"],
    "timeline": { "phase": "assembly", "order": 2, "start": -35, "end": 12, "unit": "bp" },
    "evidence": ["Mediator cryo-EM (PDB 7ECC)", "Mediator-TFIID CLMS"],
    "references": ["https://doi.org/10.1038/s41467-022-28438-3"],
    "confidence": 0.85
  },
  {
    "id": "node:polii",
    "key": "polii",
    "layer": "factors",
    "x": 528,
    "y": 192,
    "width": 216,
    "height": 156,
    "frame": {
      "type": "protein",
      "reference": "Pol II–TFIIF/TFIIE/H open complex",
      "notes": "Clamp closed on template"
    },
    "coordinates": {
      "start": -3,
      "end": 35,
      "unit": "bp",
      "reference": "Template strand relative to +1",
      "confidence": 0.88
    },
    "strand": "plus",
    "recognitionSites": [
      {
        "name": "Active site cleft",
        "start": 1,
        "end": 9,
        "sequence": "RNA:DNA hybrid",
        "strand": "plus",
        "evidence": "Run-on assays",
        "notes": "Abortive products engage"
      },
      {
        "name": "TFIIB reader",
        "start": -3,
        "end": 5,
        "sequence": "B-finger",
        "strand": "plus",
        "evidence": "Cryo-EM densities",
        "notes": "Guides +1 alignment"
      }
    ],
    "aliases": ["Pol II-TFIIF-TFIIE/H"],
    "timeline": { "phase": "isomerization", "order": 3, "start": -3, "end": 12, "unit": "bp" },
    "evidence": ["TFIIE/TFIIH PIC (PDB 7E8S)", "In vitro run-on assays"],
    "references": ["https://doi.org/10.1126/science.abg3075"],
    "confidence": 0.88
  },
  {
    "id": "node:escape",
    "key": "escape",
    "layer": "rna",
    "x": 768,
    "y": 252,
    "width": 192,
    "height": 144,
    "frame": {
      "type": "transcript",
      "reference": "Promoter-proximal RNA",
      "notes": "Paused 20–60 nt"
    },
    "coordinates": {
      "start": 10,
      "end": 60,
      "unit": "nt",
      "reference": "Nascent RNA length",
      "confidence": 0.83
    },
    "strand": "plus",
    "recognitionSites": [
      {
        "name": "Pause element",
        "start": 20,
        "end": 40,
        "sequence": "G-rich pause",
        "strand": "plus",
        "evidence": "NET-seq",
        "notes": "NELF/DSIF engagement"
      }
    ],
    "aliases": ["Promoter escape window"],
    "timeline": { "phase": "escape", "order": 4, "start": 10, "end": 60, "unit": "nt" },
    "evidence": ["NET-seq pause maps", "P-TEFb release assays"],
    "references": ["https://doi.org/10.1038/nature14290"],
    "confidence": 0.82
  },
  {
    "id": "node:enhancer",
    "key": "enhancer",
    "layer": "annotations",
    "x": 288,
    "y": 48,
    "width": 216,
    "height": 120,
    "frame": {
      "type": "genomic",
      "assembly": "GRCh38",
      "chromosome": "chr17",
      "locus": "Upstream enhancer cluster",
      "reference": "chr17:74,615,000-74,616,200"
    },
    "coordinates": {
      "start": -2000,
      "end": -200,
      "unit": "bp",
      "reference": "Relative to POLR2A +1",
      "confidence": 0.7
    },
    "strand": "bidirectional",
    "recognitionSites": [
      {
        "name": "Activator hub",
        "start": -1800,
        "end": -1500,
        "sequence": "AP-1/ETS",
        "strand": "both",
        "evidence": "ATAC-seq peaks",
        "notes": "Mediator tail recruitment"
      },
      {
        "name": "Cohesin anchor",
        "start": -600,
        "end": -400,
        "sequence": "CTCF",
        "strand": "both",
        "evidence": "ChIA-PET",
        "notes": "Loop stabilisation"
      }
    ],
    "aliases": ["Enhancer loop cluster"],
    "timeline": { "phase": "assembly", "order": 0, "start": -2000, "end": -200, "unit": "bp" },
    "evidence": ["ChIA-PET Mediator loops", "ATAC-seq accessible chromatin"],
    "references": ["https://doi.org/10.1038/s41586-018-0173-5"],
    "confidence": 0.75
  },
  {
    "id": "node:ptefb",
    "key": "ptefb",
    "layer": "annotations",
    "x": 768,
    "y": 48,
    "width": 192,
    "height": 120,
    "frame": {
      "type": "regulatory",
      "reference": "P-TEFb pause-release module",
      "notes": "BRD4/SEC recruitment"
    },
    "coordinates": {
      "start": 20,
      "end": 120,
      "unit": "bp",
      "reference": "Pause-release window",
      "confidence": 0.78
    },
    "strand": "plus",
    "recognitionSites": [
      {
        "name": "NELF release",
        "start": 20,
        "end": 45,
        "sequence": "NELF-A interface",
        "strand": "plus",
        "evidence": "P-TEFb ChIP",
        "notes": "CDK9 phosphorylation"
      },
      {
        "name": "DSIF Ser2 phosphorylation",
        "start": 45,
        "end": 80,
        "sequence": "Spt5 repeats",
        "strand": "plus",
        "evidence": "Ser2P mapping",
        "notes": "Transitions into elongation"
      }
    ],
    "aliases": ["P-TEFb activation"],
    "timeline": { "phase": "escape", "order": 5, "start": 20, "end": 120, "unit": "bp" },
    "evidence": ["P-TEFb ChIP-seq", "BRD4 dependency assays"],
    "references": ["https://doi.org/10.1038/nature14290"],
    "confidence": 0.8
  }
];
      const EDGE_TEMPLATES = [
  {
    "id": "edge:chromatin-mediator",
    "key": "chromatinMediator",
    "from": "node:chromatin",
    "to": "node:mediator",
    "kind": "flow",
    "router": "orthogonal",
    "strand": "plus",
    "frame": {
      "type": "interaction",
      "reference": "TBP–Mediator handshake"
    },
    "coordinates": {
      "start": -35,
      "end": -10,
      "unit": "bp",
      "reference": "POLR2A core promoter",
      "confidence": 0.86
    },
    "recognitionSites": [
      {
        "name": "TBP–TAF1 contact",
        "start": -31,
        "end": -24,
        "sequence": "TATA",
        "strand": "plus",
        "evidence": "Cryo-EM PIC",
        "notes": "Mediator head engages TBP"
      }
    ],
    "timeline": { "phase": "assembly", "order": 1 },
    "evidence": ["Mediator recruitment assays"],
    "references": ["https://doi.org/10.1038/s41467-022-28438-3"],
    "confidence": 0.85
  },
  {
    "id": "edge:mediator-polii",
    "key": "mediatorPolii",
    "from": "node:mediator",
    "to": "node:polii",
    "kind": "flow",
    "router": "orthogonal",
    "strand": "plus",
    "frame": {
      "type": "interaction",
      "reference": "Mediator to Pol II core"
    },
    "coordinates": {
      "start": -12,
      "end": 5,
      "unit": "bp",
      "reference": "Template strand",
      "confidence": 0.84
    },
    "recognitionSites": [
      {
        "name": "Med14 latch",
        "start": -12,
        "end": -4,
        "sequence": "Med14 loop",
        "strand": "plus",
        "evidence": "Cryo-EM",
        "notes": "Stabilises closed clamp"
      }
    ],
    "timeline": { "phase": "assembly", "order": 2 },
    "evidence": ["Mediator–Pol II biochemical reconstitution"],
    "references": ["https://doi.org/10.1126/science.abf6735"],
    "confidence": 0.84
  },
  {
    "id": "edge:polii-escape",
    "key": "poliiEscape",
    "from": "node:polii",
    "to": "node:escape",
    "kind": "flow",
    "router": "orthogonal",
    "strand": "plus",
    "frame": {
      "type": "interaction",
      "reference": "Catalysis to promoter escape"
    },
    "coordinates": {
      "start": 1,
      "end": 25,
      "unit": "nt",
      "reference": "Nascent RNA length",
      "confidence": 0.82
    },
    "recognitionSites": [
      {
        "name": "Early RNA hybrid",
        "start": 1,
        "end": 9,
        "sequence": "rAUGG",
        "strand": "plus",
        "evidence": "Abortive transcripts",
        "notes": "Determines escape efficiency"
      }
    ],
    "timeline": { "phase": "initiation", "order": 3 },
    "evidence": ["Abortive transcription assays"],
    "references": ["https://doi.org/10.1038/nature14290"],
    "confidence": 0.82
  },
  {
    "id": "edge:enhancer-mediator",
    "key": "enhancerMediator",
    "from": "node:enhancer",
    "to": "node:mediator",
    "kind": "regulation",
    "router": "orthogonal",
    "strand": "bidirectional",
    "frame": {
      "type": "interaction",
      "reference": "Enhancer loop delivery"
    },
    "coordinates": {
      "start": -2000,
      "end": -200,
      "unit": "bp",
      "reference": "Enhancer span",
      "confidence": 0.72
    },
    "recognitionSites": [
      {
        "name": "Mediator tail hub",
        "start": -900,
        "end": -450,
        "sequence": "Tail modules",
        "strand": "both",
        "evidence": "Mediator ChIA-PET",
        "notes": "Bridges enhancer to core"
      }
    ],
    "markers": {
      "end": "arrow-regulation"
    },
    "timeline": { "phase": "assembly", "order": 0 },
    "evidence": ["Enhancer loop capture"],
    "references": ["https://doi.org/10.1038/s41586-018-0173-5"],
    "confidence": 0.75
  },
  {
    "id": "edge:ptefb-escape",
    "key": "ptefbEscape",
    "from": "node:ptefb",
    "to": "node:escape",
    "kind": "regulation",
    "router": "orthogonal",
    "strand": "plus",
    "frame": {
      "type": "interaction",
      "reference": "P-TEFb pause release"
    },
    "coordinates": {
      "start": 20,
      "end": 60,
      "unit": "nt",
      "reference": "Pause window",
      "confidence": 0.8
    },
    "recognitionSites": [
      {
        "name": "Ser2 CTD phosphorylation",
        "start": 20,
        "end": 60,
        "sequence": "YS2P repeats",
        "strand": "plus",
        "evidence": "ChIP-seq Ser2P",
        "notes": "Releases DSIF/NELF"
      }
    ],
    "markers": {
      "end": "arrow-regulation"
    },
    "timeline": { "phase": "escape", "order": 5 },
    "evidence": ["P-TEFb kinase assays"],
    "references": ["https://doi.org/10.1038/nature14290"],
    "confidence": 0.8
  }
];

      const PRESET_VARIANTS = {
        'tssMini.prokaryote': {
          nodes: [
            { id: 'node:tss-pro:promoter', localePath: 'presets.tssMini.prokaryote.nodes.promoter', layer: 'chromatin', x: 48, y: 210, width: 216, height: 120 },
            { id: 'node:tss-pro:rnap', localePath: 'presets.tssMini.prokaryote.nodes.holoenzyme', layer: 'factors', x: 288, y: 192, width: 216, height: 132 },
            { id: 'node:tss-pro:open', localePath: 'presets.tssMini.prokaryote.nodes.openComplex', layer: 'factors', x: 528, y: 180, width: 216, height: 132 },
            { id: 'node:tss-pro:clearance', localePath: 'presets.tssMini.prokaryote.nodes.clearance', layer: 'rna', x: 768, y: 228, width: 192, height: 120 }
          ],
          edges: [
            { id: 'edge:tss-pro:promoter-rnap', localePath: 'presets.tssMini.prokaryote.edges.promoterToRnap', from: 'node:tss-pro:promoter', to: 'node:tss-pro:rnap', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:tss-pro:rnap-open', localePath: 'presets.tssMini.prokaryote.edges.rnapToOpen', from: 'node:tss-pro:rnap', to: 'node:tss-pro:open', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:tss-pro:open-clearance', localePath: 'presets.tssMini.prokaryote.edges.openToClearance', from: 'node:tss-pro:open', to: 'node:tss-pro:clearance', kind: 'flow', router: 'orthogonal' }
          ]
        },
        'tssMini.virus': {
          nodes: [
            { id: 'node:tss-vir:chromatin', localePath: 'presets.tssMini.virus.nodes.hostChromatin', layer: 'chromatin', x: 48, y: 210, width: 216, height: 120 },
            { id: 'node:tss-vir:viralFactors', localePath: 'presets.tssMini.virus.nodes.viralFactors', layer: 'factors', x: 288, y: 168, width: 216, height: 132 },
            { id: 'node:tss-vir:polii', localePath: 'presets.tssMini.virus.nodes.hostPol', layer: 'factors', x: 528, y: 186, width: 216, height: 132 },
            { id: 'node:tss-vir:escape', localePath: 'presets.tssMini.virus.nodes.release', layer: 'rna', x: 768, y: 228, width: 192, height: 120 }
          ],
          edges: [
            { id: 'edge:tss-vir:chromatin-factors', localePath: 'presets.tssMini.virus.edges.chromatinToFactors', from: 'node:tss-vir:chromatin', to: 'node:tss-vir:viralFactors', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-regulation' } },
            { id: 'edge:tss-vir:factors-polii', localePath: 'presets.tssMini.virus.edges.factorsToPol', from: 'node:tss-vir:viralFactors', to: 'node:tss-vir:polii', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:tss-vir:polii-escape', localePath: 'presets.tssMini.virus.edges.polToEscape', from: 'node:tss-vir:polii', to: 'node:tss-vir:escape', kind: 'flow', router: 'orthogonal' }
          ]
        },
        'exonIntron.eukaryote': {
          nodes: [
            { id: 'node:exonmap:promoter', localePath: 'presets.exonIntron.eukaryote.nodes.promoter', layer: 'chromatin', x: 48, y: 210, width: 216, height: 120 },
            { id: 'node:exonmap:exon1', localePath: 'presets.exonIntron.eukaryote.nodes.exon1', layer: 'rna', x: 288, y: 156, width: 216, height: 120 },
            { id: 'node:exonmap:intron', localePath: 'presets.exonIntron.eukaryote.nodes.intron', layer: 'annotations', x: 528, y: 228, width: 216, height: 120 },
            { id: 'node:exonmap:exon2', localePath: 'presets.exonIntron.eukaryote.nodes.exon2', layer: 'rna', x: 768, y: 156, width: 192, height: 120 },
            { id: 'node:exonmap:splice', localePath: 'presets.exonIntron.eukaryote.nodes.splicing', layer: 'factors', x: 528, y: 48, width: 216, height: 120 }
          ],
          edges: [
            { id: 'edge:exonmap:promoter-exon1', localePath: 'presets.exonIntron.eukaryote.edges.promoterToExon1', from: 'node:exonmap:promoter', to: 'node:exonmap:exon1', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:exonmap:exon1-intron', localePath: 'presets.exonIntron.eukaryote.edges.exon1ToIntron', from: 'node:exonmap:exon1', to: 'node:exonmap:intron', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:exonmap:intron-exon2', localePath: 'presets.exonIntron.eukaryote.edges.intronToExon2', from: 'node:exonmap:intron', to: 'node:exonmap:exon2', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:exonmap:splice-intron', localePath: 'presets.exonIntron.eukaryote.edges.splicingControl', from: 'node:exonmap:splice', to: 'node:exonmap:intron', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-regulation' } }
          ]
        },
        'exonIntron.prokaryote': {
          nodes: [
            { id: 'node:exonmap-pro:leader', localePath: 'presets.exonIntron.prokaryote.nodes.leader', layer: 'chromatin', x: 48, y: 210, width: 216, height: 120 },
            { id: 'node:exonmap-pro:coding', localePath: 'presets.exonIntron.prokaryote.nodes.coding', layer: 'rna', x: 288, y: 210, width: 216, height: 120 },
            { id: 'node:exonmap-pro:terminator', localePath: 'presets.exonIntron.prokaryote.nodes.terminator', layer: 'annotations', x: 528, y: 210, width: 216, height: 120 },
            { id: 'node:exonmap-pro:processing', localePath: 'presets.exonIntron.prokaryote.nodes.processing', layer: 'factors', x: 768, y: 180, width: 192, height: 120 }
          ],
          edges: [
            { id: 'edge:exonmap-pro:leader-coding', localePath: 'presets.exonIntron.prokaryote.edges.leaderToCoding', from: 'node:exonmap-pro:leader', to: 'node:exonmap-pro:coding', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:exonmap-pro:coding-terminator', localePath: 'presets.exonIntron.prokaryote.edges.codingToTerminator', from: 'node:exonmap-pro:coding', to: 'node:exonmap-pro:terminator', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:exonmap-pro:terminator-processing', localePath: 'presets.exonIntron.prokaryote.edges.terminatorToProcessing', from: 'node:exonmap-pro:terminator', to: 'node:exonmap-pro:processing', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-flow' } }
          ]
        },
        'exonIntron.virus': {
          nodes: [
            { id: 'node:exonmap-vir:donor', localePath: 'presets.exonIntron.virus.nodes.donor', layer: 'chromatin', x: 48, y: 210, width: 216, height: 120 },
            { id: 'node:exonmap-vir:intronic', localePath: 'presets.exonIntron.virus.nodes.intronic', layer: 'annotations', x: 288, y: 120, width: 216, height: 120 },
            { id: 'node:exonmap-vir:acceptor', localePath: 'presets.exonIntron.virus.nodes.acceptor', layer: 'rna', x: 528, y: 210, width: 216, height: 120 },
            { id: 'node:exonmap-vir:export', localePath: 'presets.exonIntron.virus.nodes.export', layer: 'factors', x: 768, y: 180, width: 192, height: 120 }
          ],
          edges: [
            { id: 'edge:exonmap-vir:donor-intronic', localePath: 'presets.exonIntron.virus.edges.donorToIntronic', from: 'node:exonmap-vir:donor', to: 'node:exonmap-vir:intronic', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:exonmap-vir:intronic-acceptor', localePath: 'presets.exonIntron.virus.edges.intronicToAcceptor', from: 'node:exonmap-vir:intronic', to: 'node:exonmap-vir:acceptor', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:exonmap-vir:acceptor-export', localePath: 'presets.exonIntron.virus.edges.acceptorToExport', from: 'node:exonmap-vir:acceptor', to: 'node:exonmap-vir:export', kind: 'flow', router: 'orthogonal' }
          ]
        },
        'operon.eukaryote': {
          nodes: [
            { id: 'node:operon-euk:enhancer', localePath: 'presets.operon.eukaryote.nodes.enhancer', layer: 'annotations', x: 48, y: 108, width: 216, height: 120 },
            { id: 'node:operon-euk:promoter', localePath: 'presets.operon.eukaryote.nodes.promoter', layer: 'chromatin', x: 288, y: 210, width: 216, height: 120 },
            { id: 'node:operon-euk:poly', localePath: 'presets.operon.eukaryote.nodes.polycistronic', layer: 'rna', x: 528, y: 210, width: 216, height: 120 },
            { id: 'node:operon-euk:processing', localePath: 'presets.operon.eukaryote.nodes.processing', layer: 'factors', x: 768, y: 180, width: 192, height: 120 }
          ],
          edges: [
            { id: 'edge:operon-euk:enhancer-promoter', localePath: 'presets.operon.eukaryote.edges.enhancerToPromoter', from: 'node:operon-euk:enhancer', to: 'node:operon-euk:promoter', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-regulation' } },
            { id: 'edge:operon-euk:promoter-poly', localePath: 'presets.operon.eukaryote.edges.promoterToPoly', from: 'node:operon-euk:promoter', to: 'node:operon-euk:poly', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:operon-euk:poly-processing', localePath: 'presets.operon.eukaryote.edges.polyToProcessing', from: 'node:operon-euk:poly', to: 'node:operon-euk:processing', kind: 'flow', router: 'orthogonal' }
          ]
        },
        'operon.prokaryote': {
          nodes: [
            { id: 'node:operon-pro:operator', localePath: 'presets.operon.prokaryote.nodes.operator', layer: 'chromatin', x: 48, y: 210, width: 216, height: 120 },
            { id: 'node:operon-pro:rnap', localePath: 'presets.operon.prokaryote.nodes.rnap', layer: 'factors', x: 288, y: 210, width: 216, height: 120 },
            { id: 'node:operon-pro:genes', localePath: 'presets.operon.prokaryote.nodes.genes', layer: 'rna', x: 528, y: 210, width: 216, height: 120 },
            { id: 'node:operon-pro:attenuation', localePath: 'presets.operon.prokaryote.nodes.attenuation', layer: 'annotations', x: 768, y: 108, width: 192, height: 120 }
          ],
          edges: [
            { id: 'edge:operon-pro:operator-rnap', localePath: 'presets.operon.prokaryote.edges.operatorToRnap', from: 'node:operon-pro:operator', to: 'node:operon-pro:rnap', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-regulation' } },
            { id: 'edge:operon-pro:rnap-genes', localePath: 'presets.operon.prokaryote.edges.rnapToGenes', from: 'node:operon-pro:rnap', to: 'node:operon-pro:genes', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:operon-pro:genes-attenuation', localePath: 'presets.operon.prokaryote.edges.genesToAttenuation', from: 'node:operon-pro:genes', to: 'node:operon-pro:attenuation', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:operon-pro:attenuation-rnap', localePath: 'presets.operon.prokaryote.edges.attenuationToRnap', from: 'node:operon-pro:attenuation', to: 'node:operon-pro:rnap', kind: 'regulation', router: 'orthogonal', markers: { end: 'tee-regulation' } }
          ]
        },
        'operon.virus': {
          nodes: [
            { id: 'node:operon-vir:ltr', localePath: 'presets.operon.virus.nodes.ltr', layer: 'chromatin', x: 48, y: 210, width: 216, height: 120 },
            { id: 'node:operon-vir:polymerase', localePath: 'presets.operon.virus.nodes.polymerase', layer: 'factors', x: 288, y: 186, width: 216, height: 120 },
            { id: 'node:operon-vir:polyprotein', localePath: 'presets.operon.virus.nodes.polyprotein', layer: 'rna', x: 528, y: 210, width: 216, height: 120 },
            { id: 'node:operon-vir:frameshift', localePath: 'presets.operon.virus.nodes.frameshift', layer: 'annotations', x: 768, y: 132, width: 192, height: 120 }
          ],
          edges: [
            { id: 'edge:operon-vir:ltr-polymerase', localePath: 'presets.operon.virus.edges.ltrToPolymerase', from: 'node:operon-vir:ltr', to: 'node:operon-vir:polymerase', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:operon-vir:polymerase-polyprotein', localePath: 'presets.operon.virus.edges.polymeraseToPolyprotein', from: 'node:operon-vir:polymerase', to: 'node:operon-vir:polyprotein', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:operon-vir:polyprotein-frameshift', localePath: 'presets.operon.virus.edges.polyproteinToFrameshift', from: 'node:operon-vir:polyprotein', to: 'node:operon-vir:frameshift', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-regulation' } }
          ]
        },
        'library.eukaryote': {
          nodes: [
            { id: 'node:library-euk:factors', localePath: 'presets.library.eukaryote.nodes.factors', layer: 'factors', x: 72, y: 168, width: 216, height: 120 },
            { id: 'node:library-euk:coactivators', localePath: 'presets.library.eukaryote.nodes.coactivators', layer: 'annotations', x: 312, y: 108, width: 216, height: 120 },
            { id: 'node:library-euk:pause', localePath: 'presets.library.eukaryote.nodes.pause', layer: 'rna', x: 552, y: 210, width: 216, height: 120 },
            { id: 'node:library-euk:elongation', localePath: 'presets.library.eukaryote.nodes.elongation', layer: 'factors', x: 768, y: 168, width: 168, height: 120 }
          ],
          edges: [
            { id: 'edge:library-euk:factors-coactivators', localePath: 'presets.library.eukaryote.edges.factorsToCoactivators', from: 'node:library-euk:factors', to: 'node:library-euk:coactivators', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-regulation' } },
            { id: 'edge:library-euk:coactivators-pause', localePath: 'presets.library.eukaryote.edges.coactivatorsToPause', from: 'node:library-euk:coactivators', to: 'node:library-euk:pause', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:library-euk:pause-elongation', localePath: 'presets.library.eukaryote.edges.pauseToElongation', from: 'node:library-euk:pause', to: 'node:library-euk:elongation', kind: 'flow', router: 'orthogonal' }
          ]
        },
        'library.prokaryote': {
          nodes: [
            { id: 'node:library-pro:sigma', localePath: 'presets.library.prokaryote.nodes.sigma', layer: 'factors', x: 72, y: 168, width: 216, height: 120 },
            { id: 'node:library-pro:remodeling', localePath: 'presets.library.prokaryote.nodes.remodeling', layer: 'chromatin', x: 312, y: 198, width: 216, height: 120 },
            { id: 'node:library-pro:termination', localePath: 'presets.library.prokaryote.nodes.termination', layer: 'annotations', x: 552, y: 198, width: 216, height: 120 },
            { id: 'node:library-pro:stress', localePath: 'presets.library.prokaryote.nodes.stress', layer: 'factors', x: 792, y: 138, width: 168, height: 120 }
          ],
          edges: [
            { id: 'edge:library-pro:sigma-remodeling', localePath: 'presets.library.prokaryote.edges.sigmaToRemodeling', from: 'node:library-pro:sigma', to: 'node:library-pro:remodeling', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:library-pro:remodeling-termination', localePath: 'presets.library.prokaryote.edges.remodelingToTermination', from: 'node:library-pro:remodeling', to: 'node:library-pro:termination', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:library-pro:stress-termination', localePath: 'presets.library.prokaryote.edges.stressToTermination', from: 'node:library-pro:stress', to: 'node:library-pro:termination', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-regulation' } }
          ]
        },
        'library.virus': {
          nodes: [
            { id: 'node:library-vir:entry', localePath: 'presets.library.virus.nodes.entry', layer: 'chromatin', x: 72, y: 210, width: 216, height: 120 },
            { id: 'node:library-vir:host', localePath: 'presets.library.virus.nodes.hostFactors', layer: 'factors', x: 312, y: 168, width: 216, height: 120 },
            { id: 'node:library-vir:polymerase', localePath: 'presets.library.virus.nodes.polymerase', layer: 'factors', x: 552, y: 210, width: 216, height: 120 },
            { id: 'node:library-vir:switching', localePath: 'presets.library.virus.nodes.switching', layer: 'annotations', x: 792, y: 150, width: 168, height: 120 }
          ],
          edges: [
            { id: 'edge:library-vir:entry-host', localePath: 'presets.library.virus.edges.entryToHost', from: 'node:library-vir:entry', to: 'node:library-vir:host', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:library-vir:host-polymerase', localePath: 'presets.library.virus.edges.hostToPolymerase', from: 'node:library-vir:host', to: 'node:library-vir:polymerase', kind: 'flow', router: 'orthogonal' },
            { id: 'edge:library-vir:polymerase-switching', localePath: 'presets.library.virus.edges.polymeraseToSwitching', from: 'node:library-vir:polymerase', to: 'node:library-vir:switching', kind: 'regulation', router: 'orthogonal', markers: { end: 'arrow-regulation' } }
          ]
        }
      };

      const PRESETS = {
        tssMini: {
          topicKeywords: ['transcription initiation (pol ii, +1 tss)', 'tss', 'tss+1', '+1 tss'],
          aliases: ['tss-mini', 'tss_plus1'],
          orgs: {
            eukaryote: () => ({
              nodes: NODE_TEMPLATES.map(createLocalizedNode),
              edges: EDGE_TEMPLATES.map(createLocalizedEdge)
            }),
            prokaryote: () => buildPresetVariant('tssMini.prokaryote'),
            virus: () => buildPresetVariant('tssMini.virus')
          }
        },
        exonIntron: {
          topicKeywords: ['exon', 'intron', 'splicing', 'exon–intron map'],
          aliases: ['exon-map', 'exon_intron', 'exon-intron'],
          orgs: {
            eukaryote: () => buildPresetVariant('exonIntron.eukaryote'),
            prokaryote: () => buildPresetVariant('exonIntron.prokaryote'),
            virus: () => buildPresetVariant('exonIntron.virus')
          }
        },
        operon: {
          topicKeywords: ['operon', 'polycistronic'],
          aliases: ['operon-map'],
          orgs: {
            eukaryote: () => buildPresetVariant('operon.eukaryote'),
            prokaryote: () => buildPresetVariant('operon.prokaryote'),
            virus: () => buildPresetVariant('operon.virus')
          }
        },
        library: {
          topicKeywords: ['extended library', 'module library', 'factor library'],
          aliases: ['extended-library', 'library-extended'],
          orgs: {
            eukaryote: () => buildPresetVariant('library.eukaryote'),
            prokaryote: () => buildPresetVariant('library.prokaryote'),
            virus: () => buildPresetVariant('library.virus')
          }
        }
      };

      const ORG_ALIASES = {
        eukaryote: ['euk', 'euka', 'eukaryotic', 'eukaryota', 'eukaryotes'],
        prokaryote: ['prok', 'prokaryotes', 'bacteria', 'bacterial', 'archaea'],
        virus: ['viral', 'vir', 'viruses', 'phage']
      };

      function buildPresetVariant(key) {
        const variant = PRESET_VARIANTS[key];
        if (!variant) return { nodes: [], edges: [] };
        const nodes = Array.isArray(variant.nodes) ? variant.nodes.map(createPresetNode) : [];
        const edges = Array.isArray(variant.edges) ? variant.edges.map(createPresetEdge) : [];
        return { nodes, edges };
      }

      function createPresetNode(template) {
        const entry = template.localePath ? getLocaleEntry(template.localePath) : null;
        const baseNotes = Array.isArray(template.notes) ? template.notes.slice() : [];
        const notes = Array.isArray(entry?.notes) ? entry.notes.map(note => String(note)) : baseNotes;
        const node = {
          id: template.id,
          label: typeof entry?.label === 'string' ? entry.label : template.label || '',
          type: typeof entry?.type === 'string' ? entry.type : template.type || '',
          layer: template.layer,
          x: template.x,
          y: template.y,
          width: template.width,
          height: template.height,
          notes,
          z: template.z,
          frame: entry?.frame ?? template.frame,
          coordinates: entry?.coordinates ?? template.coordinates,
          strand: entry?.strand ?? template.strand,
          recognitionSites: entry?.recognitionSites ?? template.recognitionSites,
          aliases: entry?.aliases ?? template.aliases,
          timeline: entry?.timeline ?? template.timeline,
          evidence: entry?.evidence ?? template.evidence,
          references: entry?.references ?? template.references,
          confidence: entry?.confidence ?? template.confidence
        };
        return cloneNode(node);
      }

      function createPresetEdge(template) {
        const entry = template.localePath ? getLocaleEntry(template.localePath) : null;
        const edge = {
          id: template.id,
          from: template.from,
          to: template.to,
          kind: template.kind || 'flow',
          router: template.router || 'orthogonal',
          label: typeof entry?.label === 'string' ? entry.label : template.label || '',
          markers: template.markers,
          frame: entry?.frame ?? template.frame,
          coordinates: entry?.coordinates ?? template.coordinates,
          strand: entry?.strand ?? template.strand,
          recognitionSites: entry?.recognitionSites ?? template.recognitionSites,
          timeline: entry?.timeline ?? template.timeline,
          evidence: entry?.evidence ?? template.evidence,
          references: entry?.references ?? template.references,
          confidence: entry?.confidence ?? template.confidence
        };
        return cloneEdge(edge);
      }

      function createLocalizedNode(template) {
        const nodeStrings = getLocaleEntry(`nodes.${template.key}`) || {};
        const notes = Array.isArray(nodeStrings.notes) ? nodeStrings.notes.map(note => String(note)) : [];
        const node = {
          id: template.id,
          label: typeof nodeStrings.label === 'string' ? nodeStrings.label : '',
          type: typeof nodeStrings.type === 'string' ? nodeStrings.type : '',
          layer: template.layer,
          x: template.x,
          y: template.y,
          width: template.width,
          height: template.height,
          notes,
          z: template.z,
          frame: nodeStrings.frame ?? template.frame,
          coordinates: nodeStrings.coordinates ?? template.coordinates,
          strand: nodeStrings.strand ?? template.strand,
          recognitionSites: nodeStrings.recognitionSites ?? template.recognitionSites,
          aliases: nodeStrings.aliases ?? template.aliases,
          timeline: nodeStrings.timeline ?? template.timeline,
          evidence: nodeStrings.evidence ?? template.evidence,
          references: nodeStrings.references ?? template.references,
          confidence: nodeStrings.confidence ?? template.confidence
        };
        return cloneNode(node);
      }

      function createLocalizedEdge(template) {
        const entry = getLocaleEntry(`edges.${template.key}`);
        const edge = {
          id: template.id,
          from: template.from,
          to: template.to,
          kind: template.kind || 'flow',
          router: template.router || 'orthogonal',
          label: typeof entry === 'string' ? entry : template.label || '',
          markers: template.markers,
          frame: template.frame,
          coordinates: template.coordinates,
          strand: template.strand,
          recognitionSites: template.recognitionSites,
          timeline: template.timeline,
          evidence: template.evidence,
          references: template.references,
          confidence: template.confidence
        };
        return cloneEdge(edge);
      }

      const state = {
        nodes: new Map(),
        edges: []
      };
      const edgeElements = new Map();

      let scale = 1;
      let pan = { x: 0, y: 0 };
      let gridSnapEnabled = true;
      let gridVisible = true;
      let isPanning = false;
      let panPointerId = null;
      let initialTransformRestored = false;

      const mapCanvas = document.getElementById('map-canvas');
      const mapViewport = document.getElementById('map-viewport');
      const nodeLayer = document.getElementById('node-layer');
      const edgeLayer = document.getElementById('edge-layer');
      const toggleGridButton = document.getElementById('toggle-grid');
      const snapCheckbox = document.getElementById('snap-to-grid');
      const fitToViewButton = document.getElementById('fit-to-view');
      const resetOverlapButton = document.getElementById('reset-overlap');
      const resetLayoutButton = document.getElementById('reset-layout');
      const exportJsonButton = document.getElementById('export-json');
      const importJsonButton = document.getElementById('import-json');
      const importFileInput = document.getElementById('import-file');
      const exportSvgButton = document.getElementById('export-svg');
      const exportPngButton = document.getElementById('export-png');
      const exportPdfButton = document.getElementById('export-pdf');
      const presetSelect = document.getElementById('preset-select');
      const orgSelect = document.getElementById('org-select');
      const presetControl = document.getElementById('preset-control');
      const orgControl = document.getElementById('org-control');
      const languageSwitch = document.getElementById('language-switch');

      setupLanguageSwitch();
      applyStaticText();
      setupPresetSystem();
      init();
      setupTimeline();
      setupOverlay();
      setupModelTabs();

      function init() {
        renderNodes();
        if (initialTransformRestored) {
          applyTransform();
        } else {
          fitToView();
        }
        updateEdges();
        wireControls();
      }

      function wireControls() {
        toggleGridButton.addEventListener('click', () => {
          gridVisible = !gridVisible;
          mapCanvas.classList.toggle('no-grid', !gridVisible);
          toggleGridButton.classList.toggle('active', gridVisible);
          toggleGridButton.setAttribute('aria-pressed', String(gridVisible));
          persistState();
        });

        snapCheckbox.addEventListener('change', () => {
          gridSnapEnabled = snapCheckbox.checked;
          persistState();
        });

        fitToViewButton.addEventListener('click', () => {
          fitToView();
          persistState();
        });

        resetOverlapButton.addEventListener('click', () => {
          resolveAllOverlaps();
          renderNodes();
          updateEdges();
          persistState();
        });

        resetLayoutButton.addEventListener('click', () => {
          if (storageKey) {
            localStorage.removeItem(storageKey);
          }
          scale = 1;
          pan = { x: 0, y: 0 };
          gridVisible = true;
          gridSnapEnabled = true;
          toggleGridButton.classList.add('active');
          toggleGridButton.setAttribute('aria-pressed', 'true');
          snapCheckbox.checked = true;
          mapCanvas.classList.remove('no-grid');
          state.nodes = new Map(presetNodes.map(node => [node.id, cloneNode(node)]));
          state.edges = presetEdges.map(edge => cloneEdge(edge));
          renderNodes();
          applyTransform();
          updateEdges();
          persistState();
        });

        if (presetSelect) {
          presetSelect.addEventListener('change', () => {
            const nextPreset = presetSelect.value || activePresetKey;
            const nextOrg = orgSelect && PRESETS[nextPreset]?.orgs?.[orgSelect.value]
              ? orgSelect.value
              : getDefaultOrgKey(nextPreset);
            applyPreset(nextPreset, nextOrg);
          });
        }

        if (orgSelect) {
          orgSelect.addEventListener('change', () => {
            applyPreset(activePresetKey, orgSelect.value || activeOrgKey);
          });
        }

        exportJsonButton.addEventListener('click', () => {
          const payload = exportState();
          download(buildExportFilename('json'), JSON.stringify(payload, null, 2), 'application/json');
        });

        importJsonButton.addEventListener('click', () => {
          importFileInput.click();
        });

        importFileInput.addEventListener('change', handleImportFile);

        exportSvgButton.addEventListener('click', () => {
          const svgMarkup = buildExportSvg();
          download(buildExportFilename('svg'), `<?xml version="1.0" encoding="UTF-8"?>\n${svgMarkup}`, 'image/svg+xml;charset=utf-8');
        });

        exportPngButton.addEventListener('click', () => {
          const svgMarkup = buildExportSvg();
          const blob = new Blob([svgMarkup], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const img = new Image();
          img.decoding = 'async';
          const canvas = document.createElement('canvas');
          const scale = EXPORT_DPI / CSS_PX_PER_INCH;
          canvas.width = Math.round(MAP_WIDTH * scale);
          canvas.height = Math.round(MAP_HEIGHT * scale);
          const ctx = canvas.getContext('2d');
          img.onload = () => {
            ctx.setTransform(scale, 0, 0, scale, 0, 0);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
            ctx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);
            canvas.toBlob(result => {
              if (result) {
                download(buildExportFilename('png'), result, 'image/png');
              } else {
                handlePngFallback(svgMarkup);
              }
            }, 'image/png');
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            handlePngFallback(svgMarkup);
          };
          img.src = url;
        });

        exportPdfButton.addEventListener('click', () => {
          window.print();
        });

        mapCanvas.addEventListener('wheel', handleWheel, { passive: false });
        mapCanvas.addEventListener('pointerdown', handlePanStart);
        mapCanvas.addEventListener('pointermove', handlePanMove);
        mapCanvas.addEventListener('pointerup', handlePanEnd);
        mapCanvas.addEventListener('pointercancel', handlePanEnd);
        mapCanvas.addEventListener('keydown', handleCanvasKeydown);
      }

      function applyPreset(nextPresetKey, nextOrgKey, options = {}) {
        const presetKey = PRESETS[nextPresetKey] ? nextPresetKey : activePresetKey;
        const fallbackPreset = PRESETS[presetKey] ? presetKey : 'tssMini';
        const preset = PRESETS[fallbackPreset];
        const orgEntries = preset?.orgs || {};
        const resolvedOrg = orgEntries[nextOrgKey] ? nextOrgKey : getDefaultOrgKey(fallbackPreset);
        const builder = orgEntries[resolvedOrg];
        const result = typeof builder === 'function' ? builder() : { nodes: [], edges: [] };
        const baseNodes = Array.isArray(result.nodes) ? result.nodes : [];
        const baseEdges = Array.isArray(result.edges) ? result.edges : [];

        presetNodes = baseNodes.map(node => cloneNode(node));
        presetEdges = baseEdges.map(edge => cloneEdge(edge));

        activePresetKey = fallbackPreset;
        activeOrgKey = resolvedOrg;
        storageKey = buildStorageKey(activePresetKey, activeOrgKey);

        if (!options.preserveTransform) {
          scale = 1;
          pan = { x: 0, y: 0 };
        }
        if (!options.preserveGrid) {
          gridVisible = true;
          gridSnapEnabled = true;
        }

        state.nodes = new Map(presetNodes.map(node => [node.id, cloneNode(node)]));
        state.edges = presetEdges.map(edge => cloneEdge(edge));

        let restored = false;
        if (!options.skipRestore) {
          restored = restoreState();
        } else {
          applyGridPreferences();
        }

        if (!options.skipRender) {
          renderNodes();
          if (restored || options.preserveTransform) {
            applyTransform();
          } else {
            fitToView();
          }
          updateEdges();
        }

        if (!options.skipPersist) {
          persistState();
        }

        updatePresetControlValues();
        return restored;
      }

      function buildStorageKey(presetKey, orgKey) {
        const presetPart = compactKey(presetKey || 'default') || 'default';
        const orgPart = compactKey(orgKey || 'any') || 'any';
        return `${STORAGE_KEY_BASE}:${presetPart}:${orgPart}`;
      }

      function buildExportFilename(extension) {
        const presetPart = compactKey(activePresetKey) || 'default';
        const orgPart = compactKey(activeOrgKey) || 'any';
        const ext = extension.replace(/^\.+/, '');
        return `${EXPORT_BASE_NAME}__${presetPart}.${orgPart}.${ext}`;
      }

      function setupPresetSystem() {
        populatePresetOptions();
        const initial = resolveInitialSelection();
        initialTransformRestored = applyPreset(initial.presetKey, initial.orgKey, { skipRender: true, skipPersist: true });
      }

      function populatePresetOptions() {
        if (!presetSelect) return;
        const previous = presetSelect.value;
        presetSelect.innerHTML = '';
        Object.keys(PRESETS).forEach(key => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = getLocaleString(`map.presets.options.${key}`) || key;
          presetSelect.appendChild(option);
        });
        if (previous && Array.from(presetSelect.options).some(option => option.value === previous)) {
          presetSelect.value = previous;
        }
      }

      function populateOrgOptions(presetKey) {
        if (!orgSelect) return;
        const preset = PRESETS[presetKey];
        const previous = orgSelect.value;
        orgSelect.innerHTML = '';
        if (!preset) return;
        Object.keys(preset.orgs || {}).forEach(key => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = getLocaleString(`map.presets.orgOptions.${key}`) || key;
          orgSelect.appendChild(option);
        });
        if (previous && Array.from(orgSelect.options).some(option => option.value === previous)) {
          orgSelect.value = previous;
        }
      }

      function updatePresetControlValues() {
        if (presetSelect) {
          if (!Array.from(presetSelect.options).some(option => option.value === activePresetKey)) {
            populatePresetOptions();
          }
          presetSelect.value = activePresetKey;
        }
        if (orgSelect) {
          populateOrgOptions(activePresetKey);
          if (Array.from(orgSelect.options).some(option => option.value === activeOrgKey)) {
            orgSelect.value = activeOrgKey;
          } else {
            orgSelect.value = getDefaultOrgKey(activePresetKey);
          }
        }
        if (orgControl) {
          orgControl.classList.toggle('disabled', !orgSelect || orgSelect.options.length <= 1);
        }
      }

      function resolveInitialSelection() {
        const params = new URLSearchParams(window.location.search);
        const topicValue = getParamCaseInsensitive(params, 'topic', 'preset', 'schema', 'module');
        const orgValue = getParamCaseInsensitive(params, 'org', 'organism', 'species');
        let presetKey = matchPreset(topicValue) || matchPreset(getLocaleString('page.header.title')) || activePresetKey;
        if (!PRESETS[presetKey]) {
          presetKey = 'tssMini';
        }
        let orgKey = matchOrg(orgValue) || activeOrgKey;
        if (!PRESETS[presetKey]?.orgs?.[orgKey]) {
          orgKey = getDefaultOrgKey(presetKey);
        }
        return { presetKey, orgKey };
      }

      function getParamCaseInsensitive(params, ...names) {
        for (const name of names) {
          if (!name) continue;
          if (params.has(name)) return params.get(name);
          const lower = name.toLowerCase();
          if (params.has(lower)) return params.get(lower);
          const upper = name.toUpperCase();
          if (params.has(upper)) return params.get(upper);
        }
        return null;
      }

      function matchPreset(value) {
        const normalized = normalizeForMatch(value);
        if (!normalized) return null;
        for (const [key, preset] of Object.entries(PRESETS)) {
          if (valueMatches(normalized, key)) return key;
          if (preset.aliases?.some(alias => valueMatches(normalized, alias))) return key;
          if (preset.topicKeywords?.some(keyword => includesMatch(normalized, keyword))) return key;
        }
        return null;
      }

      function matchOrg(value) {
        const normalized = normalizeForMatch(value);
        if (!normalized) return null;
        for (const [key, aliases] of Object.entries(ORG_ALIASES)) {
          if (valueMatches(normalized, key)) return key;
          if (aliases.some(alias => valueMatches(normalized, alias))) return key;
        }
        return null;
      }

      function getDefaultOrgKey(presetKey) {
        const preset = PRESETS[presetKey];
        if (!preset || !preset.orgs) return 'eukaryote';
        if (preset.orgs.eukaryote) return 'eukaryote';
        const keys = Object.keys(preset.orgs);
        return keys.length ? keys[0] : 'eukaryote';
      }

      function detectSafeMode() {
        const safeParam = normalizeForMatch(URL_PARAMS.get('safe') || URL_PARAMS.get('mode'));
        if (safeParam && ['1', 'true', 'safe', 'on', 'yes'].includes(safeParam)) {
          return true;
        }
        const reduceParam = normalizeForMatch(URL_PARAMS.get('reduceMotion'));
        if (reduceParam && ['1', 'true', 'on', 'yes'].includes(reduceParam)) {
          return true;
        }
        if (typeof window.matchMedia === 'function') {
          try {
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
              return true;
            }
          } catch (error) {
            console.warn('matchMedia check failed', error);
          }
        }
        return false;
      }

      function normalizeForMatch(value) {
        return typeof value === 'string' ? value.toLowerCase().trim() : '';
      }

      function compactKey(value) {
        return normalizeForMatch(value).replace(/[^a-z0-9+]+/g, '');
      }

      function valueMatches(value, candidate) {
        const normalizedCandidate = normalizeForMatch(candidate);
        if (!normalizedCandidate) return false;
        return value === normalizedCandidate || compactKey(value) === compactKey(candidate);
      }

      function includesMatch(value, candidate) {
        const normalizedCandidate = normalizeForMatch(candidate);
        if (!normalizedCandidate) return false;
        return value.includes(normalizedCandidate) || compactKey(value).includes(compactKey(candidate));
      }

      function setupLanguageSwitch() {
        if (!languageSwitch) return;
        const languages = Object.keys(STRINGS);
        if (languages.length <= 1) {
          languageSwitch.hidden = true;
          return;
        }

        languageSwitch.hidden = false;
        languageSwitch.innerHTML = '';
        languageSwitch.setAttribute('role', 'group');
        languageSwitch.setAttribute('aria-label', 'Interface language');

        const labelId = `${languageSwitch.id}-label`;
        const hiddenLabel = document.createElement('span');
        hiddenLabel.className = 'visually-hidden';
        hiddenLabel.id = labelId;
        hiddenLabel.textContent = 'Interface language';
        languageSwitch.appendChild(hiddenLabel);

        const select = document.createElement('select');
        select.className = 'language-switch-control';
        select.setAttribute('aria-labelledby', labelId);
        select.title = 'Interface language';

        languages.forEach(langKey => {
          if (!STRINGS[langKey]) return;
          const option = document.createElement('option');
          option.value = langKey;
          option.textContent = langKey.toUpperCase();
          if (langKey === ACTIVE_LANG) {
            option.selected = true;
          }
          select.appendChild(option);
        });

        select.value = ACTIVE_LANG;

        select.addEventListener('change', () => {
          const nextLang = select.value;
          if (!nextLang || nextLang === ACTIVE_LANG || !STRINGS[nextLang]) {
            select.value = ACTIVE_LANG;
            return;
          }
          const params = new URLSearchParams(window.location.search);
          params.delete('ui-lang');
          params.delete('lang');
          params.delete('locale');
          params.set('ui_lang', nextLang);
          const nextSearch = params.toString();
          const nextUrl = `${window.location.pathname}${nextSearch ? '?' + nextSearch : ''}${window.location.hash}`;
          window.location.assign(nextUrl);
        });

        languageSwitch.appendChild(select);
      }

      function applyStaticText() {
        document.title = getLocaleString('page.title');

        const pageElement = document.querySelector('.page');
        if (pageElement) {
          pageElement.setAttribute('aria-label', getLocaleString('page.ariaLabel'));
        }

        const headerTitle = document.getElementById('header-title');
        if (headerTitle) headerTitle.textContent = getLocaleString('page.header.title');
        const headerPill = document.getElementById('header-pill');
        if (headerPill) headerPill.textContent = getLocaleString('page.header.pill');
        const metaEnvironment = document.getElementById('meta-environment');
        if (metaEnvironment) metaEnvironment.textContent = getLocaleString('page.header.meta.environment');
        const metaContext = document.getElementById('meta-context');
        if (metaContext) metaContext.textContent = getLocaleString('page.header.meta.context');
        const metaFocus = document.getElementById('meta-focus');
        if (metaFocus) metaFocus.textContent = getLocaleString('page.header.meta.focus');

        const mapTitleElement = document.getElementById('map-title');
        if (mapTitleElement) mapTitleElement.textContent = getLocaleString('map.title');
        const mapToolbar = document.getElementById('map-toolbar');
        if (mapToolbar) mapToolbar.setAttribute('aria-label', getLocaleString('map.toolbarAria'));

        if (fitToViewButton) fitToViewButton.textContent = getLocaleString('map.buttons.fit');
        if (toggleGridButton) toggleGridButton.textContent = getLocaleString('map.buttons.grid');
        const snapLabelText = document.getElementById('snap-label-text');
        if (snapLabelText) snapLabelText.textContent = getLocaleString('map.buttons.snap');
        if (resetOverlapButton) resetOverlapButton.textContent = getLocaleString('map.buttons.resetOverlap');
        const presetLabel = document.getElementById('preset-select-label');
        if (presetLabel) presetLabel.textContent = getLocaleString('map.presets.presetLabel');
        if (presetSelect) presetSelect.setAttribute('aria-label', getLocaleString('map.presets.presetAria'));
        const orgLabel = document.getElementById('org-select-label');
        if (orgLabel) orgLabel.textContent = getLocaleString('map.presets.orgLabel');
        if (orgSelect) orgSelect.setAttribute('aria-label', getLocaleString('map.presets.orgAria'));

        if (mapCanvas) mapCanvas.setAttribute('aria-label', getLocaleString('map.canvasAria'));
        const axisLabel = document.getElementById('axis-label');
        if (axisLabel) axisLabel.textContent = getLocaleString('map.axisLabel');
        const instructions = document.getElementById('map-instructions');
        if (instructions) instructions.textContent = getLocaleString('map.instructions');

        const legendElement = document.getElementById('legend');
        if (legendElement) legendElement.setAttribute('aria-label', getLocaleString('map.legendAria'));
        const legendPolii = document.getElementById('legend-polii');
        if (legendPolii) legendPolii.textContent = getLocaleString('map.legend.polii');
        const legendChromatin = document.getElementById('legend-chromatin');
        if (legendChromatin) legendChromatin.textContent = getLocaleString('map.legend.chromatin');
        const legendRna = document.getElementById('legend-rna');
        if (legendRna) legendRna.textContent = getLocaleString('map.legend.rna');
        const legendStrand = document.getElementById('legend-strand');
        if (legendStrand) legendStrand.textContent = getLocaleString('map.legend.strand');
        const legendFrame = document.getElementById('legend-frame');
        if (legendFrame) legendFrame.textContent = getLocaleString('map.legend.frame');

        const stepsTitle = document.getElementById('steps-title');
        if (stepsTitle) stepsTitle.textContent = getLocaleString('timeline.title');
        const timelineContainer = document.getElementById('timeline');
        if (timelineContainer) timelineContainer.setAttribute('aria-label', getLocaleString('timeline.ariaLabel'));

        renderRegulation();

        const modelTitleMain = document.getElementById('model-title-main');
        if (modelTitleMain) modelTitleMain.textContent = getLocaleString('model.title');
        const modelSubheading = document.getElementById('model-subheading');
        if (modelSubheading) modelSubheading.textContent = getLocaleString('model.subheading');
        const modelTabsElement = document.getElementById('model-tabs');
        if (modelTabsElement) modelTabsElement.setAttribute('aria-label', getLocaleString('model.ariaLabel'));

        const footerAttribution = document.getElementById('footer-attribution');
        if (footerAttribution) footerAttribution.textContent = getLocaleString('footer.attribution');
        const footerLicense = document.getElementById('footer-license');
        if (footerLicense) {
          footerLicense.textContent = getLocaleString('footer.license');
          if (SAFE_MODE) {
            const safeNote = getLocaleString('messages.safeMode');
            if (safeNote) {
              footerLicense.textContent = `${footerLicense.textContent} · ${safeNote}`;
            }
          }
        }
        const footerScales = document.getElementById('footer-scales');
        if (footerScales) footerScales.textContent = getLocaleString('footer.scales');
        const exportControls = document.getElementById('export-controls');
        if (exportControls) exportControls.setAttribute('aria-label', getLocaleString('footer.controlsAria'));
        if (exportSvgButton) exportSvgButton.textContent = getLocaleString('footer.buttons.exportSvg');
        if (exportPngButton) exportPngButton.textContent = getLocaleString('footer.buttons.exportPng');
        if (exportPdfButton) exportPdfButton.textContent = getLocaleString('footer.buttons.exportPdf');
        if (exportJsonButton) exportJsonButton.textContent = getLocaleString('footer.buttons.exportJson');
        if (importJsonButton) importJsonButton.textContent = getLocaleString('footer.buttons.importJson');
        if (resetLayoutButton) resetLayoutButton.textContent = getLocaleString('footer.buttons.resetLayout');
        const openReferenceButton = document.getElementById('open-reference');
        if (openReferenceButton) openReferenceButton.textContent = getLocaleString('footer.buttons.openReference');

        populateOverlayTable();
      }

      function renderRegulation() {
        const grid = document.getElementById('regulation-grid');
        if (!grid) return;
        grid.setAttribute('aria-label', getLocaleString('regulation.ariaLabel'));
        grid.innerHTML = '';
        getLocaleArray('regulation.chips').forEach(text => {
          const chip = document.createElement('div');
          chip.className = 'chip';
          chip.textContent = text;
          grid.appendChild(chip);
        });
      }

      function populateOverlayTable() {
        const closeButton = document.getElementById('close-overlay');
        if (closeButton) closeButton.textContent = getLocaleString('overlay.close');
        const overlayTitle = document.getElementById('overlay-title');
        if (overlayTitle) overlayTitle.textContent = getLocaleString('overlay.title');
        const overlayElement = document.getElementById('reference-overlay');
        if (overlayElement) overlayElement.setAttribute('aria-labelledby', 'overlay-title');
        const colModule = document.getElementById('overlay-col-module');
        if (colModule) colModule.textContent = getLocaleString('overlay.columns.module');
        const colComposition = document.getElementById('overlay-col-composition');
        if (colComposition) colComposition.textContent = getLocaleString('overlay.columns.composition');
        const colFunction = document.getElementById('overlay-col-function');
        if (colFunction) colFunction.textContent = getLocaleString('overlay.columns.function');
        const colControl = document.getElementById('overlay-col-control');
        if (colControl) colControl.textContent = getLocaleString('overlay.columns.control');

        const tbody = document.getElementById('overlay-body');
        if (!tbody) return;
        tbody.innerHTML = '';
        const rows = getLocaleEntry('overlay.rows');
        if (Array.isArray(rows)) {
          rows.forEach(row => {
            const tr = document.createElement('tr');
            ['module', 'composition', 'function', 'control'].forEach(key => {
              const td = document.createElement('td');
              const value = typeof row?.[key] === 'string' ? row[key] : '';
              td.textContent = value;
              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });
        }
      }

      function formatSigned(value) {
        const num = Number(value);
        if (!Number.isFinite(num)) return '';
        if (num === 0) return '0';
        const sign = num > 0 ? '+' : '−';
        return `${sign}${Math.abs(num)}`;
      }

      function formatStrandSymbol(strand) {
        const normalized = typeof strand === 'string' ? strand.toLowerCase() : '';
        if (normalized === 'plus' || normalized === '5to3') return '5′→3′';
        if (normalized === 'minus' || normalized === '3to5') return '3′→5′';
        if (normalized === 'bidirectional' || normalized === 'both') return '5′↔3′';
        if (normalized === 'unknown') return 'strand?';
        return '';
      }

      function formatCoordinateRange(coordinates) {
        if (!coordinates) return '';
        const start = formatSigned(coordinates.start);
        const end = formatSigned(coordinates.end);
        if (!start || !end) return '';
        const unit = coordinates.unit ? String(coordinates.unit) : 'bp';
        let text = `${start} … ${end} ${unit}`;
        if (coordinates.reference) {
          text += ` (${coordinates.reference})`;
        }
        return text;
      }

      function formatFrameLabel(frame) {
        if (!frame) return '';
        if (frame.locus) return String(frame.locus);
        if (frame.reference) return String(frame.reference);
        if (frame.chromosome && frame.assembly) return `${frame.chromosome} · ${frame.assembly}`;
        if (frame.chromosome) return String(frame.chromosome);
        if (frame.type) return String(frame.type);
        return '';
      }

      function formatRecognitionSite(site) {
        if (!site) return '';
        const parts = [];
        if (site.name) parts.push(String(site.name));
        const start = formatSigned(site.start);
        const end = formatSigned(site.end);
        if (start && end) {
          parts.push(`${start}–${end}`);
        }
        if (site.sequence) parts.push(String(site.sequence));
        const strand = formatStrandSymbol(site.strand);
        if (strand) parts.push(strand);
        return parts.join(' • ');
      }

      function formatNodeAria(node) {
        const template = getLocaleString('messages.nodeAria') || '';
        let text = template
          .replace(/\{label\}/g, node.label ?? '')
          .replace(/\{type\}/g, node.type ?? '');
        const extras = [];
        const coords = formatCoordinateRange(node.coordinates);
        if (coords) extras.push(coords);
        const strand = formatStrandSymbol(node.strand);
        if (strand) extras.push(strand);
        if (Array.isArray(node.recognitionSites) && node.recognitionSites.length) {
          const siteText = formatRecognitionSite(node.recognitionSites[0]);
          if (siteText) extras.push(siteText);
        }
        if (extras.length) {
          text = `${text} ${extras.join('. ')}.`;
        }
        return text;
      }

      function handleImportFile(event) {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const payload = JSON.parse(reader.result);
            applyImportedState(payload);
            renderNodes();
            updateEdges();
            persistState();
          } catch (error) {
            alert(getLocaleString('messages.importError') + error.message);
          }
        };
        reader.readAsText(file);
        event.target.value = '';
      }

      function handleWheel(event) {
        event.preventDefault();
        if (event.ctrlKey) {
          const factor = event.deltaY < 0 ? 1.1 : 0.9;
          zoomAt(factor, event.clientX, event.clientY);
          persistState();
        } else {
          pan.x -= event.deltaX;
          pan.y -= event.deltaY;
          applyTransform();
          persistState();
        }
      }

      function handlePanStart(event) {
        if (event.button !== 0) return;
        if (!(event.target === mapCanvas || event.target === mapViewport)) return;
        isPanning = true;
        panPointerId = event.pointerId;
        mapCanvas.setPointerCapture(panPointerId);
        mapCanvas.classList.add('panning');
      }

      function handlePanMove(event) {
        if (!isPanning || event.pointerId !== panPointerId) return;
        pan.x += event.movementX;
        pan.y += event.movementY;
        applyTransform();
      }

      function handlePanEnd(event) {
        if (panPointerId !== null && event.pointerId === panPointerId) {
          mapCanvas.releasePointerCapture(panPointerId);
          panPointerId = null;
          isPanning = false;
          mapCanvas.classList.remove('panning');
          persistState();
        }
      }

      function handleCanvasKeydown(event) {
        const panStep = event.shiftKey ? 60 : 30;
        const center = getCanvasCenter();
        let handled = false;
        if (event.key === 'ArrowUp') {
          pan.y += panStep;
          handled = true;
        } else if (event.key === 'ArrowDown') {
          pan.y -= panStep;
          handled = true;
        } else if (event.key === 'ArrowLeft') {
          pan.x += panStep;
          handled = true;
        } else if (event.key === 'ArrowRight') {
          pan.x -= panStep;
          handled = true;
        } else if (event.key === '+' || event.key === '=') {
          zoomAt(1.1, center.x, center.y);
          handled = true;
        } else if (event.key === '-' || event.key === '_') {
          zoomAt(0.9, center.x, center.y);
          handled = true;
        } else if (event.key === '0') {
          fitToView();
          handled = true;
        }
        if (handled) {
          event.preventDefault();
          applyTransform();
          persistState();
        }
      }

      function renderNodes() {
        nodeLayer.innerHTML = '';
        const fragment = document.createDocumentFragment();
        const sorted = Array.from(state.nodes.values()).sort((a, b) => {
          const za = a.z ?? (LAYER_ORDER[a.layer] ?? 1);
          const zb = b.z ?? (LAYER_ORDER[b.layer] ?? 1);
          return za - zb;
        });
        sorted.forEach(node => {
          const element = createNodeElement(node);
          fragment.appendChild(element);
        });
        nodeLayer.appendChild(fragment);
      }

      function createNodeElement(node) {
        const element = document.createElement('div');
        element.className = 'node';
        element.dataset.layer = node.layer;
        element.dataset.id = node.id;
        element.tabIndex = 0;
        element.setAttribute('role', 'group');
        element.setAttribute('aria-label', formatNodeAria(node));
        if (Array.isArray(node.autoCorrections) && node.autoCorrections.length) {
          element.dataset.corrected = 'true';
        } else {
          delete element.dataset.corrected;
        }
        if (node.strand) {
          element.dataset.strand = node.strand;
        } else {
          delete element.dataset.strand;
        }

        const meta = document.createElement('div');
        meta.className = 'node-meta';
        const frameLabel = formatFrameLabel(node.frame);
        if (frameLabel) {
          const badge = document.createElement('span');
          badge.className = 'node-frame';
          if (node.frame?.type) {
            badge.dataset.kind = node.frame.type;
          }
          badge.textContent = frameLabel;
          meta.appendChild(badge);
        }
        const strandLabel = formatStrandSymbol(node.strand);
        if (strandLabel) {
          const strandBadge = document.createElement('span');
          strandBadge.className = 'node-strand';
          strandBadge.textContent = strandLabel;
          meta.appendChild(strandBadge);
        }
        if (meta.childElementCount) {
          element.appendChild(meta);
        }

        const title = document.createElement('div');
        title.className = 'node-title';
        const label = document.createElement('span');
        label.textContent = node.label;
        const type = document.createElement('span');
        type.className = 'node-type';
        type.textContent = node.type;
        title.append(label, type);
        element.appendChild(title);

        const coordinateText = formatCoordinateRange(node.coordinates);
        if (coordinateText) {
          const coords = document.createElement('div');
          coords.className = 'node-coordinates';
          coords.textContent = coordinateText;
          element.appendChild(coords);
        }

        if (Array.isArray(node.recognitionSites) && node.recognitionSites.length) {
          const siteList = document.createElement('ul');
          siteList.className = 'node-sites';
          node.recognitionSites.slice(0, 3).forEach(site => {
            const text = formatRecognitionSite(site);
            if (!text) return;
            const item = document.createElement('li');
            item.textContent = text;
            siteList.appendChild(item);
          });
          if (siteList.childElementCount) {
            element.appendChild(siteList);
          }
        }

        if (Array.isArray(node.notes) && node.notes.length) {
          const list = document.createElement('ul');
          list.className = 'node-notes';
          node.notes.forEach(note => {
            const li = document.createElement('li');
            li.textContent = note;
            list.appendChild(li);
          });
          element.appendChild(list);
        }

        const handle = document.createElement('div');
        handle.className = 'node-handle';
        handle.setAttribute('aria-hidden', 'true');
        handle.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M7 4h2v2H7V4zm4 0h2v2h-2V4zm4 0h2v2h-2V4zM7 9h2v2H7V9zm4 0h2v2h-2V9zm4 0h2v2h-2V9zM7 14h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM7 19h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z"></path></svg><span>${getLocaleString('messages.dragHandle')}</span>`;
        element.appendChild(handle);

        applyNodePosition(element, node);
        attachDrag(element, node);
        element.addEventListener('keydown', event => handleNodeKeydown(event, node, element));
        return element;
      }

      function attachDrag(element, node) {
        let pointerId = null;
        let origin = null;
        element.addEventListener('pointerdown', event => {
          if (event.button !== 0) return;
          pointerId = event.pointerId;
          origin = {
            mapX: getMapPoint(event).x,
            mapY: getMapPoint(event).y,
            nodeX: node.x,
            nodeY: node.y
          };
          element.setPointerCapture(pointerId);
          element.classList.add('dragging');
          const baseZ = node.z ?? (LAYER_ORDER[node.layer] ?? 1);
          element.style.zIndex = String(baseZ + 100);
          event.stopPropagation();
        });

        element.addEventListener('pointermove', event => {
          if (pointerId !== event.pointerId || !origin) return;
          const point = getMapPoint(event);
          let nextX = origin.nodeX + (point.x - origin.mapX);
          let nextY = origin.nodeY + (point.y - origin.mapY);
          if (gridSnapEnabled) {
            nextX = snap(nextX);
            nextY = snap(nextY);
          }
          node.x = nextX;
          node.y = nextY;
          clampNode(node);
          applyNodePosition(element, node, false);
          updateEdges();
        });

        const finish = event => {
          if (pointerId === null || (event && event.pointerId !== pointerId)) return;
          element.releasePointerCapture(pointerId);
          pointerId = null;
          element.classList.remove('dragging');
          resolveOverlapsFor(node);
          applyNodePosition(element, node);
          updateEdges();
          persistState();
        };

        element.addEventListener('pointerup', finish);
        element.addEventListener('pointercancel', finish);
      }

      function handleNodeKeydown(event, node, element) {
        const step = event.shiftKey ? GRID_SIZE * 2 : GRID_SIZE;
        let moved = false;
        if (event.key === 'ArrowUp') {
          node.y -= step;
          moved = true;
        } else if (event.key === 'ArrowDown') {
          node.y += step;
          moved = true;
        } else if (event.key === 'ArrowLeft') {
          node.x -= step;
          moved = true;
        } else if (event.key === 'ArrowRight') {
          node.x += step;
          moved = true;
        }
        if (moved) {
          event.preventDefault();
          if (gridSnapEnabled) {
            node.x = snap(node.x);
            node.y = snap(node.y);
          }
          clampNode(node);
          resolveOverlapsFor(node);
          applyNodePosition(element, node);
          updateEdges();
          persistState();
        }
      }

      function applyNodePosition(element, node, resetZ = true) {
        element.style.left = `${node.x}px`;
        element.style.top = `${node.y}px`;
        element.style.width = `${node.width}px`;
        element.style.height = `${node.height}px`;
        if (resetZ) {
          const baseZ = node.z ?? (LAYER_ORDER[node.layer] ?? 1);
          element.style.zIndex = String(baseZ);
        }
      }

      function getMapPoint(event) {
        const rect = mapCanvas.getBoundingClientRect();
        return {
          x: (event.clientX - rect.left - pan.x) / scale,
          y: (event.clientY - rect.top - pan.y) / scale
        };
      }

      function updateEdges() {
        if (edgeRenderPending) return;
        edgeRenderPending = true;
        requestAnimationFrame(() => {
          edgeRenderPending = false;
          drawEdges();
        });
      }

      function drawEdges() {
        const seen = new Set();
        state.edges.forEach((edge, index) => {
          const from = state.nodes.get(edge.from);
          const to = state.nodes.get(edge.to);
          if (!from || !to) return;
          const key = edge.id ?? `${edge.from}->${edge.to}#${index}`;
          let path = edgeElements.get(key);
          if (!path) {
            path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            edgeElements.set(key, path);
          }
          seen.add(key);
          path.dataset.kind = edge.kind || 'flow';
          path.dataset.router = edge.router || 'orthogonal';
          const d = computeOrthogonalPath(from, to);
          if (path.getAttribute('d') !== d) {
            path.setAttribute('d', d);
          }
          if (edge.strand) {
            path.dataset.strand = edge.strand;
          } else if (path.dataset.strand) {
            delete path.dataset.strand;
          }
          const markerEnd = edge.markers?.end || (edge.kind === 'regulation' ? 'arrow-regulation' : 'arrow-flow');
          if (markerEnd) {
            path.setAttribute('marker-end', `url(#${markerEnd})`);
          } else {
            path.removeAttribute('marker-end');
          }
          if (edge.markers?.start) {
            path.setAttribute('marker-start', `url(#${edge.markers.start})`);
          } else {
            path.removeAttribute('marker-start');
          }
          const tooltipParts = [];
          if (edge.label) tooltipParts.push(edge.label);
          const coordText = formatCoordinateRange(edge.coordinates);
          if (coordText) tooltipParts.push(coordText);
          const strandText = formatStrandSymbol(edge.strand);
          if (strandText) tooltipParts.push(strandText);
          if (Array.isArray(edge.recognitionSites) && edge.recognitionSites.length) {
            const sites = edge.recognitionSites
              .slice(0, 2)
              .map(formatRecognitionSite)
              .filter(Boolean)
              .join('; ');
            if (sites) tooltipParts.push(sites);
          }
          const tooltipText = tooltipParts.join(' • ');
          let title = path.querySelector('title');
          if (tooltipText) {
            if (!title) {
              title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
              path.appendChild(title);
            }
            if (title.textContent !== tooltipText) {
              title.textContent = tooltipText;
            }
          } else if (title) {
            title.remove();
          }
          edgeLayer.appendChild(path);
        });

        const staleKeys = [];
        edgeElements.forEach((path, key) => {
          if (!seen.has(key)) {
            path.remove();
            staleKeys.push(key);
          }
        });
        staleKeys.forEach(key => edgeElements.delete(key));
      }

      function computeOrthogonalPath(from, to) {
        const fromCenter = { x: from.x + from.width / 2, y: from.y + from.height / 2 };
        const toCenter = { x: to.x + to.width / 2, y: to.y + to.height / 2 };
        const horizontalPreference = Math.abs(fromCenter.x - toCenter.x) >= Math.abs(fromCenter.y - toCenter.y);
        let segments = [];
        if (horizontalPreference) {
          const startX = fromCenter.x <= toCenter.x ? from.x + from.width : from.x;
          const endX = fromCenter.x <= toCenter.x ? to.x : to.x + to.width;
          const midX = startX + (endX - startX) / 2;
          segments = [
            `M ${startX} ${fromCenter.y}`,
            `H ${midX}`,
            `V ${toCenter.y}`,
            `H ${endX}`
          ];
        } else {
          const startY = fromCenter.y <= toCenter.y ? from.y + from.height : from.y;
          const endY = fromCenter.y <= toCenter.y ? to.y : to.y + to.height;
          const midY = startY + (endY - startY) / 2;
          segments = [
            `M ${fromCenter.x} ${startY}`,
            `V ${midY}`,
            `H ${toCenter.x}`,
            `V ${endY}`
          ];
        }
        return segments.join(' ');
      }

      function resolveOverlapsFor(node) {
        const others = Array.from(state.nodes.values()).filter(other => other.id !== node.id);
        let iterations = 0;
        while (others.some(other => boxesOverlap(node, other))) {
          node.y = snap(node.y + GRID_SIZE);
          if (node.y + node.height > MAP_HEIGHT) {
            node.y = clamp(node.y - GRID_SIZE, 0, MAP_HEIGHT - node.height);
            node.x = snap(node.x + GRID_SIZE);
          }
          clampNode(node);
          if (++iterations > 200) break;
        }
      }

      function resolveAllOverlaps() {
        const ordered = Array.from(state.nodes.values()).sort((a, b) => a.x - b.x || a.y - b.y);
        ordered.forEach(node => resolveOverlapsFor(node));
      }

      function boxesOverlap(a, b) {
        return !(a.x + a.width <= b.x || b.x + b.width <= a.x || a.y + a.height <= b.y || b.y + b.height <= a.y);
      }

      function clampNode(node) {
        node.width = Math.max(96, node.width);
        node.height = Math.max(80, node.height);
        node.x = clamp(node.x, 0, MAP_WIDTH - node.width);
        node.y = clamp(node.y, 0, MAP_HEIGHT - node.height);
      }

      function snap(value) {
        return Math.round(value / GRID_SIZE) * GRID_SIZE;
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function zoomAt(factor, clientX, clientY) {
        const rect = mapCanvas.getBoundingClientRect();
        const originX = clientX - rect.left;
        const originY = clientY - rect.top;
        const mapX = (originX - pan.x) / scale;
        const mapY = (originY - pan.y) / scale;
        const newScale = clamp(scale * factor, 0.5, 2.5);
        pan.x = originX - mapX * newScale;
        pan.y = originY - mapY * newScale;
        scale = newScale;
        applyTransform();
      }

      function fitToView() {
        const rect = mapCanvas.getBoundingClientRect();
        const scaleX = rect.width / MAP_WIDTH;
        const scaleY = rect.height / MAP_HEIGHT;
        scale = clamp(Math.min(scaleX, scaleY), 0.5, 2.5);
        pan = {
          x: (rect.width - MAP_WIDTH * scale) / 2,
          y: (rect.height - MAP_HEIGHT * scale) / 2
        };
        applyTransform();
      }

      function getCanvasCenter() {
        const rect = mapCanvas.getBoundingClientRect();
        return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      }

      function applyTransform() {
        mapViewport.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${scale})`;
      }

      function cloneNode(node, overrides = {}) {
        const widthInput = Number.isFinite(Number(overrides.width)) ? Number(overrides.width) : node.width;
        const heightInput = Number.isFinite(Number(overrides.height)) ? Number(overrides.height) : node.height;
        const width = clamp(Math.max(96, widthInput), 96, MAP_WIDTH);
        const height = clamp(Math.max(80, heightInput), 80, MAP_HEIGHT);
        let x = Number.isFinite(Number(overrides.x)) ? Number(overrides.x) : node.x;
        let y = Number.isFinite(Number(overrides.y)) ? Number(overrides.y) : node.y;
        x = clamp(x, 0, MAP_WIDTH - width);
        y = clamp(y, 0, MAP_HEIGHT - height);
        const baseNotes = Array.isArray(node.notes) ? node.notes.slice() : [];
        const notes = Array.isArray(overrides.notes) && overrides.notes.length ? overrides.notes.slice(0, 6).map(String) : baseNotes;
        const frame = overrides.frame !== undefined ? cloneFrame(overrides.frame) : cloneFrame(node.frame);
        const coordinates = overrides.coordinates !== undefined ? cloneCoordinates(overrides.coordinates) : cloneCoordinates(node.coordinates);
        const recognitionSites = overrides.recognitionSites !== undefined ? cloneRecognitionSites(overrides.recognitionSites) : cloneRecognitionSites(node.recognitionSites);
        const aliases = overrides.aliases !== undefined ? cloneStringArray(overrides.aliases) : cloneStringArray(node.aliases);
        const timeline = overrides.timeline !== undefined ? cloneTimeline(overrides.timeline) : cloneTimeline(node.timeline);
        const evidence = overrides.evidence !== undefined ? cloneStringArray(overrides.evidence) : cloneStringArray(node.evidence);
        const references = overrides.references !== undefined ? cloneStringArray(overrides.references) : cloneStringArray(node.references);
        const strand = overrides.strand !== undefined ? overrides.strand : node.strand;
        const confidenceValue = overrides.confidence !== undefined ? Number(overrides.confidence) : node.confidence;
        const confidence = Number.isFinite(confidenceValue) ? clamp(confidenceValue, 0, 1) : undefined;
        const result = {
          id: overrides.id ?? node.id,
          label: overrides.label ?? node.label,
          type: overrides.type ?? node.type,
          layer: overrides.layer ?? node.layer,
          x,
          y,
          width,
          height,
          notes,
          z: Number.isFinite(overrides.z) ? overrides.z : node.z ?? (LAYER_ORDER[node.layer] ?? 1),
          frame,
          coordinates,
          strand: strand ?? null,
          recognitionSites,
          aliases,
          timeline,
          evidence,
          references,
          confidence
        };
        return enforceNodeConstraints(result);
      }

      function cloneEdge(edge, overrides = {}) {
        const markers = overrides.markers !== undefined ? cloneMarkers(overrides.markers) : cloneMarkers(edge.markers);
        const frame = overrides.frame !== undefined ? cloneFrame(overrides.frame) : cloneFrame(edge.frame);
        const coordinates = overrides.coordinates !== undefined ? cloneCoordinates(overrides.coordinates) : cloneCoordinates(edge.coordinates);
        const recognitionSites = overrides.recognitionSites !== undefined ? cloneRecognitionSites(overrides.recognitionSites) : cloneRecognitionSites(edge.recognitionSites);
        const timeline = overrides.timeline !== undefined ? cloneTimeline(overrides.timeline) : cloneTimeline(edge.timeline);
        const evidence = overrides.evidence !== undefined ? cloneStringArray(overrides.evidence) : cloneStringArray(edge.evidence);
        const references = overrides.references !== undefined ? cloneStringArray(overrides.references) : cloneStringArray(edge.references);
        const strand = overrides.strand !== undefined ? overrides.strand : edge.strand;
        const confidenceValue = overrides.confidence !== undefined ? Number(overrides.confidence) : edge.confidence;
        const confidence = Number.isFinite(confidenceValue) ? clamp(confidenceValue, 0, 1) : undefined;
        const result = {
          id: overrides.id ?? edge.id,
          from: overrides.from ?? edge.from,
          to: overrides.to ?? edge.to,
          kind: overrides.kind ?? edge.kind ?? 'flow',
          router: overrides.router ?? edge.router ?? 'orthogonal',
          label: overrides.label ?? edge.label ?? '',
          markers,
          frame,
          coordinates,
          strand: strand ?? null,
          recognitionSites,
          timeline,
          evidence,
          references,
          confidence
        };
        return enforceEdgeConstraints(result);
      }

      function enforceNodeConstraints(node) {
        const corrections = [];
        if (!ALLOWED_NODE_LAYERS.has(node.layer)) {
          corrections.push('layer→annotations');
          node.layer = 'annotations';
        }
        if (!Number.isFinite(node.z)) {
          node.z = LAYER_ORDER[node.layer] ?? 1;
        }
        node.width = clamp(node.width, 96, MAP_WIDTH);
        node.height = clamp(node.height, 80, MAP_HEIGHT);
        node.x = clamp(node.x, 0, MAP_WIDTH - node.width);
        node.y = clamp(node.y, 0, MAP_HEIGHT - node.height);

        node.strand = canonicalizeStrand(node.strand, corrections, 'strand');
        if (node.coordinates) {
          sanitizeCoordinateRange(node.coordinates, corrections, 'coordinates');
        }
        if (Array.isArray(node.recognitionSites)) {
          node.recognitionSites = node.recognitionSites
            .map(site => sanitizeRecognitionSite(site, corrections))
            .filter(Boolean);
        }
        if (!Array.isArray(node.notes)) {
          node.notes = [];
        }
        if (!Array.isArray(node.aliases)) {
          node.aliases = [];
        }
        if (node.confidence !== undefined && !Number.isFinite(node.confidence)) {
          corrections.push('confidence→removed');
          delete node.confidence;
        }
        return recordCorrections(node, corrections, { note: true, label: node.id || 'node' });
      }

      function enforceEdgeConstraints(edge) {
        const corrections = [];
        if (!ALLOWED_EDGE_KINDS.has(edge.kind)) {
          corrections.push('kind→flow');
          edge.kind = 'flow';
        }
        if (!ALLOWED_EDGE_ROUTERS.has(edge.router)) {
          corrections.push('router→orthogonal');
          edge.router = 'orthogonal';
        }
        edge.strand = canonicalizeStrand(edge.strand, corrections, 'strand');
        if (edge.coordinates) {
          sanitizeCoordinateRange(edge.coordinates, corrections, 'coordinates');
        }
        if (edge.markers) {
          if (edge.markers.start && !ALLOWED_MARKERS.has(edge.markers.start)) {
            corrections.push('marker(start)→removed');
            delete edge.markers.start;
          }
          if (edge.markers.end && !ALLOWED_MARKERS.has(edge.markers.end)) {
            const fallbackMarker = edge.kind === 'regulation' ? 'arrow-regulation' : 'arrow-flow';
            corrections.push(`marker(end)→${fallbackMarker}`);
            edge.markers.end = fallbackMarker;
          }
        }
        if (Array.isArray(edge.recognitionSites)) {
          edge.recognitionSites = edge.recognitionSites
            .map(site => sanitizeRecognitionSite(site, corrections))
            .filter(Boolean);
        }
        if (edge.confidence !== undefined && !Number.isFinite(edge.confidence)) {
          corrections.push('confidence→removed');
          delete edge.confidence;
        }
        return recordCorrections(edge, corrections, { label: edge.id || 'edge' });
      }

      function canonicalizeStrand(strand, corrections, field) {
        if (strand === null || strand === undefined) return null;
        const value = normalizeForMatch(strand);
        if (!value) return null;
        if (value === 'plus' || value === '5to3' || value === 'forward') {
          if (value !== 'plus') corrections.push(`${field}→plus`);
          return 'plus';
        }
        if (value === 'minus' || value === '3to5' || value === 'reverse') {
          if (value !== 'minus') corrections.push(`${field}→minus`);
          return 'minus';
        }
        if (value === 'bidirectional' || value === 'both') {
          if (value !== 'bidirectional') corrections.push(`${field}→bidirectional`);
          return 'bidirectional';
        }
        if (value === 'unknown' || value === 'na') {
          if (value !== 'unknown') corrections.push(`${field}→unknown`);
          return 'unknown';
        }
        corrections.push(`${field}→unset`);
        return null;
      }

      function sanitizeCoordinateRange(range, corrections, label) {
        if (!range) return;
        if (Number.isFinite(range.start) && Number.isFinite(range.end) && range.start > range.end) {
          const swap = range.start;
          range.start = range.end;
          range.end = swap;
          corrections.push(`${label}.order→ascending`);
        }
        if (range.confidence !== undefined && !Number.isFinite(range.confidence)) {
          delete range.confidence;
          corrections.push(`${label}.confidence→removed`);
        } else if (Number.isFinite(range.confidence)) {
          const clamped = clamp(range.confidence, 0, 1);
          if (clamped !== range.confidence) {
            range.confidence = clamped;
            corrections.push(`${label}.confidence→clamped`);
          }
        }
      }

      function sanitizeRecognitionSite(site, corrections) {
        if (!site || typeof site !== 'object') return null;
        const result = { ...site };
        if (Number.isFinite(result.start) && Number.isFinite(result.end) && result.start > result.end) {
          const swap = result.start;
          result.start = result.end;
          result.end = swap;
          corrections.push('recognitionSites.order→ascending');
        }
        result.strand = canonicalizeStrand(result.strand, corrections, 'recognitionSites.strand');
        return result;
      }

      function recordCorrections(target, corrections, options = {}) {
        const { note = false, label = 'item' } = options;
        if (!Array.isArray(corrections) || !corrections.length) {
          target.autoCorrections = [];
          return target;
        }
        target.autoCorrections = corrections.slice();
        if (note) {
          const prefix = getLocaleString('messages.autoCorrectionPrefix') || 'Auto-corrected:';
          const message = `${prefix} ${corrections.join(', ')}`;
          const current = Array.isArray(target.notes) ? target.notes.slice(0, 7) : [];
          if (!current.includes(message)) {
            current.push(message);
          }
          target.notes = current.slice(0, 8);
        }
        const summaryTemplate = getLocaleString('messages.validationApplied') || 'Adjusted fields: {fields}';
        console.info(`${summaryTemplate.replace('{fields}', corrections.join(', '))} (${label})`);
        return target;
      }

      function restoreState() {
        let restored = false;
        state.nodes = new Map(presetNodes.map(node => [node.id, cloneNode(node)]));
        state.edges = presetEdges.map(edge => cloneEdge(edge));
        gridVisible = true;
        gridSnapEnabled = true;
        try {
          const storedRaw = storageKey ? localStorage.getItem(storageKey) : null;
          if (!storedRaw) {
            applyGridPreferences();
            return restored;
          }
          const stored = JSON.parse(storedRaw);
          if (Array.isArray(stored.nodes)) {
            const merged = new Map(state.nodes);
            stored.nodes.forEach(raw => {
              if (!raw || !raw.id) return;
              const base = merged.get(raw.id) || presetNodes.find(node => node.id === raw.id) || raw;
              merged.set(raw.id, cloneNode(base, raw));
            });
            state.nodes = merged;
            restored = true;
          }
          if (Array.isArray(stored.edges) && stored.edges.length) {
            state.edges = stored.edges.map(edge => cloneEdge(edge));
            restored = true;
          }
          if (stored.transform) {
            scale = clamp(Number(stored.transform.scale) || 1, 0.5, 2.5);
            pan = {
              x: Number.isFinite(Number(stored.transform.pan?.x)) ? Number(stored.transform.pan.x) : 0,
              y: Number.isFinite(Number(stored.transform.pan?.y)) ? Number(stored.transform.pan.y) : 0
            };
            restored = true;
          }
          if (stored.preferences) {
            gridVisible = stored.preferences.gridVisible ?? gridVisible;
            gridSnapEnabled = stored.preferences.gridSnap ?? gridSnapEnabled;
          }
        } catch (error) {
          console.warn(getLocaleString('messages.stateReset'), error);
          if (storageKey) {
            localStorage.removeItem(storageKey);
          }
          gridVisible = true;
          gridSnapEnabled = true;
        }
        applyGridPreferences();
        return restored;
      }

      function applyGridPreferences() {
        mapCanvas.classList.toggle('no-grid', !gridVisible);
        toggleGridButton.classList.toggle('active', gridVisible);
        toggleGridButton.setAttribute('aria-pressed', String(gridVisible));
        snapCheckbox.checked = gridSnapEnabled;
      }

      function exportState() {
        return {
          preset: activePresetKey,
          org: activeOrgKey,
          nodes: Array.from(state.nodes.values()).map(node => cloneNode(node)),
          edges: state.edges.map(edge => cloneEdge(edge)),
          transform: { scale, pan },
          preferences: { gridVisible, gridSnap: gridSnapEnabled }
        };
      }

      function persistState() {
        if (!storageKey) return;
        try {
          const payload = exportState();
          localStorage.setItem(storageKey, JSON.stringify(payload));
        } catch (error) {
          console.warn(getLocaleString('messages.saveError'), error);
        }
      }

      function applyImportedState(payload) {
        if (!payload || !Array.isArray(payload.nodes)) {
          throw new Error(getLocaleString('messages.missingNodes'));
        }
        if (payload.preset && payload.org && (payload.preset !== activePresetKey || payload.org !== activeOrgKey)) {
          applyPreset(payload.preset, payload.org, { skipRender: true, skipPersist: true, skipRestore: true });
        }
        state.nodes = new Map(presetNodes.map(node => [node.id, cloneNode(node)]));
        state.edges = presetEdges.map(edge => cloneEdge(edge));

        const merged = new Map(state.nodes);
        payload.nodes.forEach(raw => {
          if (!raw || !raw.id) return;
          const base = merged.get(raw.id) || presetNodes.find(node => node.id === raw.id) || raw;
          merged.set(raw.id, cloneNode(base, raw));
        });
        state.nodes = merged;

        if (Array.isArray(payload.edges) && payload.edges.length) {
          state.edges = payload.edges.map(edge => cloneEdge(edge));
        } else {
          state.edges = presetEdges.map(edge => cloneEdge(edge));
        }

        if (payload.transform) {
          scale = clamp(Number(payload.transform.scale) || 1, 0.5, 2.5);
          pan = {
            x: Number.isFinite(Number(payload.transform.pan?.x)) ? Number(payload.transform.pan.x) : 0,
            y: Number.isFinite(Number(payload.transform.pan?.y)) ? Number(payload.transform.pan.y) : 0
          };
        }
        if (payload.preferences) {
          gridVisible = payload.preferences.gridVisible ?? gridVisible;
          gridSnapEnabled = payload.preferences.gridSnap ?? gridSnapEnabled;
        }
        applyGridPreferences();
        applyTransform();
      }

      function buildExportSvg() {
        const parts = [];
        const widthMm = ((MAP_WIDTH / CSS_PX_PER_INCH) * MM_PER_INCH).toFixed(2);
        const heightMm = ((MAP_HEIGHT / CSS_PX_PER_INCH) * MM_PER_INCH).toFixed(2);
        const title = escapeXml(getLocaleString('page.title') || 'Pol II transcription initiation map');
        const licenseText = escapeXml(getLocaleString('footer.license'));
        const attributionText = escapeXml(getLocaleString('footer.attribution'));
        const safeNote = SAFE_MODE ? escapeXml(getLocaleString('messages.safeMode')) : '';
        parts.push(`<svg xmlns="http://www.w3.org/2000/svg" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" width="${widthMm}mm" height="${heightMm}mm" viewBox="0 0 ${MAP_WIDTH} ${MAP_HEIGHT}" preserveAspectRatio="xMidYMid meet">`);
        parts.push('<metadata><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title>' + title + '</dc:title><dc:creator><cc:Agent><dc:title>eukaryote lab</dc:title></cc:Agent></dc:creator><dc:description>' + attributionText + '</dc:description><dc:coverage>' + PAGE_WIDTH_MM + 'mm × ' + PAGE_HEIGHT_MM + 'mm</dc:coverage><dc:license rdf:resource="https://creativecommons.org/licenses/by/4.0/"/></cc:Work></rdf:RDF></metadata>');
        const descParts = [attributionText];
        if (licenseText) descParts.push(licenseText);
        if (safeNote) descParts.push(safeNote);
        parts.push(`<desc>${descParts.join(' · ')}</desc>`);
        parts.push('<rect width="100%" height="100%" fill="#f8fafc"/>');
        parts.push('<g stroke-width="1">');
        for (let x = GRID_SIZE; x < MAP_WIDTH; x += GRID_SIZE) {
          const major = x % (GRID_SIZE * 5) === 0;
          const color = major ? 'rgba(29,78,216,0.18)' : 'rgba(148,163,184,0.16)';
          parts.push(`<line x1="${x}" y1="0" x2="${x}" y2="${MAP_HEIGHT}" stroke="${color}"/>`);
        }
        for (let y = GRID_SIZE; y < MAP_HEIGHT; y += GRID_SIZE) {
          const major = y % (GRID_SIZE * 5) === 0;
          const color = major ? 'rgba(29,78,216,0.18)' : 'rgba(148,163,184,0.16)';
          parts.push(`<line x1="0" y1="${y}" x2="${MAP_WIDTH}" y2="${y}" stroke="${color}"/>`);
        }
        parts.push('</g>');
        state.edges.forEach(edge => {
          const from = state.nodes.get(edge.from);
          const to = state.nodes.get(edge.to);
          if (!from || !to) return;
          const d = computeOrthogonalPath(from, to);
          const stroke = edge.kind === 'regulation' ? '#b91c1c' : '#1d4ed8';
          const dash = edge.kind === 'regulation' ? ' stroke-dasharray="6 3"' : '';
          const markerEnd = edge.markers?.end || (edge.kind === 'regulation' ? 'arrow-regulation' : 'arrow-flow');
          const markerStart = edge.markers?.start ? ` marker-start="url(#${escapeXml(edge.markers.start)})"` : '';
          const markerEndAttr = markerEnd ? ` marker-end="url(#${escapeXml(markerEnd)})"` : '';
          const strandAttr = edge.strand ? ` data-strand="${escapeXml(edge.strand)}"` : '';
          const tooltipParts = [];
          if (edge.label) tooltipParts.push(edge.label);
          const coordText = formatCoordinateRange(edge.coordinates);
          if (coordText) tooltipParts.push(coordText);
          const strandText = formatStrandSymbol(edge.strand);
          if (strandText) tooltipParts.push(strandText);
          if (Array.isArray(edge.recognitionSites) && edge.recognitionSites.length) {
            const sites = edge.recognitionSites.slice(0, 2).map(formatRecognitionSite).filter(Boolean).join('; ');
            if (sites) tooltipParts.push(sites);
          }
          const title = tooltipParts.length ? `<title>${escapeXml(tooltipParts.join(' • '))}</title>` : '';
          parts.push(`<path d="${d}" fill="none" stroke="${stroke}" stroke-width="2.5"${dash}${markerStart}${markerEndAttr}${strandAttr}>${title}</path>`);
        });
        parts.push('<defs>');
        parts.push('<marker id="arrow-flow" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="#1d4ed8"></path></marker>');
        parts.push('<marker id="arrow-regulation" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="#b91c1c"></path></marker>');
        parts.push('<marker id="tee-regulation" viewBox="0 0 10 10" refX="2" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto"><path d="M 2 0 L 2 10" stroke="#b91c1c" stroke-width="2"></path></marker>');
        parts.push('</defs>');
        const nodes = Array.from(state.nodes.values()).sort((a, b) => (a.z ?? LAYER_ORDER[a.layer] ?? 1) - (b.z ?? LAYER_ORDER[b.layer] ?? 1));
        nodes.forEach(node => {
          const style = LAYER_STYLE[node.layer] || { fill: '#e2e8f0', stroke: '#475569' };
          parts.push('<g>');
          parts.push(`<rect x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="10" ry="10" fill="${style.fill}" stroke="${style.stroke}" stroke-width="1.5"/>`);
          let cursorY = node.y + 20;
          const frameText = formatFrameLabel(node.frame);
          if (frameText) {
            parts.push(`<text x="${node.x + 12}" y="${cursorY}" font-size="8" font-family="Fira Sans, Segoe UI, sans-serif" fill="#2563eb" font-weight="600">${escapeXml(frameText)}</text>`);
            cursorY += 12;
          }
          parts.push(`<text x="${node.x + 12}" y="${cursorY}" font-size="12" font-family="Fira Sans, Segoe UI, sans-serif" font-weight="600" fill="#111111">${escapeXml(node.label)}</text>`);
          cursorY += 16;
          parts.push(`<text x="${node.x + 12}" y="${cursorY}" font-size="9" font-family="Fira Sans, Segoe UI, sans-serif" fill="#475569">${escapeXml(node.type)}</text>`);
          cursorY += 14;
          const coordText = formatCoordinateRange(node.coordinates);
          if (coordText) {
            parts.push(`<text x="${node.x + 12}" y="${cursorY}" font-size="9" font-family="Fira Sans, Segoe UI, sans-serif" fill="#1f2937">${escapeXml(coordText)}</text>`);
            cursorY += 12;
          }
          const strandText = formatStrandSymbol(node.strand);
          if (strandText) {
            parts.push(`<text x="${node.x + 12}" y="${cursorY}" font-size="9" font-family="Fira Sans, Segoe UI, sans-serif" fill="#0f172a">${escapeXml(strandText)}</text>`);
            cursorY += 12;
          }
          if (Array.isArray(node.recognitionSites) && node.recognitionSites.length) {
            node.recognitionSites.slice(0, 2).forEach(site => {
              const siteText = formatRecognitionSite(site);
              if (!siteText) return;
              parts.push(`<text x="${node.x + 12}" y="${cursorY}" font-size="8" font-family="Fira Sans, Segoe UI, sans-serif" fill="#334155">${escapeXml(siteText)}</text>`);
              cursorY += 12;
            });
          }
          const notesStart = Math.max(cursorY + 8, node.y + 58);
          if (Array.isArray(node.notes)) {
            node.notes.forEach((note, index) => {
              const noteY = notesStart + index * 14;
              if (noteY < node.y + node.height - 8) {
                parts.push(`<text x="${node.x + 12}" y="${noteY}" font-size="9" font-family="Fira Sans, Segoe UI, sans-serif" fill="#4b5563">${escapeXml(note)}</text>`);
              }
            });
          }
          parts.push('</g>');
        });
        parts.push('</svg>');
        return parts.join('');
      }

      function download(filename, content, type) {
        const blob = content instanceof Blob ? content : new Blob([content], { type });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        setTimeout(() => URL.revokeObjectURL(link.href), 0);
      }

      function handlePngFallback(svgMarkup) {
        const fallbackMessage = getLocaleString('messages.pngFallback');
        if (fallbackMessage) {
          console.warn(fallbackMessage);
          try {
            alert(fallbackMessage);
          } catch (error) {
            console.warn('Alert unavailable for PNG fallback', error);
          }
        }
        download(buildExportFilename('svg'), `<?xml version="1.0" encoding="UTF-8"?>\n${svgMarkup}`, 'image/svg+xml;charset=utf-8');
      }

      function escapeXml(value) {
        return String(value ?? '').replace(/[&<>"']/g, char => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[char]));
      }

      function setupTimeline() {
        const timelineContainer = document.getElementById('timeline');
        const stepPanel = document.getElementById('step-panel');
        if (!timelineContainer || !stepPanel) return;

        timelineContainer.innerHTML = '';
        const steps = getLocaleEntry('timeline.steps') || {};
        const orderSource = getLocaleEntry('timeline.order');
        const order = Array.isArray(orderSource) ? orderSource : TIMELINE_ORDER;
        let activeKey = null;

        order.forEach(key => {
          const step = steps?.[key];
          if (!step) return;
          const button = document.createElement('button');
          button.type = 'button';
          button.dataset.step = key;
          button.setAttribute('role', 'tab');
          button.setAttribute('aria-selected', 'false');

          const titleSpan = document.createElement('span');
          titleSpan.className = 'title';
          titleSpan.textContent = typeof step.buttonTitle === 'string' ? step.buttonTitle : '';
          const detailSpan = document.createElement('span');
          detailSpan.className = 'detail';
          detailSpan.textContent = typeof step.buttonDetail === 'string' ? step.buttonDetail : '';
          button.append(titleSpan, detailSpan);

          button.addEventListener('click', () => selectStep(key));

          timelineContainer.appendChild(button);
          if (activeKey === null) {
            activeKey = key;
            button.classList.add('active');
            button.setAttribute('aria-selected', 'true');
          }
        });

        function selectStep(stepKey) {
          const step = steps?.[stepKey];
          if (!step) return;
          Array.from(timelineContainer.children).forEach(child => {
            if (!(child instanceof HTMLElement)) return;
            const isActive = child.dataset.step === stepKey;
            child.classList.toggle('active', isActive);
            child.setAttribute('aria-selected', String(isActive));
          });
          stepPanel.innerHTML = '';
          const title = document.createElement('h3');
          title.textContent = typeof step.panelTitle === 'string' ? step.panelTitle : '';
          stepPanel.appendChild(title);
          const list = document.createElement('ul');
          const points = Array.isArray(step.panelPoints) ? step.panelPoints : [];
          points.forEach(point => {
            const li = document.createElement('li');
            li.textContent = point;
            list.appendChild(li);
          });
          stepPanel.appendChild(list);
        }

        if (activeKey) {
          selectStep(activeKey);
        } else {
          stepPanel.innerHTML = '';
        }
      }

      function setupOverlay() {
        const overlay = document.getElementById('reference-overlay');
        const openButton = document.getElementById('open-reference');
        const closeButton = document.getElementById('close-overlay');
        openButton.addEventListener('click', () => overlay.classList.add('active'));
        closeButton.addEventListener('click', () => overlay.classList.remove('active'));
        overlay.addEventListener('click', event => {
          if (event.target === overlay) {
            overlay.classList.remove('active');
          }
        });
      }

      function setupModelTabs() {
        const modelButtons = document.querySelectorAll('.model-tabs button');
        const modelPanel = document.getElementById('model-panel');
        if (!modelButtons.length || !modelPanel) return;

        const tabLabels = getLocaleEntry('model.tabs') || {};
        modelButtons.forEach(button => {
          const key = button.dataset.model;
          button.textContent = typeof tabLabels?.[key] === 'string' ? tabLabels[key] : '';
          button.setAttribute('role', 'tab');
          button.setAttribute('aria-selected', button.classList.contains('active') ? 'true' : 'false');
        });

        const content = getLocaleEntry('model.content') || {};

        function renderModelSection(key) {
          const section = content?.[key];
          modelPanel.innerHTML = '';
          if (!section) return;
          const title = document.createElement('h3');
          title.textContent = typeof section.title === 'string' ? section.title : '';
          modelPanel.appendChild(title);
          const list = document.createElement('ul');
          const items = Array.isArray(section.items) ? section.items : [];
          items.forEach(item => {
            const li = document.createElement('li');
            li.innerHTML = item;
            list.appendChild(li);
          });
          modelPanel.appendChild(list);
          if (section.callout) {
            const callout = document.createElement('div');
            callout.className = 'callout';
            callout.innerHTML = section.callout;
            modelPanel.appendChild(callout);
          }
          if (section.snippet) {
            const pre = document.createElement('pre');
            pre.textContent = section.snippet;
            modelPanel.appendChild(pre);
          }
        }

        modelButtons.forEach(button => {
          button.addEventListener('click', () => {
            modelButtons.forEach(other => {
              const isActive = other === button;
              other.classList.toggle('active', isActive);
              other.setAttribute('aria-selected', String(isActive));
            });
            renderModelSection(button.dataset.model);
          });
        });

        const activeButton = Array.from(modelButtons).find(btn => btn.classList.contains('active')) || modelButtons[0];
        if (activeButton) {
          modelButtons.forEach(btn => {
            const isActive = btn === activeButton;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-selected', String(isActive));
          });
          renderModelSection(activeButton.dataset.model);
        }
      }


    })();
  </script>
</body>
</html>
